var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== 'symbol' ? key + '' : key, value);
  return value;
};
(function polyfill() {
  const relList = document.createElement('link').relList;
  if (relList && relList.supports && relList.supports('modulepreload')) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== 'childList') {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === 'LINK' && node.rel === 'modulepreload')
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity)
      fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy)
      fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === 'use-credentials')
      fetchOpts.credentials = 'include';
    else if (link.crossOrigin === 'anonymous')
      fetchOpts.credentials = 'omit';
    else
      fetchOpts.credentials = 'same-origin';
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
function setCallbacks(element, callbacks) {
  callbacks.forEach(({ eventType, callback }) => {
    element.addEventListener(eventType, callback);
  });
}
function createElement$1(params) {
  const element = document.createElement(params.tag);
  if (params.classNames) {
    params.classNames.forEach((cssClass) => element.classList.add(cssClass));
  }
  if (params.textContent) {
    element.textContent = params.textContent;
  }
  if (params.attributes) {
    Object.keys(params.attributes).forEach((attrName) => {
      if (params.attributes) {
        element.setAttribute(attrName, params.attributes[attrName]);
      }
    });
  }
  if (params.callbacks) {
    setCallbacks(element, params.callbacks);
  }
  return element;
}
function addInnerComponent(parent, child) {
  if (child) {
    parent.appendChild(child);
  } else {
    console.error('Attempted to add a non-existent child element to parent:', parent);
  }
}
function clear(element) {
  if (element) {
    element.innerHTML = '';
  }
}
class EventEmitter {
  constructor() {
    __publicField(this, 'listeners', {});
  }

  on(eventType, listener) {
    if (!this.listeners[eventType]) {
      this.listeners[eventType] = [];
    }
    this.listeners[eventType].push(listener);
  }

  emit(eventType, data) {
    const listeners = this.listeners[eventType];
    if (listeners) {
      listeners.forEach((listener) => listener(data));
    }
  }
}
const appEvents = new EventEmitter();
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, 'default') ? x2.default : x2;
}
var define_global_default = {};
var g = typeof globalThis !== 'undefined' && globalThis || typeof self !== 'undefined' && self || // eslint-disable-next-line no-undef
typeof define_global_default !== 'undefined' && define_global_default || {};
var support$1 = {
  searchParams: 'URLSearchParams' in g,
  iterable: 'Symbol' in g && 'iterator' in Symbol,
  blob: 'FileReader' in g && 'Blob' in g && function () {
    try {
      new Blob();
      return true;
    } catch (e) {
      return false;
    }
  }(),
  formData: 'FormData' in g,
  arrayBuffer: 'ArrayBuffer' in g,
};
function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj);
}
if (support$1.arrayBuffer) {
  var viewClasses = [
    '[object Int8Array]',
    '[object Uint8Array]',
    '[object Uint8ClampedArray]',
    '[object Int16Array]',
    '[object Uint16Array]',
    '[object Int32Array]',
    '[object Uint32Array]',
    '[object Float32Array]',
    '[object Float64Array]',
  ];
  var isArrayBufferView = ArrayBuffer.isView || function (obj) {
    return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
  };
}
function normalizeName(name) {
  if (typeof name !== 'string') {
    name = String(name);
  }
  if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {
    throw new TypeError('Invalid character in header field name: "' + name + '"');
  }
  return name.toLowerCase();
}
function normalizeValue(value) {
  if (typeof value !== 'string') {
    value = String(value);
  }
  return value;
}
function iteratorFor(items) {
  var iterator = {
    next: function () {
      var value = items.shift();
      return { done: value === void 0, value };
    },
  };
  if (support$1.iterable) {
    iterator[Symbol.iterator] = function () {
      return iterator;
    };
  }
  return iterator;
}
function Headers(headers) {
  this.map = {};
  if (headers instanceof Headers) {
    headers.forEach(function (value, name) {
      this.append(name, value);
    }, this);
  } else if (Array.isArray(headers)) {
    headers.forEach(function (header) {
      if (header.length != 2) {
        throw new TypeError('Headers constructor: expected name/value pair to be length 2, found' + header.length);
      }
      this.append(header[0], header[1]);
    }, this);
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function (name) {
      this.append(name, headers[name]);
    }, this);
  }
}
Headers.prototype.append = function (name, value) {
  name = normalizeName(name);
  value = normalizeValue(value);
  var oldValue = this.map[name];
  this.map[name] = oldValue ? oldValue + ', ' + value : value;
};
Headers.prototype.delete = function (name) {
  delete this.map[normalizeName(name)];
};
Headers.prototype.get = function (name) {
  name = normalizeName(name);
  return this.has(name) ? this.map[name] : null;
};
Headers.prototype.has = function (name) {
  return this.map.hasOwnProperty(normalizeName(name));
};
Headers.prototype.set = function (name, value) {
  this.map[normalizeName(name)] = normalizeValue(value);
};
Headers.prototype.forEach = function (callback, thisArg) {
  for (var name in this.map) {
    if (this.map.hasOwnProperty(name)) {
      callback.call(thisArg, this.map[name], name, this);
    }
  }
};
Headers.prototype.keys = function () {
  var items = [];
  this.forEach(function (value, name) {
    items.push(name);
  });
  return iteratorFor(items);
};
Headers.prototype.values = function () {
  var items = [];
  this.forEach(function (value) {
    items.push(value);
  });
  return iteratorFor(items);
};
Headers.prototype.entries = function () {
  var items = [];
  this.forEach(function (value, name) {
    items.push([name, value]);
  });
  return iteratorFor(items);
};
if (support$1.iterable) {
  Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
}
function consumed(body) {
  if (body._noBody)
    return;
  if (body.bodyUsed) {
    return Promise.reject(new TypeError('Already read'));
  }
  body.bodyUsed = true;
}
function fileReaderReady(reader) {
  return new Promise(function (resolve, reject) {
    reader.onload = function () {
      resolve(reader.result);
    };
    reader.onerror = function () {
      reject(reader.error);
    };
  });
}
function readBlobAsArrayBuffer(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsArrayBuffer(blob);
  return promise;
}
function readBlobAsText(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
  var encoding = match ? match[1] : 'utf-8';
  reader.readAsText(blob, encoding);
  return promise;
}
function readArrayBufferAsText(buf) {
  var view = new Uint8Array(buf);
  var chars = new Array(view.length);
  for (var i = 0; i < view.length; i++) {
    chars[i] = String.fromCharCode(view[i]);
  }
  return chars.join('');
}
function bufferClone(buf) {
  if (buf.slice) {
    return buf.slice(0);
  } else {
    var view = new Uint8Array(buf.byteLength);
    view.set(new Uint8Array(buf));
    return view.buffer;
  }
}
function Body() {
  this.bodyUsed = false;
  this._initBody = function (body) {
    this.bodyUsed = this.bodyUsed;
    this._bodyInit = body;
    if (!body) {
      this._noBody = true;
      this._bodyText = '';
    } else if (typeof body === 'string') {
      this._bodyText = body;
    } else if (support$1.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body;
    } else if (support$1.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body;
    } else if (support$1.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString();
    } else if (support$1.arrayBuffer && support$1.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer);
      this._bodyInit = new Blob([this._bodyArrayBuffer]);
    } else if (support$1.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body);
    } else {
      this._bodyText = body = Object.prototype.toString.call(body);
    }
    if (!this.headers.get('content-type')) {
      if (typeof body === 'string') {
        this.headers.set('content-type', 'text/plain;charset=UTF-8');
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set('content-type', this._bodyBlob.type);
      } else if (support$1.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
      }
    }
  };
  if (support$1.blob) {
    this.blob = function () {
      var rejected = consumed(this);
      if (rejected) {
        return rejected;
      }
      if (this._bodyBlob) {
        return Promise.resolve(this._bodyBlob);
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(new Blob([this._bodyArrayBuffer]));
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as blob');
      } else {
        return Promise.resolve(new Blob([this._bodyText]));
      }
    };
  }
  this.arrayBuffer = function () {
    if (this._bodyArrayBuffer) {
      var isConsumed = consumed(this);
      if (isConsumed) {
        return isConsumed;
      } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
        return Promise.resolve(
          this._bodyArrayBuffer.buffer.slice(
            this._bodyArrayBuffer.byteOffset,
            this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength,
          ),
        );
      } else {
        return Promise.resolve(this._bodyArrayBuffer);
      }
    } else if (support$1.blob) {
      return this.blob().then(readBlobAsArrayBuffer);
    } else {
      throw new Error('could not read as ArrayBuffer');
    }
  };
  this.text = function () {
    var rejected = consumed(this);
    if (rejected) {
      return rejected;
    }
    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob);
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
    } else if (this._bodyFormData) {
      throw new Error('could not read FormData body as text');
    } else {
      return Promise.resolve(this._bodyText);
    }
  };
  if (support$1.formData) {
    this.formData = function () {
      return this.text().then(decode);
    };
  }
  this.json = function () {
    return this.text().then(JSON.parse);
  };
  return this;
}
var methods = ['CONNECT', 'DELETE', 'GET', 'HEAD', 'OPTIONS', 'PATCH', 'POST', 'PUT', 'TRACE'];
function normalizeMethod(method) {
  var upcased = method.toUpperCase();
  return methods.indexOf(upcased) > -1 ? upcased : method;
}
function Request(input, options) {
  if (!(this instanceof Request)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }
  options = options || {};
  var body = options.body;
  if (input instanceof Request) {
    if (input.bodyUsed) {
      throw new TypeError('Already read');
    }
    this.url = input.url;
    this.credentials = input.credentials;
    if (!options.headers) {
      this.headers = new Headers(input.headers);
    }
    this.method = input.method;
    this.mode = input.mode;
    this.signal = input.signal;
    if (!body && input._bodyInit != null) {
      body = input._bodyInit;
      input.bodyUsed = true;
    }
  } else {
    this.url = String(input);
  }
  this.credentials = options.credentials || this.credentials || 'same-origin';
  if (options.headers || !this.headers) {
    this.headers = new Headers(options.headers);
  }
  this.method = normalizeMethod(options.method || this.method || 'GET');
  this.mode = options.mode || this.mode || null;
  this.signal = options.signal || this.signal || function () {
    if ('AbortController' in g) {
      var ctrl = new AbortController();
      return ctrl.signal;
    }
  }();
  this.referrer = null;
  if ((this.method === 'GET' || this.method === 'HEAD') && body) {
    throw new TypeError('Body not allowed for GET or HEAD requests');
  }
  this._initBody(body);
  if (this.method === 'GET' || this.method === 'HEAD') {
    if (options.cache === 'no-store' || options.cache === 'no-cache') {
      var reParamSearch = /([?&])_=[^&]*/;
      if (reParamSearch.test(this.url)) {
        this.url = this.url.replace(reParamSearch, '$1_=' + (/* @__PURE__ */ new Date()).getTime());
      } else {
        var reQueryString = /\?/;
        this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + (/* @__PURE__ */ new Date()).getTime();
      }
    }
  }
}
Request.prototype.clone = function () {
  return new Request(this, { body: this._bodyInit });
};
function decode(body) {
  var form = new FormData();
  body.trim().split('&').forEach(function (bytes) {
    if (bytes) {
      var split = bytes.split('=');
      var name = split.shift().replace(/\+/g, ' ');
      var value = split.join('=').replace(/\+/g, ' ');
      form.append(decodeURIComponent(name), decodeURIComponent(value));
    }
  });
  return form;
}
function parseHeaders$1(rawHeaders) {
  var headers = new Headers();
  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
  preProcessedHeaders.split('\r').map(function (header) {
    return header.indexOf('\n') === 0 ? header.substr(1, header.length) : header;
  }).forEach(function (line) {
    var parts = line.split(':');
    var key = parts.shift().trim();
    if (key) {
      var value = parts.join(':').trim();
      try {
        headers.append(key, value);
      } catch (error) {
        console.warn('Response ' + error.message);
      }
    }
  });
  return headers;
}
Body.call(Request.prototype);
function Response(bodyInit, options) {
  if (!(this instanceof Response)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }
  if (!options) {
    options = {};
  }
  this.type = 'default';
  this.status = options.status === void 0 ? 200 : options.status;
  if (this.status < 200 || this.status > 599) {
    throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
  }
  this.ok = this.status >= 200 && this.status < 300;
  this.statusText = options.statusText === void 0 ? '' : '' + options.statusText;
  this.headers = new Headers(options.headers);
  this.url = options.url || '';
  this._initBody(bodyInit);
}
Body.call(Response.prototype);
Response.prototype.clone = function () {
  return new Response(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new Headers(this.headers),
    url: this.url,
  });
};
Response.error = function () {
  var response = new Response(null, { status: 200, statusText: '' });
  response.ok = false;
  response.status = 0;
  response.type = 'error';
  return response;
};
var redirectStatuses = [301, 302, 303, 307, 308];
Response.redirect = function (url, status) {
  if (redirectStatuses.indexOf(status) === -1) {
    throw new RangeError('Invalid status code');
  }
  return new Response(null, { status, headers: { location: url } });
};
var DOMException = g.DOMException;
try {
  new DOMException();
} catch (err) {
  DOMException = function (message, name) {
    this.message = message;
    this.name = name;
    var error = Error(message);
    this.stack = error.stack;
  };
  DOMException.prototype = Object.create(Error.prototype);
  DOMException.prototype.constructor = DOMException;
}
function fetch$2(input, init) {
  return new Promise(function (resolve, reject) {
    var request = new Request(input, init);
    if (request.signal && request.signal.aborted) {
      return reject(new DOMException('Aborted', 'AbortError'));
    }
    var xhr = new XMLHttpRequest();
    function abortXhr() {
      xhr.abort();
    }
    xhr.onload = function () {
      var options = {
        statusText: xhr.statusText,
        headers: parseHeaders$1(xhr.getAllResponseHeaders() || ''),
      };
      if (request.url.indexOf('file://') === 0 && (xhr.status < 200 || xhr.status > 599)) {
        options.status = 200;
      } else {
        options.status = xhr.status;
      }
      options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
      var body = 'response' in xhr ? xhr.response : xhr.responseText;
      setTimeout(function () {
        resolve(new Response(body, options));
      }, 0);
    };
    xhr.onerror = function () {
      setTimeout(function () {
        reject(new TypeError('Network request failed'));
      }, 0);
    };
    xhr.ontimeout = function () {
      setTimeout(function () {
        reject(new TypeError('Network request timed out'));
      }, 0);
    };
    xhr.onabort = function () {
      setTimeout(function () {
        reject(new DOMException('Aborted', 'AbortError'));
      }, 0);
    };
    function fixUrl(url) {
      try {
        return url === '' && g.location.href ? g.location.href : url;
      } catch (e) {
        return url;
      }
    }
    xhr.open(request.method, fixUrl(request.url), true);
    if (request.credentials === 'include') {
      xhr.withCredentials = true;
    } else if (request.credentials === 'omit') {
      xhr.withCredentials = false;
    }
    if ('responseType' in xhr) {
      if (support$1.blob) {
        xhr.responseType = 'blob';
      } else if (support$1.arrayBuffer) {
        xhr.responseType = 'arraybuffer';
      }
    }
    if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers || g.Headers && init.headers instanceof g.Headers)) {
      var names2 = [];
      Object.getOwnPropertyNames(init.headers).forEach(function (name) {
        names2.push(normalizeName(name));
        xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
      });
      request.headers.forEach(function (value, name) {
        if (names2.indexOf(name) === -1) {
          xhr.setRequestHeader(name, value);
        }
      });
    } else {
      request.headers.forEach(function (value, name) {
        xhr.setRequestHeader(name, value);
      });
    }
    if (request.signal) {
      request.signal.addEventListener('abort', abortXhr);
      xhr.onreadystatechange = function () {
        if (xhr.readyState === 4) {
          request.signal.removeEventListener('abort', abortXhr);
        }
      };
    }
    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
  });
}
fetch$2.polyfill = true;
if (!g.fetch) {
  g.fetch = fetch$2;
  g.Headers = Headers;
  g.Request = Request;
  g.Response = Response;
}
var fetchNpmBrowserify = self.fetch.bind(self);
const fetch$1 = /* @__PURE__ */ getDefaultExportFromCjs(fetchNpmBrowserify);
var buffer = {};
var base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  }
  var validLen = b64.indexOf('=');
  if (validLen === -1)
    validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
    output.push(tripletToBase64(tmp));
  }
  return output.join('');
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(
      lookup[tmp >> 2] + lookup[tmp << 4 & 63] + '==',
    );
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(
      lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + '=',
    );
  }
  return parts.join('');
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function (buffer2, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer2[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer2[offset + i], i += d, nBits -= 8) {
  }
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer2[offset + i], i += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
ieee754.write = function (buffer2, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
  }
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
  }
  buffer2[offset + i - d] |= s * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function (exports) {
  const base64 = base64Js;
  const ieee754$1 = ieee754;
  const customInspectSymbol = typeof Symbol === 'function' && typeof Symbol.for === 'function' ? Symbol.for('nodejs.util.inspect.custom') : null;
  exports.Buffer = Buffer2;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports.kMaxLength = K_MAX_LENGTH;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(
      'This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.',
    );
  }
  function typedArraySupport() {
    try {
      const arr = new Uint8Array(1);
      const proto = { foo: function () {
        return 42;
      } };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, 'parent', {
    enumerable: true,
    get: function () {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.buffer;
    },
  });
  Object.defineProperty(Buffer2.prototype, 'offset', {
    enumerable: true,
    get: function () {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.byteOffset;
    },
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function Buffer2(arg, encodingOrOffset, length) {
    if (typeof arg === 'number') {
      if (typeof encodingOrOffset === 'string') {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number',
        );
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  Buffer2.poolSize = 8192;
  function from(value, encodingOrOffset, length) {
    if (typeof value === 'string') {
      return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError(
        'The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value,
      );
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === 'number') {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number',
      );
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer2.from(valueOf, encodingOrOffset, length);
    }
    const b = fromObject(value);
    if (b)
      return b;
    if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {
      return Buffer2.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
    }
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value,
    );
  }
  Buffer2.from = function (value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer2, Uint8Array);
  function assertSize(size) {
    if (typeof size !== 'number') {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size);
    }
    if (fill !== void 0) {
      return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
  }
  Buffer2.alloc = function (size, fill, encoding) {
    return alloc(size, fill, encoding);
  };
  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }
  Buffer2.allocUnsafe = function (size) {
    return allocUnsafe(size);
  };
  Buffer2.allocUnsafeSlow = function (size) {
    return allocUnsafe(size);
  };
  function fromString(string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') {
      encoding = 'utf8';
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
    const length = byteLength2(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for (let i = 0; i < length; i += 1) {
      buf[i] = array[i] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy = new Uint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new Uint8Array(array);
    } else if (length === void 0) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer2.isBuffer(obj)) {
      const len = checked(obj.length) | 0;
      const buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer2.alloc(+length);
  }
  Buffer2.isBuffer = function isBuffer2(b) {
    return b != null && b._isBuffer === true && b !== Buffer2.prototype;
  };
  Buffer2.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array))
      a = Buffer2.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array))
      b = Buffer2.from(b, b.offset, b.byteLength);
    if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array',
      );
    }
    if (a === b)
      return 0;
    let x2 = a.length;
    let y = b.length;
    for (let i = 0, len = Math.min(x2, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x2 = a[i];
        y = b[i];
        break;
      }
    }
    if (x2 < y)
      return -1;
    if (y < x2)
      return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'latin1':
      case 'binary':
      case 'base64':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer2.alloc(0);
    }
    let i;
    if (length === void 0) {
      length = 0;
      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }
    const buffer2 = Buffer2.allocUnsafe(length);
    let pos = 0;
    for (i = 0; i < list.length; ++i) {
      let buf = list[i];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer2.length) {
          if (!Buffer2.isBuffer(buf))
            buf = Buffer2.from(buf);
          buf.copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(
            buffer2,
            buf,
            pos,
          );
        }
      } else if (!Buffer2.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength2(string, encoding) {
    if (Buffer2.isBuffer(string)) {
      return string.length;
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== 'string') {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string,
      );
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0)
      return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case 'ascii':
        case 'latin1':
        case 'binary':
          return len;
        case 'utf8':
        case 'utf-8':
          return utf8ToBytes(string).length;
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2;
        case 'hex':
          return len >>> 1;
        case 'base64':
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length;
          }
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength2;
  function slowToString(encoding, start, end) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return '';
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return '';
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return '';
    }
    if (!encoding)
      encoding = 'utf8';
    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end);
        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end);
        case 'ascii':
          return asciiSlice(this, start, end);
        case 'latin1':
        case 'binary':
          return latin1Slice(this, start, end);
        case 'base64':
          return base64Slice(this, start, end);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError('Unknown encoding: ' + encoding);
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
  }
  Buffer2.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 16-bits');
    }
    for (let i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 32-bits');
    }
    for (let i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 64-bits');
    }
    for (let i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0)
      return '';
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals(b) {
    if (!Buffer2.isBuffer(b))
      throw new TypeError('Argument must be a Buffer');
    if (this === b)
      return true;
    return Buffer2.compare(this, b) === 0;
  };
  Buffer2.prototype.inspect = function inspect() {
    let str = '';
    const max = exports.INSPECT_MAX_BYTES;
    str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
    if (this.length > max)
      str += ' ... ';
    return '<Buffer ' + str + '>';
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer2.from(target, target.offset, target.byteLength);
    }
    if (!Buffer2.isBuffer(target)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target,
      );
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError('out of range index');
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    let x2 = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x2, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for (let i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x2 = thisCopy[i];
        y = targetCopy[i];
        break;
      }
    }
    if (x2 < y)
      return -1;
    if (y < x2)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === 'string') {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === 'string') {
      val = Buffer2.from(val, encoding);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === 'number') {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === 'function') {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError('val must be string, number or Buffer');
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read(buf, i2) {
      if (indexSize === 1) {
        return buf[i2];
      } else {
        return buf.readUInt16BE(i2 * indexSize);
      }
    }
    let i;
    if (dir) {
      let foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i;
          if (i - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        let found = true;
        for (let j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false;
            break;
          }
        }
        if (found)
          return i;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    const strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    let i;
    for (i = 0; i < length; ++i) {
      const parsed = parseInt(string.substr(i * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i;
      buf[offset + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer2.prototype.write = function write(string, offset, length, encoding) {
    if (offset === void 0) {
      encoding = 'utf8';
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0)
          encoding = 'utf8';
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error(
        'Buffer.write(string, encoding, offset[, length]) is no longer supported',
      );
    }
    const remaining = this.length - offset;
    if (length === void 0 || length > remaining)
      length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError('Attempt to write outside buffer bounds');
    }
    if (!encoding)
      encoding = 'utf8';
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length);
        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length);
        case 'ascii':
        case 'latin1':
        case 'binary':
          return asciiWrite(this, string, offset, length);
        case 'base64':
          return base64Write(this, string, offset, length);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase)
            throw new TypeError('Unknown encoding: ' + encoding);
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON() {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0),
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while (i < end) {
      const firstByte = buf[i];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = '';
    let i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH),
      );
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    let ret = '';
    end = Math.min(buf.length, end);
    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    let ret = '';
    end = Math.min(buf.length, end);
    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    let out = '';
    for (let i = start; i < end; ++i) {
      out += hexSliceLookupTable[buf[i]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = '';
    for (let i = 0; i < bytes.length - 1; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0)
        end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start)
      end = start;
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError('offset is not uint');
    if (offset + ext > length)
      throw new RangeError('Trying to access beyond buffer length');
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length);
    }
    let val = this[offset + --byteLength3];
    let mul = 1;
    while (byteLength3 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength3] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  });
  Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  });
  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let i = byteLength3;
    let mul = 1;
    let val = this[offset + --i];
    while (i > 0 && (mul *= 256)) {
      val += this[offset + --i] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
  });
  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer2.isBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError('Index out of range');
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let i = byteLength3 - 1;
    let mul = 1;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
  }
  function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
  }
  Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
  });
  Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
  });
  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i = byteLength3 - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
  });
  Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
  });
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length)
      throw new RangeError('Index out of range');
    if (offset < 0)
      throw new RangeError('Index out of range');
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer2.isBuffer(target))
      throw new TypeError('argument should be a Buffer');
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds');
    }
    if (start < 0 || start >= this.length)
      throw new RangeError('Index out of range');
    if (end < 0)
      throw new RangeError('sourceEnd out of bounds');
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
      this.copyWithin(targetStart, start, end);
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, end),
        targetStart,
      );
    }
    return len;
  };
  Buffer2.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === 'string') {
      if (typeof start === 'string') {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === 'string') {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== 'string') {
        throw new TypeError('encoding must be a string');
      }
      if (typeof encoding === 'string' && !Buffer2.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding);
      }
      if (val.length === 1) {
        const code2 = val.charCodeAt(0);
        if (encoding === 'utf8' && code2 < 128 || encoding === 'latin1') {
          val = code2;
        }
      }
    } else if (typeof val === 'number') {
      val = val & 255;
    } else if (typeof val === 'boolean') {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError('Out of range index');
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val)
      val = 0;
    let i;
    if (typeof val === 'number') {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
      const len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }
    return this;
  };
  const errors = {};
  function E(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, 'message', {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true,
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }

      get code() {
        return sym;
      }

      set code(value) {
        Object.defineProperty(this, 'code', {
          configurable: true,
          enumerable: true,
          value,
          writable: true,
        });
      }

      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E(
    'ERR_BUFFER_OUT_OF_BOUNDS',
    function (name) {
      if (name) {
        return `${name} is outside of buffer bounds`;
      }
      return 'Attempt to access memory outside buffer bounds';
    },
    RangeError,
  );
  E(
    'ERR_INVALID_ARG_TYPE',
    function (name, actual) {
      return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
    },
    TypeError,
  );
  E(
    'ERR_OUT_OF_RANGE',
    function (str, range, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === 'bigint') {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += 'n';
      }
      msg += ` It must be ${range}. Received ${received}`;
      return msg;
    },
    RangeError,
  );
  function addNumericalSeparator(val) {
    let res = '';
    let i = val.length;
    const start = val[0] === '-' ? 1 : 0;
    for (; i >= start + 4; i -= 3) {
      res = `_${val.slice(i - 3, i)}${res}`;
    }
    return `${val.slice(0, i)}${res}`;
  }
  function checkBounds(buf, offset, byteLength3) {
    validateNumber(offset, 'offset');
    if (buf[offset] === void 0 || buf[offset + byteLength3] === void 0) {
      boundsError(offset, buf.length - (byteLength3 + 1));
    }
  }
  function checkIntBI(value, min, max, buf, offset, byteLength3) {
    if (value > max || value < min) {
      const n = typeof min === 'bigint' ? 'n' : '';
      let range;
      {
        if (min === 0 || min === BigInt(0)) {
          range = `>= 0${n} and < 2${n} ** ${(byteLength3 + 1) * 8}${n}`;
        } else {
          range = `>= -(2${n} ** ${(byteLength3 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n}`;
        }
      }
      throw new errors.ERR_OUT_OF_RANGE('value', range, value);
    }
    checkBounds(buf, offset, byteLength3);
  }
  function validateNumber(value, name) {
    if (typeof value !== 'number') {
      throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value);
    }
  }
  function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type);
      throw new errors.ERR_OUT_OF_RANGE('offset', 'an integer', value);
    }
    if (length < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE(
      'offset',
      `>= ${0} and <= ${length}`,
      value,
    );
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split('=')[0];
    str = str.trim().replace(INVALID_BASE64_RE, '');
    if (str.length < 2)
      return '';
    while (str.length % 4 !== 0) {
      str = str + '=';
    }
    return str;
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for (let i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128,
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128,
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128,
        );
      } else {
        throw new Error('Invalid code point');
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      byteArray.push(str.charCodeAt(i) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0)
        break;
      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    let i;
    for (i = 0; i < length; ++i) {
      if (i + offset >= dst.length || i >= src.length)
        break;
      dst[i + offset] = src[i];
    }
    return i;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function () {
    const alphabet = '0123456789abcdef';
    const table = new Array(256);
    for (let i = 0; i < 16; ++i) {
      const i16 = i * 16;
      for (let j = 0; j < 16; ++j) {
        table[i16 + j] = alphabet[i] + alphabet[j];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn) {
    return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error('BigInt not supported');
  }
})(buffer);
function toPrimitive$1(t, r) {
  if ('object' != typeof t || !t)
    return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || 'default');
    if ('object' != typeof i)
      return i;
    throw new TypeError('@@toPrimitive must return a primitive value.');
  }
  return ('string' === r ? String : Number)(t);
}
function toPropertyKey$1(t) {
  var i = toPrimitive$1(t, 'string');
  return 'symbol' == typeof i ? i : i + '';
}
function _defineProperty$1(obj, key, value) {
  key = toPropertyKey$1(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true,
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function isDefined$1(value) {
  return typeof value !== 'undefined' && value !== null;
}
function clean(value) {
  if (!isDefined$1(value))
    return '';
  if (typeof value == 'string')
    return value;
  return Object.fromEntries(Object.entries(value).filter(([_, value2]) => ![null, void 0, ''].includes(value2)));
}
function urlParser(url) {
  const object = {};
  const data = new URLSearchParams(url);
  for (let x2 of data.keys()) {
    if (data.getAll(x2).length > 1) {
      object[x2] = data.getAll(x2);
    } else {
      object[x2] = data.get(x2);
    }
  }
  return object;
}
function urlStringifier(object) {
  object = clean(object);
  if (!object)
    return '';
  const params = new URLSearchParams(object);
  for (const [key, value] of Object.entries(object)) {
    if (Array.isArray(value)) {
      params.delete(key);
      value.filter(isDefined$1).forEach((v) => params.append(key, v));
    }
  }
  return params.toString();
}
function parseURLString(url, parser = urlParser) {
  return parser(url);
}
function stringifyURLString(object, stringifier = urlStringifier) {
  return stringifier(object);
}
var METHODS = ['ACL', 'BIND', 'CHECKOUT', 'CONNECT', 'COPY', 'DELETE', 'GET', 'HEAD', 'LINK', 'LOCK', 'M-SEARCH', 'MERGE', 'MKACTIVITY', 'MKCALENDAR', 'MKCOL', 'MOVE', 'NOTIFY', 'OPTIONS', 'PATCH', 'POST', 'PROPFIND', 'PROPPATCH', 'PURGE', 'PUT', 'REBIND', 'REPORT', 'SEARCH', 'SOURCE', 'SUBSCRIBE', 'TRACE', 'UNBIND', 'UNLINK', 'UNLOCK', 'UNSUBSCRIBE'];
function validate$1(funcName, request, options = {
  allowedMethods: METHODS,
}) {
  if (!request)
    throw new Error(`The "${funcName}" function requires a "Request" object as an argument. See https://commercetools.github.io/nodejs/sdk/Glossary.html#clientrequest`);
  if (typeof request.uri !== 'string')
    throw new Error(`The "${funcName}" Request object requires a valid uri. See https://commercetools.github.io/nodejs/sdk/Glossary.html#clientrequest`);
  if (!options.allowedMethods.includes(request.method))
    throw new Error(`The "${funcName}" Request object requires a valid method. See https://commercetools.github.io/nodejs/sdk/Glossary.html#clientrequest`);
}
let _options;
const PAGE_LIMIT = 20;
function compose(...funcs) {
  funcs = funcs.filter((func) => typeof func === 'function');
  if (funcs.length === 1)
    return funcs[0];
  return funcs.reduce((a, b) => (...args) => a(b(...args)));
}
function process$1(request, fn, processOpt) {
  validate$1('process', request, {
    allowedMethods: ['GET'],
  });
  if (typeof fn !== 'function')
    throw new Error('The "process" function accepts a "Function" as a second argument that returns a Promise. See https://commercetools.github.io/nodejs/sdk/api/sdkClient.html#processrequest-processfn-options');
  const opt = {
    limit: PAGE_LIMIT,
    // defaults
    total: Number.POSITIVE_INFINITY,
    accumulate: true,
    ...processOpt,
  };
  return new Promise((resolve, reject) => {
    let _path, _queryString = '';
    if (request && request.uri) {
      const [path, queryString] = request.uri.split('?');
      _path = path;
      _queryString = queryString;
    }
    const requestQuery = {
      ...parseURLString(_queryString),
    };
    const query = {
      // defaults
      limit: opt.limit,
      // merge given query params
      ...requestQuery,
    };
    let hasFirstPageBeenProcessed = false;
    let itemsToGet = opt.total;
    const processPage = async (lastId, acc = []) => {
      const limit = query.limit < itemsToGet ? query.limit : itemsToGet;
      const originalQueryString = stringifyURLString({
        ...query,
        limit,
      });
      const enhancedQuery = {
        sort: opt.sort || 'id asc',
        withTotal: false,
        ...lastId ? {
          where: `id > "${lastId}"`,
        } : {},
      };
      const enhancedQueryString = stringifyURLString(enhancedQuery);
      const enhancedRequest = {
        ...request,
        uri: `${_path}?${enhancedQueryString}&${originalQueryString}`,
      };
      try {
        const payload = await createClient(_options).execute(enhancedRequest);
        const {
          results,
          count: resultsLength,
        } = payload.body;
        if (!resultsLength && hasFirstPageBeenProcessed) {
          return resolve(acc || []);
        }
        const result = await Promise.resolve(fn(payload));
        let accumulated = [];
        hasFirstPageBeenProcessed = true;
        if (opt.accumulate)
          accumulated = acc.concat(result || []);
        itemsToGet -= resultsLength;
        if (resultsLength < query.limit || !itemsToGet) {
          return resolve(accumulated || []);
        }
        const last = results[resultsLength - 1];
        const newLastId = last && last.id;
        processPage(newLastId, accumulated);
      } catch (error) {
        reject(error);
      }
    };
    processPage();
  });
}
function createClient(options) {
  _options = options;
  if (!options)
    throw new Error('Missing required options');
  if (options.middlewares && !Array.isArray(options.middlewares))
    throw new Error('Middlewares should be an array');
  if (!options.middlewares || !Array.isArray(options.middlewares) || !options.middlewares.length)
    throw new Error('You need to provide at least one middleware');
  return {
    /**
     * Given a request object,
     */
    process: process$1,
    execute(request) {
      validate$1('exec', request);
      return new Promise((resolve, reject) => {
        const resolver = (rq, rs) => {
          if (rs.error)
            rs.reject(rs.error);
          else {
            const resObj = {
              body: rs.body || {},
              statusCode: rs.statusCode,
            };
            if (rs.headers)
              resObj.headers = rs.headers;
            if (rs.request)
              resObj.request = rs.request;
            rs.resolve(resObj);
          }
        };
        const dispatch = compose(...options.middlewares)(resolver);
        dispatch(
          request,
          // Initial response shape
          {
            resolve,
            reject,
            body: void 0,
            error: void 0,
          },
        );
      });
    },
  };
}
function buildRequestForClientCredentialsFlow(options) {
  if (!options)
    throw new Error('Missing required options');
  if (!options.host)
    throw new Error('Missing required option (host)');
  if (!options.projectKey)
    throw new Error('Missing required option (projectKey)');
  if (!options.credentials)
    throw new Error('Missing required option (credentials)');
  const {
    clientId,
    clientSecret,
  } = options.credentials;
  if (!(clientId && clientSecret))
    throw new Error('Missing required credentials (clientId, clientSecret)');
  const scope = options.scopes ? options.scopes.join(' ') : void 0;
  const basicAuth = buffer.Buffer.from(`${clientId}:${clientSecret}`).toString('base64');
  const oauthUri = options.oauthUri || '/oauth/token';
  const url = options.host.replace(/\/$/, '') + oauthUri;
  const body = `grant_type=client_credentials${scope ? `&scope=${scope}` : ''}`;
  return {
    basicAuth,
    url,
    body,
  };
}
function buildRequestForPasswordFlow(options) {
  if (!options)
    throw new Error('Missing required options');
  if (!options.host)
    throw new Error('Missing required option (host)');
  if (!options.projectKey)
    throw new Error('Missing required option (projectKey)');
  if (!options.credentials)
    throw new Error('Missing required option (credentials)');
  const {
    clientId,
    clientSecret,
    user,
  } = options.credentials;
  const pKey = options.projectKey;
  if (!(clientId && clientSecret && user))
    throw new Error('Missing required credentials (clientId, clientSecret, user)');
  const {
    username,
    password,
  } = user;
  if (!(username && password))
    throw new Error('Missing required user credentials (username, password)');
  const scope = (options.scopes || []).join(' ');
  const scopeStr = scope ? `&scope=${scope}` : '';
  const basicAuth = buffer.Buffer.from(`${clientId}:${clientSecret}`).toString('base64');
  const oauthUri = options.oauthUri || `/oauth/${pKey}/customers/token`;
  const url = options.host.replace(/\/$/, '') + oauthUri;
  const body = `grant_type=password&username=${encodeURIComponent(username)}&password=${encodeURIComponent(password)}${scopeStr}`;
  return {
    basicAuth,
    url,
    body,
  };
}
function buildRequestForRefreshTokenFlow(options) {
  if (!options)
    throw new Error('Missing required options');
  if (!options.host)
    throw new Error('Missing required option (host)');
  if (!options.projectKey)
    throw new Error('Missing required option (projectKey)');
  if (!options.credentials)
    throw new Error('Missing required option (credentials)');
  if (!options.refreshToken)
    throw new Error('Missing required option (refreshToken)');
  const {
    clientId,
    clientSecret,
  } = options.credentials;
  if (!(clientId && clientSecret))
    throw new Error('Missing required credentials (clientId, clientSecret)');
  const basicAuth = buffer.Buffer.from(`${clientId}:${clientSecret}`).toString('base64');
  const oauthUri = options.oauthUri || '/oauth/token';
  const url = options.host.replace(/\/$/, '') + oauthUri;
  const body = `grant_type=refresh_token&refresh_token=${encodeURIComponent(options.refreshToken)}`;
  return {
    basicAuth,
    url,
    body,
  };
}
function buildRequestForAnonymousSessionFlow(options) {
  if (!options)
    throw new Error('Missing required options');
  if (!options.projectKey)
    throw new Error('Missing required option (projectKey)');
  const pKey = options.projectKey;
  options.oauthUri = options.oauthUri || `/oauth/${pKey}/anonymous/token`;
  const result = buildRequestForClientCredentialsFlow(options);
  if (options.credentials.anonymousId)
    result.body += `&anonymous_id=${options.credentials.anonymousId}`;
  return {
    ...result,
  };
}
function mergeAuthHeader(token, req) {
  return {
    ...req,
    headers: {
      ...req.headers,
      Authorization: `Bearer ${token}`,
    },
  };
}
function calculateExpirationTime(expiresIn) {
  return Date.now() + // Add a gap of 5 minutes before expiration time.
  expiresIn * 1e3 - 5 * 60 * 1e3;
}
async function executeRequest({
  fetcher,
  url,
  basicAuth,
  body,
  tokenCache,
  requestState,
  pendingTasks,
  response,
  tokenCacheKey,
}) {
  try {
    const _res = await fetcher(url, {
      method: 'POST',
      headers: {
        Authorization: `Basic ${basicAuth}`,
        'Content-Length': buffer.Buffer.byteLength(body).toString(),
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body,
    });
    if (_res.ok) {
      const {
        access_token: token,
        expires_in: expiresIn,
        refresh_token: refreshToken,
      } = await _res.json();
      const expirationTime = calculateExpirationTime(expiresIn);
      tokenCache.set({
        token,
        expirationTime,
        refreshToken,
      }, tokenCacheKey);
      requestState.set(false);
      const executionQueue = pendingTasks.slice();
      pendingTasks = [];
      executionQueue.forEach((task) => {
        const requestWithAuth = mergeAuthHeader(token, task.request);
        task.next(requestWithAuth, task.response);
      });
      return;
    }
    let parsed;
    const text = await _res.text();
    try {
      parsed = JSON.parse(text);
    } catch (error2) {
    }
    const error = new Error(parsed ? parsed.message : text);
    if (parsed)
      error.body = parsed;
    requestState.set(false);
    response.reject(error);
  } catch (error) {
    requestState.set(false);
    if (response && typeof response.reject === 'function')
      response.reject(error);
  }
}
function authMiddlewareBase({
  request,
  response,
  url,
  basicAuth,
  body,
  pendingTasks,
  requestState,
  tokenCache,
  tokenCacheKey,
  fetch: fetcher,
}, next, userOptions) {
  if (!fetcher && typeof fetch === 'undefined')
    throw new Error('`fetch` is not available. Please pass in `fetch` as an option or have it globally available.');
  if (!fetcher)
    fetcher = fetch;
  if (request.headers && request.headers.authorization || request.headers && request.headers.Authorization) {
    next(request, response);
    return;
  }
  const tokenObj = tokenCache.get(tokenCacheKey);
  if (tokenObj && tokenObj.token && Date.now() < tokenObj.expirationTime) {
    const requestWithAuth = mergeAuthHeader(tokenObj.token, request);
    next(requestWithAuth, response);
    return;
  }
  pendingTasks.push({
    request,
    response,
    next,
  });
  if (requestState.get())
    return;
  requestState.set(true);
  if (tokenObj && tokenObj.refreshToken && (!tokenObj.token || tokenObj.token && Date.now() > tokenObj.expirationTime)) {
    if (!userOptions)
      throw new Error('Missing required options');
    executeRequest({
      fetcher,
      ...buildRequestForRefreshTokenFlow({
        ...userOptions,
        refreshToken: tokenObj.refreshToken,
      }),
      tokenCacheKey,
      tokenCache,
      requestState,
      pendingTasks,
      response,
    });
    return;
  }
  executeRequest({
    fetcher,
    url,
    basicAuth,
    body,
    tokenCacheKey,
    tokenCache,
    requestState,
    pendingTasks,
    response,
  });
}
function store(initVal) {
  let value = initVal;
  return {
    get: (TokenCacheOption) => value,
    set: (val, TokenCacheOption) => {
      value = val;
    },
  };
}
function createAuthMiddlewareForAnonymousSessionFlow$1(options) {
  const tokenCache = options.tokenCache || store({
    token: '',
    expirationTime: -1,
  });
  const pendingTasks = [];
  const requestState = store(false);
  return (next) => (request, response) => {
    if (request.headers && request.headers.authorization || request.headers && request.headers.Authorization) {
      next(request, response);
      return;
    }
    const params = {
      request,
      response,
      ...buildRequestForAnonymousSessionFlow(options),
      pendingTasks,
      requestState,
      tokenCache,
      fetch: options.fetch,
    };
    authMiddlewareBase(params, next, options);
  };
}
function buildTokenCacheKey(options) {
  return {
    clientId: options.credentials.clientId,
    host: options.host,
    projectKey: options.projectKey,
  };
}
function createAuthMiddlewareForClientCredentialsFlow$1(options) {
  const tokenCache = options.tokenCache || store({
    token: '',
    expirationTime: -1,
  });
  const requestState = store(false);
  const pendingTasks = [];
  return (next) => (request, response) => {
    if (request.headers && request.headers.authorization || request.headers && request.headers.Authorization) {
      next(request, response);
      return;
    }
    const params = {
      request,
      response,
      ...buildRequestForClientCredentialsFlow(options),
      pendingTasks,
      requestState,
      tokenCache,
      tokenCacheKey: buildTokenCacheKey(options),
      fetch: options.fetch,
    };
    authMiddlewareBase(params, next);
  };
}
function createAuthMiddlewareWithExistingToken$1(authorization = '', options = {}) {
  return (next) => (request, response) => {
    if (typeof authorization !== 'string')
      throw new Error('authorization must be a string');
    const force = options.force === void 0 ? true : options.force;
    if (!authorization || (request.headers && request.headers.authorization || request.headers && request.headers.Authorization) && force === false) {
      return next(request, response);
    }
    const requestWithAuth = {
      ...request,
      headers: {
        ...request.headers,
        Authorization: authorization,
      },
    };
    return next(requestWithAuth, response);
  };
}
function createAuthMiddlewareForPasswordFlow$1(options) {
  const tokenCache = options.tokenCache || store({});
  const pendingTasks = [];
  const requestState = store(false);
  return (next) => (request, response) => {
    if (request.headers && request.headers.authorization || request.headers && request.headers.Authorization) {
      next(request, response);
      return;
    }
    const params = {
      request,
      response,
      ...buildRequestForPasswordFlow(options),
      pendingTasks,
      requestState,
      tokenCache,
      fetch: options.fetch,
    };
    authMiddlewareBase(params, next, options);
  };
}
function createAuthMiddlewareForRefreshTokenFlow$1(options) {
  const tokenCache = options.tokenCache || store({
    token: '',
    expirationTime: -1,
  });
  const pendingTasks = [];
  const requestState = store(false);
  return (next) => (request, response) => {
    if (request.headers && request.headers.authorization || request.headers && request.headers.Authorization) {
      next(request, response);
      return;
    }
    const params = {
      request,
      response,
      ...buildRequestForRefreshTokenFlow(options),
      pendingTasks,
      requestState,
      tokenCache,
      fetch: options.fetch,
    };
    authMiddlewareBase(params, next);
  };
}
var authMiddlewares = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  createAuthMiddlewareForAnonymousSessionFlow: createAuthMiddlewareForAnonymousSessionFlow$1,
  createAuthMiddlewareForClientCredentialsFlow: createAuthMiddlewareForClientCredentialsFlow$1,
  createAuthMiddlewareWithExistingToken: createAuthMiddlewareWithExistingToken$1,
  createAuthMiddlewareForPasswordFlow: createAuthMiddlewareForPasswordFlow$1,
  createAuthMiddlewareForRefreshTokenFlow: createAuthMiddlewareForRefreshTokenFlow$1,
});
function createCorrelationIdMiddleware(options) {
  return (next) => (request, response) => {
    const nextRequest = {
      ...request,
      headers: {
        ...request.headers,
        'X-Correlation-ID': options.generate(),
      },
    };
    next(nextRequest, response);
  };
}
function defineError(statusCode, message, meta = {}) {
  this.status = this.statusCode = this.code = statusCode;
  this.message = message;
  Object.assign(this, meta);
  this.name = this.constructor.name;
  this.constructor.prototype.__proto__ = Error.prototype;
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, this.constructor);
}
function NetworkError(...args) {
  defineError.call(this, 0, ...args);
}
function HttpError(...args) {
  defineError.call(this, ...args);
}
function BadRequest(...args) {
  defineError.call(this, 400, ...args);
}
function Unauthorized(...args) {
  defineError.call(this, 401, ...args);
}
function Forbidden(...args) {
  defineError.call(this, 403, ...args);
}
function NotFound(...args) {
  defineError.call(this, 404, ...args);
}
function ConcurrentModification(...args) {
  defineError.call(this, 409, ...args);
}
function InternalServerError(...args) {
  defineError.call(this, 500, ...args);
}
function ServiceUnavailable(...args) {
  defineError.call(this, 503, ...args);
}
function getErrorByCode(code2) {
  switch (code2) {
    case 0:
      return NetworkError;
    case 400:
      return BadRequest;
    case 401:
      return Unauthorized;
    case 403:
      return Forbidden;
    case 404:
      return NotFound;
    case 409:
      return ConcurrentModification;
    case 500:
      return InternalServerError;
    case 503:
      return ServiceUnavailable;
    default:
      return void 0;
  }
}
function parseHeaders(headers) {
  if (headers.raw)
    return headers.raw();
  if (!headers.forEach)
    return {};
  const map = {};
  headers.forEach((value, name) => {
    map[name] = value;
  });
  return map;
}
function isBuffer(obj) {
  return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
}
function createError({
  statusCode,
  message,
  ...rest
}) {
  var _a;
  let errorMessage = message || 'Unexpected non-JSON error response';
  if (statusCode === 404) {
    errorMessage = `URI not found: ${((_a = rest.originalRequest) == null ? void 0 : _a.uri) || rest.uri}`;
    delete rest.uri;
  }
  const ResponseError = getErrorByCode(statusCode);
  if (ResponseError)
    return new ResponseError(errorMessage, rest);
  return new HttpError(statusCode, errorMessage, rest);
}
function calcDelayDuration(retryCount, retryDelay, maxRetries, backoff, maxDelay) {
  if (backoff)
    return retryCount !== 0 ? Math.min(Math.round((Math.random() + 1) * retryDelay * 2 ** retryCount), maxDelay) : retryDelay;
  return retryDelay;
}
function maskAuthData(request, maskSensitiveHeaderData) {
  if (maskSensitiveHeaderData) {
    if (request && request.headers && request.headers.authorization)
      request.headers.authorization = 'Bearer ********';
    if (request && request.headers && request.headers.Authorization)
      request.headers.Authorization = 'Bearer ********';
  }
}
function createHttpMiddleware({
  host,
  credentialsMode,
  includeResponseHeaders,
  includeOriginalRequest,
  includeRequestInErrorResponse = true,
  maskSensitiveHeaderData = true,
  headersWithStringBody = [],
  enableRetry,
  timeout,
  retryConfig: {
    // encourage exponential backoff to prevent spamming the server if down
    maxRetries = 10,
    backoff = true,
    retryDelay = 200,
    maxDelay = Infinity,
    // If set to true reinitialize the abort controller when the timeout is reached and apply the retry config
    retryOnAbort = false,
    retryCodes = [503],
  } = {},
  fetch: fetcher,
  getAbortController,
}) {
  if (!fetcher)
    throw new Error('`fetch` is not available. Please pass in `fetch` as an option or have it globally available.');
  if (timeout && !getAbortController)
    throw new Error('`AbortController` is not available. Please pass in `getAbortController` as an option or have AbortController globally available when using timeout.');
  let fetchFunction;
  if (fetcher) {
    fetchFunction = fetcher;
  } else {
    fetchFunction = fetch;
  }
  if (!Array.isArray(retryCodes)) {
    throw new Error('`retryCodes` option must be an array of retry status (error) codes.');
  }
  if (!Array.isArray(headersWithStringBody)) {
    throw new Error('`headersWithStringBody` option must be an array of strings');
  }
  return (next) => (request, response) => {
    const url = host.replace(/\/$/, '') + request.uri;
    const requestHeader = {
      ...request.headers,
    };
    if (!(Object.prototype.hasOwnProperty.call(requestHeader, 'Content-Type') || Object.prototype.hasOwnProperty.call(requestHeader, 'content-type'))) {
      requestHeader['Content-Type'] = 'application/json';
    }
    if (requestHeader['Content-Type'] === null) {
      delete requestHeader['Content-Type'];
    }
    const body = ['application/json', 'application/graphql', ...headersWithStringBody].indexOf(requestHeader['Content-Type']) > -1 && typeof request.body === 'string' || isBuffer(request.body) ? request.body : JSON.stringify(request.body || void 0);
    if (body && (typeof body === 'string' || isBuffer(body))) {
      requestHeader['Content-Length'] = buffer.Buffer.byteLength(body).toString();
    }
    const fetchOptions = {
      method: request.method,
      headers: requestHeader,
    };
    if (credentialsMode) {
      fetchOptions.credentialsMode = credentialsMode;
    }
    if (body) {
      fetchOptions.body = body;
    }
    let retryCount = 0;
    function executeFetch() {
      let timer;
      let abortController;
      if (timeout) {
        abortController = (getAbortController ? getAbortController() : null) || new AbortController();
        fetchOptions.signal = abortController.signal;
        timer = setTimeout(() => {
          abortController.abort();
        }, timeout);
      }
      fetchFunction(url, fetchOptions).then(
        (res) => {
          if (res.ok) {
            if (fetchOptions.method === 'HEAD') {
              next(request, {
                ...response,
                statusCode: res.status,
              });
              return;
            }
            res.text().then((result) => {
              let parsed;
              try {
                parsed = result.length > 0 ? JSON.parse(result) : {};
              } catch (err) {
                if (enableRetry && retryCount < maxRetries) {
                  setTimeout(executeFetch, calcDelayDuration(retryCount, retryDelay, maxRetries, backoff, maxDelay));
                  retryCount += 1;
                  return;
                }
                parsed = result;
              }
              const parsedResponse = {
                ...response,
                body: parsed,
                statusCode: res.status,
              };
              if (includeResponseHeaders)
                parsedResponse.headers = parseHeaders(res.headers);
              if (includeOriginalRequest) {
                parsedResponse.request = {
                  ...fetchOptions,
                };
                maskAuthData(parsedResponse.request, maskSensitiveHeaderData);
              }
              next(request, parsedResponse);
            }).catch((err) => {
              if (enableRetry && retryCount < maxRetries) {
                setTimeout(executeFetch, calcDelayDuration(retryCount, retryDelay, maxRetries, backoff, maxDelay));
                retryCount += 1;
                return;
              }
              const error = new NetworkError(err.message, {
                ...includeRequestInErrorResponse ? {
                  originalRequest: request,
                } : {},
                retryCount,
              });
              maskAuthData(error.originalRequest, maskSensitiveHeaderData);
              next(request, {
                ...response,
                error,
                statusCode: 0,
              });
            });
            return;
          }
          res.text().then((text) => {
            let parsed;
            try {
              parsed = JSON.parse(text);
            } catch (error2) {
              parsed = text;
            }
            const error = createError({
              statusCode: res.status,
              ...includeRequestInErrorResponse ? {
                originalRequest: request,
              } : res.status === 404 ? {
                uri: request.uri,
              } : {},
              retryCount,
              headers: parseHeaders(res.headers),
              ...typeof parsed === 'object' ? {
                message: parsed.message,
                body: parsed,
              } : {
                message: parsed,
                body: parsed,
              },
            });
            if (enableRetry && (retryCodes.indexOf(error.statusCode) !== -1 || (retryCodes == null ? void 0 : retryCodes.indexOf(error.message)) !== -1)) {
              if (retryCount < maxRetries) {
                setTimeout(executeFetch, calcDelayDuration(retryCount, retryDelay, maxRetries, backoff, maxDelay));
                retryCount += 1;
                return;
              }
            }
            maskAuthData(error.originalRequest, maskSensitiveHeaderData);
            const parsedResponse = {
              ...response,
              error,
              statusCode: res.status,
            };
            next(request, parsedResponse);
          });
        },
        // We know that this is a "network" error thrown by the `fetch` library
        (e) => {
          if (enableRetry && (retryOnAbort || !abortController || !abortController.signal)) {
            if (retryCount < maxRetries) {
              setTimeout(executeFetch, calcDelayDuration(retryCount, retryDelay, maxRetries, backoff, maxDelay));
              retryCount += 1;
              return;
            }
          }
          const error = new NetworkError(e.message, {
            ...includeRequestInErrorResponse ? {
              originalRequest: request,
            } : {},
            retryCount,
          });
          maskAuthData(error.originalRequest, maskSensitiveHeaderData);
          next(request, {
            ...response,
            error,
            statusCode: 0,
          });
        },
      ).finally(() => {
        clearTimeout(timer);
      });
    }
    executeFetch();
  };
}
function createLoggerMiddleware() {
  return (next) => (request, response) => {
    const {
      error,
      body,
      statusCode,
    } = response;
    console.log('Request: ', request);
    console.log('Response: ', {
      error,
      body,
      statusCode,
    });
    next(request, response);
  };
}
function createQueueMiddleware({
  concurrency = 20,
}) {
  const queue = [];
  let runningCount = 0;
  const dequeue = (next) => {
    runningCount -= 1;
    if (queue.length && runningCount <= concurrency) {
      const nextTask = queue.shift();
      runningCount += 1;
      next(nextTask.request, nextTask.response);
    }
  };
  return (next) => (request, response) => {
    const patchedResponse = {
      ...response,
      resolve(data) {
        response.resolve(data);
        dequeue(next);
      },
      reject(error) {
        response.reject(error);
        dequeue(next);
      },
    };
    queue.push({
      request,
      response: patchedResponse,
    });
    if (runningCount < concurrency) {
      const nextTask = queue.shift();
      runningCount += 1;
      next(nextTask.request, nextTask.response);
    }
  };
}
var packageJson = {
  name: '@commercetools/sdk-client-v2',
  version: '2.5.0',
  engines: {
    node: '>=14',
  },
  description: 'commercetools Composable Commerce TypeScript SDK client.',
  keywords: [
    'commercetools',
    'composable commerce',
    'sdk',
    'typescript',
    'client',
    'middleware',
    'http',
    'oauth',
    'auth',
  ],
  homepage: 'https://github.com/commercetools/commercetools-sdk-typescript',
  license: 'MIT',
  directories: {
    lib: 'lib',
    test: 'test',
  },
  publishConfig: {
    access: 'public',
  },
  repository: {
    type: 'git',
    url: 'git+https://github.com/commercetools/commercetools-sdk-typescript.git',
  },
  bugs: {
    url: 'https://github.com/commercetools/commercetools-sdk-typescript/issues',
  },
  dependencies: {
    buffer: '^6.0.3',
    'node-fetch': '^2.6.1',
  },
  files: [
    'dist',
    'CHANGELOG.md',
  ],
  author: 'Chukwuemeka Ajima <meeky.ae@gmail.com>',
  main: 'dist/commercetools-sdk-client-v2.cjs.js',
  module: 'dist/commercetools-sdk-client-v2.esm.js',
  browser: {
    './dist/commercetools-sdk-client-v2.cjs.js': './dist/commercetools-sdk-client-v2.browser.cjs.js',
    './dist/commercetools-sdk-client-v2.esm.js': './dist/commercetools-sdk-client-v2.browser.esm.js',
  },
  devDependencies: {
    'abort-controller': '3.0.0',
    'common-tags': '1.8.2',
    dotenv: '16.4.5',
    jest: '29.7.0',
    nock: '12.0.3',
    'organize-imports-cli': '0.10.0',
  },
  scripts: {
    organize_imports: "find src -type f -name '*.ts' | xargs organize-imports-cli",
    postbuild: 'yarn organize_imports',
    post_process_generate: 'yarn organize_imports',
  },
};
const isBrowser = () => window.document && window.document.nodeType === 9;
function getSystemInfo() {
  if (isBrowser())
    return window.navigator.userAgent;
  const nodeVersion = (process == null ? void 0 : process.version.slice(1)) || '12';
  return `node.js/${nodeVersion}`;
}
function createUserAgent(options) {
  if (!options || Object.keys(options).length === 0 || !{}.hasOwnProperty.call(options, 'name'))
    throw new Error('Missing required option `name`');
  const baseInfo = options.version ? `${options.name}/${options.version}` : options.name;
  let libraryInfo = null;
  if (options.libraryName && !options.libraryVersion)
    libraryInfo = options.libraryName;
  else if (options.libraryName && options.libraryVersion)
    libraryInfo = `${options.libraryName}/${options.libraryVersion}`;
  let contactInfo = null;
  if (options.contactUrl && !options.contactEmail)
    contactInfo = `(+${options.contactUrl})`;
  else if (!options.contactUrl && options.contactEmail)
    contactInfo = `(+${options.contactEmail})`;
  else if (options.contactUrl && options.contactEmail)
    contactInfo = `(+${options.contactUrl}; +${options.contactEmail})`;
  const systemInfo = getSystemInfo();
  const customAgent = options.customAgent || '';
  return [baseInfo, systemInfo, libraryInfo, contactInfo, customAgent].filter(Boolean).join(' ');
}
function createUserAgentMiddleware(options) {
  const userAgent = createUserAgent({
    ...options,
    name: `commercetools-sdk-javascript-v2/${packageJson.version}`,
  });
  return (next) => (request, response) => {
    const requestWithUserAgent = {
      ...request,
      headers: {
        ...request.headers,
        'User-Agent': userAgent,
      },
    };
    next(requestWithUserAgent, response);
  };
}
const {
  createAuthMiddlewareForPasswordFlow,
  createAuthMiddlewareForAnonymousSessionFlow,
  createAuthMiddlewareForClientCredentialsFlow,
  createAuthMiddlewareForRefreshTokenFlow,
  createAuthMiddlewareWithExistingToken,
} = authMiddlewares;
class ClientBuilder {
  constructor() {
    _defineProperty$1(this, 'projectKey', void 0);
    _defineProperty$1(this, 'authMiddleware', void 0);
    _defineProperty$1(this, 'httpMiddleware', void 0);
    _defineProperty$1(this, 'userAgentMiddleware', void 0);
    _defineProperty$1(this, 'correlationIdMiddleware', void 0);
    _defineProperty$1(this, 'loggerMiddleware', void 0);
    _defineProperty$1(this, 'queueMiddleware', void 0);
    _defineProperty$1(this, 'telemetryMiddleware', void 0);
    _defineProperty$1(this, 'beforeMiddleware', void 0);
    _defineProperty$1(this, 'afterMiddleware', void 0);
    _defineProperty$1(this, 'middlewares', []);
  }

  withProjectKey(key) {
    this.projectKey = key;
    return this;
  }

  defaultClient(baseUri, credentials, oauthUri, projectKey2) {
    return this.withClientCredentialsFlow({
      host: oauthUri,
      projectKey: projectKey2 || this.projectKey,
      credentials,
    }).withHttpMiddleware({
      host: baseUri,
      fetch: fetch$1,
    }).withLoggerMiddleware().withUserAgentMiddleware();
  }

  withAuthMiddleware(authMiddleware) {
    this.authMiddleware = authMiddleware;
    return this;
  }

  withMiddleware(middleware) {
    this.middlewares.push(middleware);
    return this;
  }

  withClientCredentialsFlow(options) {
    return this.withAuthMiddleware(createAuthMiddlewareForClientCredentialsFlow({
      host: options.host || 'https://auth.europe-west1.gcp.commercetools.com',
      projectKey: options.projectKey || this.projectKey,
      credentials: {
        clientId: options.credentials.clientId || '',
        clientSecret: options.credentials.clientSecret || '',
      },
      oauthUri: options.oauthUri || '',
      scopes: options.scopes,
      fetch: options.fetch || fetch$1,
      ...options,
    }));
  }

  withPasswordFlow(options) {
    return this.withAuthMiddleware(createAuthMiddlewareForPasswordFlow({
      host: options.host || 'https://auth.europe-west1.gcp.commercetools.com',
      projectKey: options.projectKey || this.projectKey,
      credentials: {
        clientId: options.credentials.clientId || '',
        clientSecret: options.credentials.clientSecret || '',
        user: {
          username: options.credentials.user.username || '',
          password: options.credentials.user.password || '',
        },
      },
      fetch: options.fetch || fetch$1,
      ...options,
    }));
  }

  withAnonymousSessionFlow(options) {
    return this.withAuthMiddleware(createAuthMiddlewareForAnonymousSessionFlow({
      host: options.host || 'https://auth.europe-west1.gcp.commercetools.com',
      projectKey: this.projectKey || options.projectKey,
      credentials: {
        clientId: options.credentials.clientId || '',
        clientSecret: options.credentials.clientSecret || '',
        anonymousId: options.credentials.anonymousId || '',
      },
      fetch: options.fetch || fetch$1,
      ...options,
    }));
  }

  withRefreshTokenFlow(options) {
    return this.withAuthMiddleware(createAuthMiddlewareForRefreshTokenFlow({
      host: options.host || 'https://auth.europe-west1.gcp.commercetools.com',
      projectKey: this.projectKey || options.projectKey,
      credentials: {
        clientId: options.credentials.clientId || '',
        clientSecret: options.credentials.clientSecret || '',
      },
      fetch: options.fetch || fetch$1,
      refreshToken: options.refreshToken || '',
      ...options,
    }));
  }

  withExistingTokenFlow(authorization, options) {
    return this.withAuthMiddleware(createAuthMiddlewareWithExistingToken(authorization, {
      force: options.force || true,
      ...options,
    }));
  }

  withHttpMiddleware(options) {
    this.httpMiddleware = createHttpMiddleware({
      host: options.host || 'https://api.europe-west1.gcp.commercetools.com',
      fetch: options.fetch || fetch$1,
      ...options,
    });
    return this;
  }

  withUserAgentMiddleware(options) {
    this.userAgentMiddleware = createUserAgentMiddleware(options);
    return this;
  }

  withQueueMiddleware(options) {
    this.queueMiddleware = createQueueMiddleware({
      concurrency: options.concurrency || 20,
      ...options,
    });
    return this;
  }

  withLoggerMiddleware(options) {
    const {
      logger,
      ...rest
    } = options || {};
    this.loggerMiddleware = typeof (options == null ? void 0 : options.logger) == 'function' && options.logger(rest) || createLoggerMiddleware();
    return this;
  }

  withCorrelationIdMiddleware(options) {
    this.correlationIdMiddleware = createCorrelationIdMiddleware({
      generate: options.generate || null,
      ...options,
    });
    return this;
  }

  withTelemetryMiddleware(options) {
    const {
      createTelemetryMiddleware,
      ...rest
    } = options;
    this.withUserAgentMiddleware({
      customAgent: (rest == null ? void 0 : rest.userAgent) || 'typescript-sdk-apm-middleware',
    });
    this.telemetryMiddleware = createTelemetryMiddleware(rest);
    return this;
  }

  withBeforeExecutionMiddleware(options) {
    const {
      middleware,
      ...rest
    } = options || {};
    this.beforeMiddleware = options.middleware(rest);
    return this;
  }

  withAfterExecutionMiddleware(options) {
    const {
      middleware,
      ...rest
    } = options || {};
    this.afterMiddleware = options.middleware(rest);
    return this;
  }

  build() {
    const middlewares = this.middlewares.slice();
    if (this.telemetryMiddleware)
      middlewares.push(this.telemetryMiddleware);
    if (this.correlationIdMiddleware)
      middlewares.push(this.correlationIdMiddleware);
    if (this.userAgentMiddleware)
      middlewares.push(this.userAgentMiddleware);
    if (this.authMiddleware)
      middlewares.push(this.authMiddleware);
    if (this.beforeMiddleware)
      middlewares.push(this.beforeMiddleware);
    if (this.queueMiddleware)
      middlewares.push(this.queueMiddleware);
    if (this.httpMiddleware)
      middlewares.push(this.httpMiddleware);
    if (this.afterMiddleware)
      middlewares.push(this.afterMiddleware);
    if (this.loggerMiddleware)
      middlewares.push(this.loggerMiddleware);
    return createClient({
      middlewares,
    });
  }
}
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }
  return getRandomValues(rnds8);
}
const byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}
const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const native = {
  randomUUID,
};
function v4(options, buf, offset) {
  if (native.randomUUID && !buf && !options) {
    return native.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  return unsafeStringify(rnds);
}
const projectKey = 'valenki-store';
const authMiddlewareOptions = {
  host: `https://auth.${'europe-west1.gcp'}.commercetools.com`,
  projectKey,
  credentials: {
    clientId: '5itiLUzQgL2_vB9JU7COTVC6',
    clientSecret: 'C1SfQzwx4ojkPd8JozqhAM-_ZKS81Yz9',
  },
  scopes: [`manage_project:${projectKey}`],
  fetch,
};
const httpMiddlewareOptions = {
  host: `https://api.${'europe-west1.gcp'}.commercetools.com`,
  fetch,
};
const ctpClient = new ClientBuilder().withProjectKey(projectKey).withClientCredentialsFlow(authMiddlewareOptions).withHttpMiddleware(httpMiddlewareOptions).build();
const anonymousAuthOptions = {
  ...authMiddlewareOptions,
  credentials: {
    ...authMiddlewareOptions.credentials,
    anonymousId: v4(),
  },
};
const anonymousCtpClient = new ClientBuilder().withAnonymousSessionFlow(anonymousAuthOptions).withHttpMiddleware(httpMiddlewareOptions).build();
new ClientBuilder().withProjectKey(projectKey).withClientCredentialsFlow(authMiddlewareOptions).withHttpMiddleware(httpMiddlewareOptions).build();
function createPasswordFlowClient(body) {
  const options = {
    host: 'https://auth.europe-west1.gcp.commercetools.com',
    projectKey,
    credentials: {
      clientId: '5itiLUzQgL2_vB9JU7COTVC6',
      clientSecret: 'C1SfQzwx4ojkPd8JozqhAM-_ZKS81Yz9',
      user: {
        username: `${body.email}`,
        password: `${body.password}`,
      },
    },
    scopes: [`manage_project:${projectKey}`],
    fetch,
    tokenCache: {
      get() {
        const token = JSON.parse(localStorage.getItem('token'));
        return token;
      },
      set(cache) {
        const token = JSON.stringify(cache);
        localStorage.setItem('token', token);
      },
    },
  };
  const passwordFlowClient = new ClientBuilder().withPasswordFlow(options).withHttpMiddleware(httpMiddlewareOptions).build();
  return passwordFlowClient;
}
function createRefreshTokenClient(refreshToken) {
  const refreshAuthMiddlewareOptions = {
    host: 'https://auth.europe-west1.gcp.commercetools.com',
    projectKey,
    credentials: {
      clientId: '5itiLUzQgL2_vB9JU7COTVC6',
      clientSecret: 'C1SfQzwx4ojkPd8JozqhAM-_ZKS81Yz9',
    },
    refreshToken: `${refreshToken}`,
    tokenCache: {
      get() {
        const token = JSON.parse(localStorage.getItem('token'));
        return token;
      },
      set(cache) {
        const token = JSON.stringify(cache);
        localStorage.setItem('token', token);
      },
    },
    fetch,
  };
  const refreshTokenClient = new ClientBuilder().withRefreshTokenFlow(refreshAuthMiddlewareOptions).withHttpMiddleware(httpMiddlewareOptions).build();
  return refreshTokenClient;
}
function toPrimitive(t, r) {
  if ('object' != typeof t || !t)
    return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || 'default');
    if ('object' != typeof i)
      return i;
    throw new TypeError('@@toPrimitive must return a primitive value.');
  }
  return ('string' === r ? String : Number)(t);
}
function toPropertyKey(t) {
  var i = toPrimitive(t, 'string');
  return 'symbol' == typeof i ? i : i + '';
}
function _defineProperty(obj, key, value) {
  key = toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true,
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function isDefined(value) {
  return typeof value !== 'undefined' && value !== null;
}
function stringify(object) {
  const params = new URLSearchParams(object);
  for (const [key, value] of Object.entries(object)) {
    if (Array.isArray(value)) {
      params.delete(key);
      value.filter(Boolean).forEach((v) => params.append(key, v));
    }
  }
  return params.toString();
}
function cleanObject(obj) {
  return Object.keys(obj).reduce((result, key) => {
    const value = obj[key];
    if (Array.isArray(value)) {
      const values = value.filter(isDefined);
      if (!values.length) {
        return result;
      }
      return {
        ...result,
        [key]: values,
      };
    }
    if (isDefined(value)) {
      return {
        ...result,
        [key]: value,
      };
    }
    return result;
  }, {});
}
function formatQueryString(variableMap) {
  const map = cleanObject(variableMap);
  const result = stringify(map);
  if (result === '') {
    return '';
  }
  return `?${result}`;
}
function buildRelativeUri(commonRequest) {
  const pathMap = commonRequest.pathVariables;
  var uri = commonRequest.uriTemplate;
  for (const param in pathMap) {
    const value = encodeURIComponent(`${pathMap[param]}`);
    uri = uri.replace(`{${param}}`, `${value}`);
  }
  const resQuery = formatQueryString(commonRequest.queryParams || {});
  return `${uri}${resQuery}`;
}
class ApiRequest {
  constructor(request, requestExecutor) {
    this.requestExecutor = requestExecutor;
    _defineProperty(this, 'request', void 0);
    this.request = {
      ...request,
      uri: buildRelativeUri(request),
    };
  }

  clientRequest() {
    return this.request;
  }

  execute() {
    return this.requestExecutor(this.request);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyMeActiveCartRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Retrieves the Customer's most recently modified active Cart in the Store specified by the `storeKey` path parameter.
   *
   *	Carts with `Merchant` or `Quote` [CartOrigin](ctp:api:type:CartOrigin) are ignored.
   *
   *	If no active Cart exists, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/active-cart',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if an active Cart exists. Returns a `200 OK` status if an active Cart exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/active-cart',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }
}
class ByProjectKeyMeActiveCartRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Retrieves the Customer's most recently modified active Cart.
   *	Carts with `Merchant` or `Quote` [CartOrigin](ctp:api:type:CartOrigin) are ignored.
   *
   *	If no active Cart exists, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/me/active-cart',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if an active Cart exists. Returns a `200 OK` status if an active Cart exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/me/active-cart',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }
}
class ByProjectKeyApiClientsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/api-clients/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  /**
   *	Checks if an API Client exists for a given `id`. Returns a `200 OK` status if the API Client exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/api-clients/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/api-clients/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }
}
class ByProjectKeyApiClientsRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withId(childPathArgs) {
    return new ByProjectKeyApiClientsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/api-clients',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if an API Client exists for a given Query Predicate. Returns a `200 OK` status if any API Clients match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/api-clients',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/api-clients',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyAsAssociateByAssociateIdBusinessUnitsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/business-units/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a BusinessUnit exists for a given `id`. Returns a `200 OK` status if the BusinessUnit exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/business-units/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/business-units/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyAsAssociateByAssociateIdBusinessUnitsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/business-units/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a BusinessUnit exists for a given `key`. Returns a `200 OK` status if the BusinessUnit exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/business-units/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/business-units/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyAsAssociateByAssociateIdBusinessUnitsRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withKey(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdBusinessUnitsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdBusinessUnitsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/business-units',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a BusinessUnit exists for a given Query Predicate. Returns a `200 OK` status if any BusinessUnits match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/business-units',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/business-units',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyApprovalFlowsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/approval-flows/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/approval-flows/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyApprovalFlowsRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withId(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyApprovalFlowsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/approval-flows',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyApprovalRulesByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/approval-rules/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/approval-rules/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyApprovalRulesKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/approval-rules/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/approval-rules/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyApprovalRulesRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withId(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyApprovalRulesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withKey(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyApprovalRulesKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/approval-rules',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/approval-rules',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyCartsReplicateRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Creates a new Cart by replicating an existing Cart or Order. Can be useful in cases where a customer wants to cancel a recent order to make some changes or reorder a previous order.
   *
   *	The replicated Cart preserves Customer information, Line Items and Custom Line Items, Custom Fields, Discount Codes, and other settings of the Cart or Order. If the Line Items become invalid, for example, due to removed Products or Prices, they are removed from the new Cart. If the Customer switches to another Customer Group, the new Cart is updated with the new value. It has up-to-date Tax Rates, Prices, and Line Item product data and is in `Active` [CartState](ctp:api:type:CartState).
   *
   *	The new Cart does not contain Payments or Deliveries. The [State](ctp:api:type:ItemState) of Line Items and Custom Line Items is reset to `initial`.
   *
   *	If the Cart exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/carts/replicate',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyCartsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	If the Cart exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/carts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Cart exists for a given `id`. Returns a `200 OK` status if the Cart exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/carts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  /**
   *	If the Cart exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/carts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  /**
   *	If the Cart exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/carts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyCartsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	If the Cart exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/carts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Cart exists for a given `key`. Returns a `200 OK` status if the Cart exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/carts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  /**
   *	If the Cart exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/carts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  /**
   *	If the Cart exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/carts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyCartsRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withKey(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyCartsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyCartsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  replicate() {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyCartsReplicateRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/carts',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Cart exists for a given Query Predicate. Returns a `200 OK` status if any Carts match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/carts',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Creates a [Cart](ctp:api:type:Cart) in the [BusinessUnit](ctp:api:type:BusinessUnit) referenced by `businessUnitKey`. As such, the `businessUnit` field on [CartDraft](ctp:api:type:CartDraft) is ignored for this request.
   *	Creating a Cart can fail with an [InvalidOperation](ctp:api:type:InvalidOperationError) if the referenced [ShippingMethod](ctp:api:type:ShippingMethod) in the [CartDraft](ctp:api:type:CartDraft) has a predicate that does not match the Cart.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/carts',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyOrdersQuotesRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Creates an Order from a [Quote](ctp:api:type:Cart) in a [BusinessUnit](ctp:api:type:BusinessUnit).
   *	Creating an Order fails with an [InvalidOperation](ctp:api:type:InvalidOperationError) if the Quote does not reference the same BusinessUnit as the `businessUnitKey` path parameter.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/orders/quotes',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyOrdersByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	If the Order exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/orders/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if an Order exists for a given `id`. Returns a `200 OK` status if the Order exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/orders/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  /**
   *	If the Order exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/orders/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyOrdersOrderNumberByOrderNumberRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	If the Order exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/orders/order-number={orderNumber}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if an Order exists for a given `orderNumber`. Returns a `200 OK` status if the Order exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/orders/order-number={orderNumber}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  /**
   *	If the Order exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/orders/order-number={orderNumber}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyOrdersRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  orderQuote() {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyOrdersQuotesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withOrderNumber(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyOrdersOrderNumberByOrderNumberRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyOrdersByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/orders',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if an Order exists for a given Query Predicate. Returns a `200 OK` status if any Orders match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/orders',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Creates an Order from a [Cart](ctp:api:type:Cart) in a [BusinessUnit](ctp:api:type:BusinessUnit).
   *	The Cart must have a shipping address set before creating an Order.
   *	Creating an Order fails with an [InvalidOperation](ctp:api:type:InvalidOperationError) if the Cart does not reference the same BusinessUnit as the `businessUnitKey` path parameter.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/orders',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuoteRequestsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	If the QuoteRequest exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quote-requests/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a QuoteRequest exists for a given `id`. Returns a `200 OK` status if the QuoteRequest exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quote-requests/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  /**
   *	If the QuoteRequest exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quote-requests/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuoteRequestsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	If the QuoteRequest exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quote-requests/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a QuoteRequest exists for a given `key`. Returns a `200 OK` status if the QuoteRequest exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quote-requests/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  /**
   *	If the QuoteRequest exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quote-requests/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuoteRequestsRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withKey(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuoteRequestsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuoteRequestsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quote-requests',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a QuoteRequest exists for a given Query Predicate. Returns a `200 OK` status if any QuoteRequests match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quote-requests',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Creates a QuoteRequest in a [BusinessUnit](ctp:api:type:BusinessUnit). Creating QuoteRequest fails with an [InvalidOperation](ctp:api:type:InvalidOperationError) if the Cart does not reference the same BusinessUnit as the `businessUnitKey` path parameter.
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quote-requests',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuotesByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	If the Quote exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quotes/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Quote exists for a given `id`. Returns a `200 OK` status if the Quote exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quotes/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  /**
   *	If the Quote exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quotes/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuotesKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	If the Quote exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quotes/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Quote exists for a given `key`. Returns a `200 OK` status if the Quote exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quotes/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  /**
   *	If the Quote exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quotes/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuotesRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withKey(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuotesKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuotesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quotes',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Quote exists for a given Query Predicate. Returns a `200 OK` status if any Quotes match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quotes',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	An Approval Rule describes the conditions determining whether an Order that matches the predicate needs approval by an approver before it can be ordered by an requester within a Business Unit.
   */
  approvalRules() {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyApprovalRulesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	Approval Flows connect Orders that require approval with the Approval Rules that initiate the approval requirement.
   *	They represent the approval process by including information about approvals, rejections, and all involved parties.
   *
   */
  approvalFlows() {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyApprovalFlowsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	A shopping cart holds product variants and can be ordered.
   */
  carts() {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyCartsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  orders() {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyOrdersRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	A quote holds the negotiated offer.
   */
  quotes() {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuotesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  quoteRequests() {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuoteRequestsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }
}
class ByProjectKeyAsAssociateByAssociateIdRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	A Business Unit can represent a Company or a Division.
   */
  businessUnits() {
    return new ByProjectKeyAsAssociateByAssociateIdBusinessUnitsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  inBusinessUnitKeyWithBusinessUnitKeyValue(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }
}
class ByProjectKeyAsAssociateRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withAssociateIdValue(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }
}
class ByProjectKeyAssociateRolesByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/associate-roles/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if an AssociateRole exists for a given `id`. Returns a `200 OK` status if the AssociateRole exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/associate-roles/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/associate-roles/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/associate-roles/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyAssociateRolesKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/associate-roles/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if an AssociateRole exists for a given `key`. Returns a `200 OK` status if the AssociateRole exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/associate-roles/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/associate-roles/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  /**
   *	Deleting an AssociateRole generates the [AssociateRoleDeleted](ctp:api:type:AssociateRoleDeletedMessage) Message. An AssociateRole can only be deleted if it is not assigned to any [Associates](ctp:api:type:Associate).
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/associate-roles/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyAssociateRolesRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withKey(childPathArgs) {
    return new ByProjectKeyAssociateRolesKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeyAssociateRolesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/associate-roles',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if an AssociateRole exists for a given Query Predicate. Returns a `200 OK` status if any AssociateRole match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/associate-roles',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Creating a Associate Role generates the [AssociateRoleCreated](ctp:api:type:AssociateRoleCreatedMessage) Message.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/associate-roles',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyAttributeGroupsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/attribute-groups/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if an AttributeGroup exists for a given `id`. Returns a `200 OK` status if the AttributeGroup exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/attribute-groups/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/attribute-groups/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/attribute-groups/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyAttributeGroupsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/attribute-groups/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if an AttributeGroup exists for a given `key`. Returns `200 OK` status if the AttributeGroup exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/attribute-groups/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/attribute-groups/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/attribute-groups/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyAttributeGroupsRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withKey(childPathArgs) {
    return new ByProjectKeyAttributeGroupsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeyAttributeGroupsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/attribute-groups',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if an AttributeGroup exists for a given Query Predicate. Returns `200 OK` status if any AttributeGroups match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/attribute-groups',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/attribute-groups',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyBusinessUnitsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/business-units/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a BusinessUnit exists for a given `id`. Returns a `200 OK` status if the BusinessUnit exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/business-units/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/business-units/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/business-units/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyBusinessUnitsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/business-units/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a BusinessUnit exists for a given `key`. Returns a `200 OK` status if the BusinessUnit exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/business-units/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/business-units/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/business-units/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyBusinessUnitsRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withKey(childPathArgs) {
    return new ByProjectKeyBusinessUnitsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeyBusinessUnitsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/business-units',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a BusinessUnit exists for a given Query Predicate. Returns a `200 OK` status if any BusinessUnits match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/business-units',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/business-units',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyCartDiscountsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/cart-discounts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a CartDiscount exists for a given `id`. Returns a `200 OK` status if the CartDiscount exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/cart-discounts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/cart-discounts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  /**
   *	Deleting a Cart Discount produces the [CartDiscountDeleted](ctp:api:type:CartDiscountDeletedMessage) Message.
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/cart-discounts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyCartDiscountsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/cart-discounts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a CartDiscount exists for a given `key`. Returns a `200 OK` status if the CartDiscount exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/cart-discounts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/cart-discounts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  /**
   *	Deleting a Cart Discount produces the [CartDiscountDeleted](ctp:api:type:CartDiscountDeletedMessage) Message.
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/cart-discounts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyCartDiscountsRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withKey(childPathArgs) {
    return new ByProjectKeyCartDiscountsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeyCartDiscountsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/cart-discounts',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a CartDiscount exists for a given Query Predicate. Returns a `200 OK` status if any CartDiscounts match the Query Predicate, or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/cart-discounts',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Creating a Cart Discount produces the [CartDiscountCreated](ctp:api:type:CartDiscountCreatedMessage) Message.
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/cart-discounts',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyCartsReplicateRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Creates a new Cart by replicating an existing Cart or Order. Can be useful in cases where a customer wants to cancel a recent order to make some changes or reorder a previous order.
   *
   *	The replicated Cart preserves Customer information, Line Items and Custom Line Items, Custom Fields, Discount Codes, and other settings of the Cart or Order. If the Line Items become invalid, for example, due to removed Products or Prices, they are removed from the new Cart. If the Customer switches to another Customer Group, the new Cart is updated with the new value. It has up-to-date Tax Rates, Prices, and Line Item product data and is in `Active` [CartState](ctp:api:type:CartState).
   *
   *	The new Cart does not contain Payments or Deliveries. The [State](ctp:api:type:ItemState) of Line Items and Custom Line Items is reset to `initial`.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/carts/replicate',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyCartsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	To ensure the Cart is up-to-date with current values (such as Prices and Discounts), use the [Recalculate](ctp:api:type:CartRecalculateAction) update action.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/carts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Cart exists for a given `id`. Returns a `200 OK` status if the Cart exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/carts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/carts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/carts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyCartsCustomerIdByCustomerIdRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Retrieves the recently modified active Cart of a Customer with [CartOrigin](ctp:api:type:CartOrigin) `Customer`. If no active Cart exists, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   *	To ensure the Cart is up-to-date with current values (such as Prices and Discounts), use the [Recalculate](ctp:api:type:CartRecalculateAction) update action.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/carts/customer-id={customerId}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Cart of a Customer exists. Returns a `200 OK` status if the Cart exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/carts/customer-id={customerId}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }
}
class ByProjectKeyCartsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	To ensure the Cart is up-to-date with current values (such as Prices and Discounts), use the [Recalculate](ctp:api:type:CartRecalculateAction) update action.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/carts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Cart exists for a given `key`. Returns a `200 OK` status if the Cart exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/carts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/carts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/carts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyCartsRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  replicate() {
    return new ByProjectKeyCartsReplicateRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withCustomerId(childPathArgs) {
    return new ByProjectKeyCartsCustomerIdByCustomerIdRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withKey(childPathArgs) {
    return new ByProjectKeyCartsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeyCartsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/carts',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Cart exists for a given Query Predicate. Returns a `200 OK` status if any Carts match the Query Predicate, or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/carts',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Creating a Cart fails with an [InvalidOperation](ctp:api:type:InvalidOperationError) error if the
   *	[ShippingMethod](ctp:api:type:ShippingMethod) referenced in the CartDraft
   *	has a `predicate` that does not match the Cart.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/carts',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyCategoriesByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Either the [scope](/../api/scopes) `view_products:{projectKey}` or `view_categories:{projectKey}` is required.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/categories/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Category exists for a given `id`. Returns a `200 OK` status if the Category exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/categories/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  /**
   *	Either the [scope](/../api/scopes) `manage_products:{projectKey}` or `manage_categories:{projectKey}` is required.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/categories/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  /**
   *	Either the [scope](/../api/scopes) `manage_products:{projectKey}` or `manage_categories:{projectKey}` is required.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/categories/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyCategoriesKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Either the [scope](/../api/scopes) `view_products:{projectKey}` or `view_categories:{projectKey}` is required.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/categories/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Category exists for a given `key`. Returns a `200 OK` status if the Category exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/categories/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  /**
   *	Either the [scope](/../api/scopes) `manage_products:{projectKey}` or `manage_categories:{projectKey}` is required.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/categories/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  /**
   *	Either the [scope](/../api/scopes) `manage_products:{projectKey}` or `manage_categories:{projectKey}` is required.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/categories/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyCategoriesRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withKey(childPathArgs) {
    return new ByProjectKeyCategoriesKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeyCategoriesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	Either the [scope](/../api/scopes) `view_products:{projectKey}` or `view_categories:{projectKey}` is required.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/categories',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Category exists for on a given Query Predicate. Returns a `200 OK` status if any Categories match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/categories',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Either the [scope](/../api/scopes) `manage_products:{projectKey}` or `manage_categories:{projectKey}` is required.
   *
   *	Creating a Category produces the [CategoryCreated](ctp:api:type:CategoryCreatedMessage) Message.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/categories',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyChannelsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/channels/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Channel exists for a given `id`. Returns a `200 OK` status if the Channel exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/channels/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/channels/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  /**
   *	Returns a [ReferenceExists](ctp:api:type:ReferenceExistsError) error if other resources reference the Channel to be deleted.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/channels/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyChannelsRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withId(childPathArgs) {
    return new ByProjectKeyChannelsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/channels',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Channel exists for a given Query Predicate. Returns a `200 OK` status if any Channels match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/channels',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/channels',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyCustomObjectsByContainerByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/custom-objects/{container}/{key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/custom-objects/{container}/{key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyCustomObjectsByContainerRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/custom-objects/{container}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyCustomObjectsRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withContainerAndKey(childPathArgs) {
    return new ByProjectKeyCustomObjectsByContainerByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withContainer(childPathArgs) {
    return new ByProjectKeyCustomObjectsByContainerRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	For performance reasons, it is highly advisable to query for Custom Objects in a container by using the `container` field in the `where` predicate.
   *
   */
  /**
   * @deprecated
   **/
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/custom-objects',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a CustomObject exists for a given Query Predicate. Returns a `200 OK` status if any CustomObjects match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/custom-objects',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	If an object with the given container/key exists, the object will be replaced with the new value and the version is incremented.
   *	If the request contains a version and an object with the given container/key, then the version must match the version of the existing object. Concurrent updates to the same Custom Object returns a [ConcurrentModification](ctp:api:type:ConcurrentModificationError) error even if the version is not provided.
   *
   *	Fields with `null` values will **not be saved**.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/custom-objects',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyCustomerGroupsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/customer-groups/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a CustomerGroup exists for a given `id`. Returns a `200 OK` status if the CustomerGroup exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/customer-groups/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/customer-groups/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/customer-groups/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyCustomerGroupsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/customer-groups/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a CustomerGroup exists for a given `key`. Returns a `200 OK` status if the CustomerGroup exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/customer-groups/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/customer-groups/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/customer-groups/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyCustomerGroupsRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withKey(childPathArgs) {
    return new ByProjectKeyCustomerGroupsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeyCustomerGroupsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/customer-groups',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a CustomerGroup exists for a given Query Predicate. Returns a `200 OK` status if any CustomerGroup match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/customer-groups',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/customer-groups',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyCustomersEmailConfirmRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Verifying the email of the Customer produces the [CustomerEmailVerified](ctp:api:type:CustomerEmailVerifiedMessage) Message.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/customers/email/confirm',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyCustomersEmailTokenRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Produces the [CustomerEmailTokenCreated](ctp:api:type:CustomerEmailTokenCreatedMessage) Message.
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/customers/email-token',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyCustomersPasswordTokenRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/customers/password-token',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyCustomersPasswordRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Changing the password produces the [CustomerPasswordUpdated](ctp:api:type:CustomerPasswordUpdatedMessage) Message with `reset=false`.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/customers/password',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyCustomersPasswordResetRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Resetting the password of the Customer produces the [CustomerPasswordUpdated](ctp:api:type:CustomerPasswordUpdatedMessage) Message with `reset=true`.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/customers/password/reset',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyCustomersByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/customers/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Customer exists for a given `id`. Returns a `200 OK` status if the Customer exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/customers/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  /**
   *	Simultaneously updating two Customers with the same email address can return a [LockedField](ctp:api:type:LockedFieldError) error.
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/customers/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  /**
   *	Deleting a Customer produces the [CustomerDeleted](ctp:api:type:CustomerDeletedMessage) Message.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/customers/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyCustomersEmailTokenByEmailTokenRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/customers/email-token={emailToken}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyCustomersKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/customers/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Customer exists for a given `key`. Returns a `200 OK` status if the Customer exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/customers/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  /**
   *	Simultaneously updating two Customers with the same email address can return a [LockedField](ctp:api:type:LockedFieldError) error.
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/customers/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  /**
   *	Deleting a Customer produces the [CustomerDeleted](ctp:api:type:CustomerDeletedMessage) Message.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/customers/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyCustomersPasswordTokenByPasswordTokenRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/customers/password-token={passwordToken}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyCustomersRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withPasswordToken(childPathArgs) {
    return new ByProjectKeyCustomersPasswordTokenByPasswordTokenRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withEmailToken(childPathArgs) {
    return new ByProjectKeyCustomersEmailTokenByEmailTokenRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  emailToken() {
    return new ByProjectKeyCustomersEmailTokenRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  emailConfirm() {
    return new ByProjectKeyCustomersEmailConfirmRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  password() {
    return new ByProjectKeyCustomersPasswordRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  passwordReset() {
    return new ByProjectKeyCustomersPasswordResetRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	Produces the [CustomerPasswordTokenCreated](ctp:api:type:CustomerPasswordTokenCreatedMessage) Message.
   */
  passwordToken() {
    return new ByProjectKeyCustomersPasswordTokenRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withKey(childPathArgs) {
    return new ByProjectKeyCustomersKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeyCustomersByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/customers',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Customer exists for a given Query Predicate. Returns a `200 OK` status if any Customers match the Query Predicate, or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/customers',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	If the `anonymousCart` field is set on the [CustomerDraft](ctp:api:type:CustomerDraft), then the newly created Customer will be assigned to that [Cart](ctp:api:type:Cart).
   *	Similarly, if the `anonymousId` field is set, the Customer will be set on all [Carts](ctp:api:type:Cart), [Orders](ctp:api:type:Order), [ShoppingLists](ctp:api:type:ShoppingList) and [Payments](ctp:api:type:Payment) with the same `anonymousId`.
   *
   *	Creating a Customer produces the [CustomerCreated](ctp:api:type:CustomerCreatedMessage) Message. Simultaneously creating two Customers with the same email address can return a [LockedField](ctp:api:type:LockedFieldError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/customers',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyDiscountCodesByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Deprecated scope: `view_orders:{projectKey}`
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/discount-codes/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a DiscountCode exists for a given `id`. Returns a `200 OK` status if the DiscountCode exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/discount-codes/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  /**
   *	Deprecated scope: `manage_orders:{projectKey}`
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/discount-codes/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  /**
   *	Deleting a Discount Code produces the [DiscountCodeDeleted](ctp:api:type:DiscountCodeDeletedMessage) Message.
   *
   *	Deprecated scope: `manage_orders:{projectKey}`
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/discount-codes/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyDiscountCodesKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Deprecated scope: `view_orders:{projectKey}`
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/discount-codes/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a DiscountCode exists for a given `key`. Returns a `200 OK` status if the DiscountCode exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/discount-codes/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  /**
   *	Deprecated scope: `manage_orders:{projectKey}`
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/discount-codes/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  /**
   *	Deleting a Discount Code produces the [DiscountCodeDeleted](ctp:api:type:DiscountCodeDeletedMessage) Message.
   *
   *	Deprecated scope: `manage_orders:{projectKey}`
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/discount-codes/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyDiscountCodesRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withId(childPathArgs) {
    return new ByProjectKeyDiscountCodesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withKey(childPathArgs) {
    return new ByProjectKeyDiscountCodesKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	Deprecated scope: `view_orders:{projectKey}`
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/discount-codes',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a DiscountCode exists for a given Query Predicate. Returns a `200 OK` status if any DiscountCodes match the Query Predicate, or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/discount-codes',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Creating a Discount Code produces the [DiscountCodeCreated](ctp:api:type:DiscountCodeCreatedMessage) Message.
   *
   *	Deprecated scope: `manage_orders:{projectKey}`
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/discount-codes',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyExtensionsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/extensions/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  /**
   *	Checks if an Extension exists for a given `id`. Returns a `200 OK` status if the Extension exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/extensions/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/extensions/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/extensions/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyExtensionsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/extensions/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  /**
   *	Checks if an Extension exists for a given `key`. Returns a `200 OK` status if the Extension exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/extensions/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/extensions/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/extensions/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyExtensionsRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withKey(childPathArgs) {
    return new ByProjectKeyExtensionsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeyExtensionsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/extensions',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if an Extension exists for a given Query Predicate. Returns a `200 OK` status if any Extensions match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/extensions',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/extensions',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyGraphqlRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Execute a GraphQL query
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/graphql',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/graphql',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInBusinessUnitKeyByBusinessUnitKeyMeCustomersRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	The My Business Unit endpoint does not support assigning existing Customers to a Business Unit.
   *	Associates with the `UpdateAssociates` [Permission](ctp:api:type:Permission) can use this endpoint to create a new Customer and associate it with the Business Unit.
   *	If the required [Permission](/projects/associate-roles#permission) is missing, an [AssociateMissingPermission](/errors#associatemissingpermission) error is returned.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-business-unit/key={businessUnitKey}/me/customers',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInBusinessUnitKeyByBusinessUnitKeyMeRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  customers() {
    return new ByProjectKeyInBusinessUnitKeyByBusinessUnitKeyMeCustomersRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }
}
class ByProjectKeyInBusinessUnitKeyByBusinessUnitKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  me() {
    return new ByProjectKeyInBusinessUnitKeyByBusinessUnitKeyMeRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }
}
class ByProjectKeyInStoreKeyByStoreKeyCartDiscountsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/cart-discounts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a CartDiscount exists for a given `id`. Returns a `200 OK` status if the CartDiscount exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/cart-discounts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  /**
   *	To update a CartDiscount, you must have permissions for all Stores the CartDiscount is associated with, except when [removing a Store](ctp:api:type:CartDiscountRemoveStoreAction).
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/cart-discounts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  /**
   *	To delete a CartDiscount, specify the `manage_cart_discounts:{projectKey}:{storeKey}` scope for all Stores associated with the CartDiscount.
   *
   *	Deleting a Cart Discount produces the [CartDiscountDeleted](ctp:api:type:CartDiscountDeletedMessage) Message.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/cart-discounts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyCartDiscountsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/cart-discounts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a CartDiscount exists for a given `key`. Returns a `200 OK` status if the CartDiscount exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/cart-discounts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  /**
   *	To update a CartDiscount, you must have permissions for all Stores the CartDiscount is associated with, except when [removing a Store](ctp:api:type:CartDiscountRemoveStoreAction).
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/cart-discounts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  /**
   *	To delete a CartDiscount, specify the `manage_cart_discounts:{projectKey}:{storeKey}` scope for all Stores associated with the CartDiscount.
   *
   *	Deleting a Cart Discount produces the [CartDiscountDeleted](ctp:api:type:CartDiscountDeletedMessage) Message.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/cart-discounts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyCartDiscountsRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withKey(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyCartDiscountsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyCartDiscountsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/cart-discounts',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a CartDiscount exists for a given Query Predicate. Returns a `200 OK` status if any CartDiscounts match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/cart-discounts',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	When using the endpoint, the Store specified in the path and the Stores specified in the payload's `stores` field are added to the CartDiscount.
   *
   *	Creating a Cart Discount produces the [CartDiscountCreated](ctp:api:type:CartDiscountCreatedMessage) Message.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/cart-discounts',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyCartsReplicateRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Creates a new Cart by replicating an existing Cart or Order. Can be useful in cases where a customer wants to cancel a recent order to make some changes or reorder a previous order.
   *
   *	The replicated Cart preserves Customer information, Line Items and Custom Line Items, Custom Fields, Discount Codes, and other settings of the Cart or Order. If the Line Items become invalid, for example, due to removed Products or Prices, they are removed from the new Cart. If the Customer switches to another Customer Group, the new Cart is updated with the new value. It has up-to-date Tax Rates, Prices, and Line Item product data and is in `Active` [CartState](ctp:api:type:CartState).
   *
   *	The new Cart does not contain payments or deliveries. The [State](ctp:api:type:ItemState) of Line Items and Custom Line Items is reset to `initial`.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/carts/replicate',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyCartsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	If the Cart exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   *	To ensure the Cart is up-to-date with current values (such as Prices and Discounts), use the [Recalculate](ctp:api:type:CartRecalculateAction) update action.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/carts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Cart exists for a given `id`. Returns a `200 OK` status if the Cart exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/carts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  /**
   *	Updates a [Cart](ctp:api:type:Cart) in the [Store](ctp:api:type:Store) specified by `storeKey`.
   *	If the Cart exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/carts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  /**
   *	If the Cart exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/carts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyCartsCustomerIdByCustomerIdRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Retrieves the recently modified active Cart of a Customer with [CartOrigin](ctp:api:type:CartOrigin) `Customer`. If no active Cart exists, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   *	If the Cart exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   *	To ensure the Cart is up-to-date with current values (such as Prices and Discounts), use the [Recalculate](ctp:api:type:CartRecalculateAction) update action.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/carts/customer-id={customerId}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Cart of a Customer exists. Returns a `200 OK` status if the Cart exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/carts/customer-id={customerId}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyCartsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	If the Cart exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   *	To ensure the Cart is up-to-date with current values (such as Prices and Discounts), use the [Recalculate](ctp:api:type:CartRecalculateAction) update action.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/carts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Cart exists for a given `key`. Returns a `200 OK` status if the Cart exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/carts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  /**
   *	If the Cart exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/carts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  /**
   *	If the Cart exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/carts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyCartsRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withCustomerId(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyCartsCustomerIdByCustomerIdRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withKey(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyCartsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  replicate() {
    return new ByProjectKeyInStoreKeyByStoreKeyCartsReplicateRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyCartsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	Queries carts in a specific [Store](ctp:api:type:Store).
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/carts',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Cart exists for a given Query Predicate. Returns a `200 OK` status if any Carts match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/carts',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Creates a [Cart](ctp:api:type:Cart) in the [Store](ctp:api:type:Store) specified by `storeKey`.
   *	When using this endpoint the Cart's `store` field is always set to the [Store](ctp:api:type:Store) specified in the path parameter.
   *	If the referenced [ShippingMethod](ctp:api:type:ShippingMethod) in the [CartDraft](ctp:api:type:CartDraft) has a predicate that does not match, an [InvalidOperation](ctp:api:type:InvalidOperationError) error is returned.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/carts',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyCustomersEmailConfirmRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	The customer verifies the email using the token value.
   *	Verifying the email of the Customer produces the [CustomerEmailVerified](ctp:api:type:CustomerEmailVerifiedMessage) Message.
   *
   *	If the Customer exists in the Project but the `stores` field references a different [Store](ctp:api:type:Store), this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/customers/email/confirm',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyCustomersEmailTokenRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	If the Customer exists in the Project but the `stores` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/customers/email-token',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyCustomersPasswordTokenRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	If the Customer exists in the Project but the `stores` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/customers/password-token',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyCustomersPasswordRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Changing the password of the Customer produces the [CustomerPasswordUpdated](ctp:api:type:CustomerPasswordUpdatedMessage) Message with `reset=false`.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/customers/password',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyCustomersPasswordResetRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Resetting the password of the Customer produces the [CustomerPasswordUpdated](ctp:api:type:CustomerPasswordUpdatedMessage) Message with `reset=true`.
   *
   *	If the Customer exists in the Project but the `stores` field references a different [Store](ctp:api:type:Store), this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/customers/password/reset',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyCustomersByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	If the Customer exists in the Project but the `stores` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/customers/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Customer exists for a given `id`. Returns a `200 OK` status if the Customer exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/customers/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  /**
   *	If the Customer exists in the Project but the `stores` field references a different [Store](ctp:api:type:Store), this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   *	Simultaneously updating two Customers with the same email address can return a [LockedField](ctp:api:type:LockedFieldError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/customers/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  /**
   *	Deleting a Customer produces the [CustomerDeleted](ctp:api:type:CustomerDeletedMessage) Message.
   *
   *	If the Customer exists in the Project but the `stores` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/customers/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyCustomersEmailTokenByEmailTokenRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	If the Customer exists in the Project but the `stores` field references a different [Store](ctp:api:type:Store), this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/customers/email-token={emailToken}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyCustomersKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	If the Customer exists in the Project but the `stores` field references a different [Store](ctp:api:type:Store), this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/customers/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Customer exists for a given `key`. Returns a `200 OK` status if the Customer exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/customers/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  /**
   *	If the Customer exists in the Project but the `stores` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   *	Simultaneously updating two Customers with the same email address can return a [LockedField](ctp:api:type:LockedFieldError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/customers/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  /**
   *	Deleting a Customer produces the [CustomerDeleted](ctp:api:type:CustomerDeletedMessage) Message.
   *
   *	If the Customer exists in the Project but the `stores` field references a different [Store](ctp:api:type:Store), this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/customers/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyCustomersPasswordTokenByPasswordTokenRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	If the Customer exists in the Project but the `stores` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/customers/password-token={passwordToken}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyCustomersRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withPasswordToken(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyCustomersPasswordTokenByPasswordTokenRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withEmailToken(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyCustomersEmailTokenByEmailTokenRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  emailToken() {
    return new ByProjectKeyInStoreKeyByStoreKeyCustomersEmailTokenRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  emailConfirm() {
    return new ByProjectKeyInStoreKeyByStoreKeyCustomersEmailConfirmRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  password() {
    return new ByProjectKeyInStoreKeyByStoreKeyCustomersPasswordRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  passwordReset() {
    return new ByProjectKeyInStoreKeyByStoreKeyCustomersPasswordResetRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  passwordToken() {
    return new ByProjectKeyInStoreKeyByStoreKeyCustomersPasswordTokenRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withKey(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyCustomersKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyCustomersByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/customers',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Customer exists for a given Query Predicate. Returns a `200 OK` status if any Customers match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/customers',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	When using this endpoint, if omitted, the Customer `stores` field is set to the [Store](ctp:api:type:Store) specified in the path parameter.
   *
   *	If the `anonymousCart` field is set on the [CustomerDraft](ctp:api:type:CustomerDraft), then the newly created Customer will be assigned to that [Cart](ctp:api:type:Cart).
   *	Similarly, if the `anonymousId` field is set, the Customer will be set on all [Carts](ctp:api:type:Cart), [Orders](ctp:api:type:Order), [ShoppingLists](ctp:api:type:ShoppingList) and [Payments](ctp:api:type:Payment) with the same `anonymousId`.
   *	If a Cart with a `store` field specified, the `store` field must reference the same [Store](ctp:api:type:Store) specified in the `{storeKey}` path parameter.
   *
   *	Creating a Customer produces the [CustomerCreated](ctp:api:type:CustomerCreatedMessage) Message. Simultaneously creating two Customers with the same email address can return a [LockedField](ctp:api:type:LockedFieldError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/customers',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyLoginRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Authenticates a Customer associated with a [Store](ctp:api:type:Store). For more information, see [Global versus Store-specific Customers](/../api/customers-overview#global-versus-store-specific-customers).
   *
   *	Triggers [Cart merge during sign-in](/../api/customers-overview#cart-merge-during-sign-in).
   *
   *	If the Customer exists in the Project but the `stores` field references a different [Store](ctp:api:type:Store), this method returns an [InvalidCredentials](ctp:api:type:InvalidCredentialsError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/login',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyMeCartsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/carts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks ifa My Cart exists for a given `id`. Returns a `200 OK` status if the My Cart exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/carts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  /**
   *	If the Cart exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/carts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/carts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyMeCartsRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withId(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyMeCartsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/carts',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Cart exists for a given Query Predicate. Returns a `200 OK` status if any Carts match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/carts',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	The `store` field in the created [Cart](ctp:api:type:Cart) is set to the Store specified by the `storeKey` path parameter.
   *
   *	Specific Error Codes: [CountryNotConfiguredInStore](ctp:api:type:CountryNotConfiguredInStoreError)
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/carts',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyMeEmailConfirmRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	This is the last step in the [email verification process of a Customer](/../api/projects/customers#email-verification-of-customer-in-store).
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/email/confirm',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyMeLoginRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Retrieves the authenticated Customer (that matches the given email/password pair) if they are part of a specific [Store](ctp:api:type:Store).
   *
   *	- If the Customer does not have a Cart, the most recently modified anonymous cart becomes the Customer's Cart.
   *	- If the Customer already has a Cart, the most recently modified anonymous cart is handled according to [AnonymousCartSignInMode](ctp:api:type:AnonymousCartSignInMode).
   *
   *	If a Cart is returned as part of [CustomerSignInResult](ctp:api:type:CustomerSignInResult), it has been [recalculated](ctp:api:type:MyCartRecalculateAction) with up-to-date prices, taxes, discounts, and invalid line items removed.
   *
   *	If an account with the given credentials is not found, an [InvalidCredentials](ctp:api:type:InvalidCredentialsError) error is returned.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/login',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyMeOrdersByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	If the Order exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/orders/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if an Order exists for a given `id`. Returns a `200 OK` status if the My Order exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/orders/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyMeOrdersRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withId(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyMeOrdersByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/orders',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if an Order exists for a given Query Predicate. Returns a `200 OK` status if any Orders match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/orders',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	The Cart must have a [shipping address set](ctp:api:type:CartSetShippingAddressAction) for taxes to be calculated. When creating [B2B Orders](/associates-overview#b2b-resources), the Customer must have the `CreateMyOrdersFromMyCarts` [Permission](ctp:api:type:Permission).
   *
   *	Creating an Order produces the [OrderCreated](ctp:api:type:OrderCreatedMessage) Message.
   *
   *	Specific Error Codes:
   *
   *	- [OutOfStock](ctp:api:type:OutOfStockError)
   *	- [PriceChanged](ctp:api:type:PriceChangedError)
   *	- [DiscountCodeNonApplicable](ctp:api:type:DiscountCodeNonApplicableError)
   *	- [CountryNotConfiguredInStore](ctp:api:type:CountryNotConfiguredInStoreError)
   *	- [AssociateMissingPermission](ctp:api:type:AssociateMissingPermissionError)
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/orders',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyMePasswordResetRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	This is the last step in the [password reset process of the authenticated Customer](/../api/projects/customers#password-reset-of-customer-in-store).
   *
   *	Resetting a password produces the of the Customer [CustomerPasswordUpdated](ctp:api:type:CustomerPasswordUpdatedMessage) Message with `reset=true`.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/password/reset',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyMePasswordRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  reset() {
    return new ByProjectKeyInStoreKeyByStoreKeyMePasswordResetRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	Changing the password of the Customer produces the [CustomerPasswordUpdated](ctp:api:type:CustomerPasswordUpdatedMessage) Message with `reset=false`.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/password',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyMeShoppingListsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	If a ShoppingList exists in a Project but does _not_ have the `store` field, or the `store` field references a different [Store](ctp:api:type:Store),
   *	the [ResourceNotFound](/errors#404-not-found-1) error is returned.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/shopping-lists/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a ShoppingList exists for a given `id`. Returns a `200 OK` status if the ShoppingList exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/shopping-lists/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  /**
   *	If a ShoppingList exists in a Project but does _not_ have the `store` field, or the `store` field references a different [Store](ctp:api:type:Store),
   *	the [ResourceNotFound](/errors#404-not-found-1) error is returned.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/shopping-lists/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  /**
   *	If a ShoppingList exists in a Project but does _not_ have the `store` field, or the `store` field references a different [Store](ctp:api:type:Store),
   *	the [ResourceNotFound](/errors#404-not-found-1) error is returned.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/shopping-lists/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyMeShoppingListsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	If a ShoppingList exists in a Project but does _not_ have the `store` field, or the `store` field references a different [Store](ctp:api:type:Store), the [ResourceNotFound](/errors#404-not-found-1) error is returned.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/shopping-lists/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a ShoppingList exists for a given `key`. Returns a `200 OK` status if the ShoppingList exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/shopping-lists/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  /**
   *	If a ShoppingList exists in a Project but does _not_ have the `store` field, or the `store` field references a different [Store](ctp:api:type:Store),
   *	the [ResourceNotFound](/errors#404-not-found-1) error is returned.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/shopping-lists/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  /**
   *	If a ShoppingList exists in a Project but does _not_ have the `store` field, or the `store` field references a different [Store](ctp:api:type:Store),
   *	the [ResourceNotFound](/errors#404-not-found-1) error is returned.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/shopping-lists/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyMeShoppingListsRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withKey(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyMeShoppingListsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyMeShoppingListsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/shopping-lists',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a ShoppingList exists for a given Query Predicate. Returns a `200 OK` status if any ShoppingLists match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/shopping-lists',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	When using this endpoint, the `store` field of a ShoppingList is always set to the [Store](ctp:api:type:Store) specified in the path parameter.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/shopping-lists',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyMeSignupRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	If omitted in the request body, the [Customer](ctp:api:type:Customer) `stores` field is set to the [Store](ctp:api:type:Store) specified in the path parameter.
   *
   *	Creating a Customer produces the [CustomerCreated](ctp:api:type:CustomerCreatedMessage) Message.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/signup',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyMeRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	A shopping cart holds product variants and can be ordered.
   */
  carts() {
    return new ByProjectKeyInStoreKeyByStoreKeyMeCartsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	An order can be created from a order, usually after a checkout process has been completed.
   */
  orders() {
    return new ByProjectKeyInStoreKeyByStoreKeyMeOrdersRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  activeCart() {
    return new ByProjectKeyInStoreKeyByStoreKeyMeActiveCartRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	shopping-lists e.g. for wishlist support
   *
   */
  shoppingLists() {
    return new ByProjectKeyInStoreKeyByStoreKeyMeShoppingListsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  emailConfirm() {
    return new ByProjectKeyInStoreKeyByStoreKeyMeEmailConfirmRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  password() {
    return new ByProjectKeyInStoreKeyByStoreKeyMePasswordRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  signup() {
    return new ByProjectKeyInStoreKeyByStoreKeyMeSignupRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  login() {
    return new ByProjectKeyInStoreKeyByStoreKeyMeLoginRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyOrdersByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	If the Order exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/orders/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if an Order exists for a given `id`. Returns a `200 OK` status if the Order exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/orders/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  /**
   *	If the Order exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/orders/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  /**
   *	If the Order exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   *	Deleting an Order produces the [OrderDeleted](ctp:api:type:OrderDeletedMessage) Message.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/orders/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyOrdersOrderNumberByOrderNumberRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	If the Order exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/orders/order-number={orderNumber}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if an Order exists for a given `orderNumber`. Returns a `200 OK` status if the Order exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/orders/order-number={orderNumber}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  /**
   *	If the Order exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/orders/order-number={orderNumber}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  /**
   *	If the Order exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   *	Deleting an Order produces the [OrderDeleted](ctp:api:type:OrderDeletedMessage) Message.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/orders/order-number={orderNumber}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyOrdersRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withOrderNumber(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyOrdersOrderNumberByOrderNumberRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyOrdersByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/orders',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if an Order exists for a given Query Predicate. Returns a `200 OK` status if any Orders match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/orders',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Before you create an Order, the Cart must have a [shipping address set](ctp:api:type:CartSetShippingAddressAction).
   *	The shipping address is used for tax calculation for a Cart with `Platform` [TaxMode](ctp:api:type:TaxMode).
   *
   *	Creating an Order produces the [OrderCreated](ctp:api:type:OrderCreatedMessage) Message.
   *
   *	Specific Error Codes:
   *
   *	- [OutOfStock](ctp:api:type:OutOfStockError)
   *	- [PriceChanged](ctp:api:type:PriceChangedError)
   *	- [DiscountCodeNonApplicable](ctp:api:type:DiscountCodeNonApplicableError)
   *	- [ShippingMethodDoesNotMatchCart](ctp:api:type:ShippingMethodDoesNotMatchCartError)
   *	- [InvalidItemShippingDetails](ctp:api:type:InvalidItemShippingDetailsError)
   *	- [MatchingPriceNotFound](ctp:api:type:MatchingPriceNotFoundError)
   *	- [MissingTaxRateForCountry](ctp:api:type:MissingTaxRateForCountryError)
   *	- [CountryNotConfiguredInStore](ctp:api:type:CountryNotConfiguredInStoreError)
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/orders',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyProductProjectionsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Gets the current or staged representation of a [Product](ctp:api:type:Product) by its ID in the specified [Store](ctp:api:type:Store).
   *	If the Store has defined some languages, countries, distribution, supply Channels, and/or Product Selection,
   *	they are used for projections based on [locale](ctp:api:type:ProductProjectionLocales), [price](ctp:api:type:ProductProjectionPrices),
   *	and [inventory](ctp:api:type:ProductProjectionInventoryEntries).
   *
   *	If [ProductSelection](ctp:api:type:ProductSelection) is used, it affects the [availability of the Product](/projects/stores#products-available-in-store) in the specified Store.
   *
   *	When used with an API Client that has the `view_published_products:{projectKey}` scope, this endpoint only returns published (current) Product Projections.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/product-projections/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if the current or staged representations of a Product exists for a given `id` in the specified [Store](ctp:api:type:Store). Returns a `200 OK` status if the ProductProjection exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/product-projections/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyProductProjectionsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Gets the current or staged representation of a [Product](ctp:api:type:Product) by its key in the specified [Store](ctp:api:type:Store).
   *	If the Store has defined some languages, countries, distribution, supply Channels, and/or Product Selection,
   *	they are used for projections based on [locale](ctp:api:type:ProductProjectionLocales), [price](ctp:api:type:ProductProjectionPrices),
   *	and [inventory](ctp:api:type:ProductProjectionInventoryEntries).
   *
   *	If [ProductSelection](ctp:api:type:ProductSelection) is used, it affects the [availability of the Product](/projects/stores#products-available-in-store) in the specified Store.
   *
   *	When used with an API Client that has the `view_published_products:{projectKey}` scope, this endpoint only returns published (current) Product Projections.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/product-projections/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if the current or staged representations of a Product exists for a given `key` in the specified [Store](ctp:api:type:Store). Returns a `200 OK` status if the ProductProjection exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/product-projections/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyProductProjectionsRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withKey(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyProductProjectionsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyProductProjectionsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }
}
class ByProjectKeyInStoreKeyByStoreKeyProductSelectionAssignmentsRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Queries Product Selection assignments in a specific [Store](ctp:api:type:Store).
   *
   *	The response will include duplicate Products whenever more than one active Product Selection of the Store
   *	includes a Product. To make clear through which Product Selection a Product is available in the Store
   *	the response contains assignments including both the Product and the Product Selection.
   *	Only Products of Product Selections that are activated in the Store will be returned.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/product-selection-assignments',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyProductTailoringRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Queries Product Tailoring in a specific [Store](ctp:api:type:Store).
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/product-tailoring',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Creates a [ProductTailoring](ctp:api:type:ProductTailoring) in the [Store](ctp:api:type:Store) specified by `storeKey`.
   *	When using this endpoint the ProductTailoring's `store` field is always set to the [Store](ctp:api:type:Store) specified in the path parameter.
   *
   *	Generates the [ProductTailoringCreated](ctp:api:type:ProductTailoringCreatedMessage) Message.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/product-tailoring',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyProductsByProductIDProductTailoringRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Gets the current or staged representation of a [Product Tailoring](ctp:api:type:ProductTailoring) by its Product ID in the specified [Store](ctp:api:type:Store).
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/products/{productID}/product-tailoring',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Updates the current or staged representation of a [Product Tailoring](ctp:api:type:ProductTailoring) by its Product ID in the specified [Store](ctp:api:type:Store).
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/products/{productID}/product-tailoring',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  /**
   *	Generates the [ProductTailoringDeleted](ctp:api:type:ProductTailoringDeletedMessage) Message.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/products/{productID}/product-tailoring',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyProductsByProductIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  productTailoring() {
    return new ByProjectKeyInStoreKeyByStoreKeyProductsByProductIDProductTailoringRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }
}
class ByProjectKeyInStoreKeyByStoreKeyProductsKeyByProductKeyProductTailoringRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Gets the current or staged representation of a [Product Tailoring](ctp:api:type:ProductTailoring) by its Product key in the specified [Store](ctp:api:type:Store).
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/products/key={productKey}/product-tailoring',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Updates the current or staged representation of a [Product Tailoring](ctp:api:type:ProductTailoring) by its Product key in the specified [Store](ctp:api:type:Store).
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/products/key={productKey}/product-tailoring',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  /**
   *	Generates the [ProductTailoringDeleted](ctp:api:type:ProductTailoringDeletedMessage) Message.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/products/key={productKey}/product-tailoring',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyProductsKeyByProductKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  productTailoring() {
    return new ByProjectKeyInStoreKeyByStoreKeyProductsKeyByProductKeyProductTailoringRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }
}
class ByProjectKeyInStoreKeyByStoreKeyProductsRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withProductId(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyProductsByProductIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withProductKey(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyProductsKeyByProductKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }
}
class ByProjectKeyInStoreKeyByStoreKeyShippingMethodsMatchingCartRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Retrieves all the ShippingMethods that can ship to the shipping address of the given Cart in a given [Store](ctp:api:type:Store).
   *	Each ShippingMethod contains exactly one ShippingRate with the flag `isMatching` set to `true`.
   *	This ShippingRate is used when the ShippingMethod is [added to the Cart](ctp:api:type:CartSetShippingMethodAction).
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/shipping-methods/matching-cart',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a ShippingMethod that can ship to the shipping address of the given Cart exists in the given [Store](ctp:api:type:Store). Returns a `200 OK` status if the ShippingMethod exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/shipping-methods/matching-cart',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyShippingMethodsRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Get ShippingMethods for a cart in a store
   */
  matchingCart() {
    return new ByProjectKeyInStoreKeyByStoreKeyShippingMethodsMatchingCartRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }
}
class ByProjectKeyInStoreKeyByStoreKeyShoppingListsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	If a ShoppingList exists in a Project but does _not_ have the `store` field, or the `store` field references a different [Store](ctp:api:type:Store),
   *	the [ResourceNotFound](/errors#404-not-found-1) error is returned.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/shopping-lists/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a ShoppingList exists for a given `id`. Returns a `200 OK` status if the ShoppingList exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/shopping-lists/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  /**
   *	If a ShoppingList exists in a Project but does _not_ have the `store` field, or the `store` field references a different [Store](ctp:api:type:Store),
   *	the [ResourceNotFound](/errors#404-not-found-1) error is returned.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/shopping-lists/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  /**
   *	If a ShoppingList exists in a Project but does _not_ have the `store` field, or the `store` field references a different [Store](ctp:api:type:Store),
   *	the [ResourceNotFound](/errors#404-not-found-1) error is returned.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/shopping-lists/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyShoppingListsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	If a ShoppingList exists in a Project but does _not_ have the `store` field, or the `store` field references a different [Store](ctp:api:type:Store),
   *	the [ResourceNotFound](/errors#404-not-found-1) error is returned.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/shopping-lists/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a ShoppingList exists for a given `key`. Returns a `200 OK` status if the ShoppingList exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/shopping-lists/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  /**
   *	If a ShoppingList exists in a Project but does _not_ have the `store` field, or the `store` field references a different [Store](ctp:api:type:Store),
   *	the [ResourceNotFound](/errors#404-not-found-1) error is returned.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/shopping-lists/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  /**
   *	If a ShoppingList exists in a Project but does _not_ have the `store` field, or the `store` field references a different [Store](ctp:api:type:Store),
   *	the [ResourceNotFound](/errors#404-not-found-1) error is returned.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/shopping-lists/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyShoppingListsRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withKey(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyShoppingListsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyShoppingListsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/shopping-lists',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a ShoppingList exists for a given Query Predicate. Returns a `200 OK` status if any ShoppingLists match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/shopping-lists',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	When using this endpoint, the `store` field of a ShoppingList is always set to the [Store](ctp:api:type:Store) specified in the path parameter.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/shopping-lists',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInStoreKeyByStoreKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	A shopping cart holds product variants and can be ordered.
   */
  carts() {
    return new ByProjectKeyInStoreKeyByStoreKeyCartsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	An order can be created from a cart, usually after a checkout process has been completed.
   */
  orders() {
    return new ByProjectKeyInStoreKeyByStoreKeyOrdersRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  me() {
    return new ByProjectKeyInStoreKeyByStoreKeyMeRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	A Customer is a person purchasing products. Carts, Orders,
   *	Comments and Reviews can be associated to a Customer.
   *
   */
  customers() {
    return new ByProjectKeyInStoreKeyByStoreKeyCustomersRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	Retrieves the authenticated customer.
   */
  login() {
    return new ByProjectKeyInStoreKeyByStoreKeyLoginRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  shippingMethods() {
    return new ByProjectKeyInStoreKeyByStoreKeyShippingMethodsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	shopping-lists e.g. for wishlist support
   *
   */
  shoppingLists() {
    return new ByProjectKeyInStoreKeyByStoreKeyShoppingListsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  productProjections() {
    return new ByProjectKeyInStoreKeyByStoreKeyProductProjectionsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  productSelectionAssignments() {
    return new ByProjectKeyInStoreKeyByStoreKeyProductSelectionAssignmentsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  cartDiscounts() {
    return new ByProjectKeyInStoreKeyByStoreKeyCartDiscountsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	A Product Tailoring holds tailored data of Product in the Store.
   */
  productTailoring() {
    return new ByProjectKeyInStoreKeyByStoreKeyProductTailoringRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  products() {
    return new ByProjectKeyInStoreKeyByStoreKeyProductsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }
}
class ByProjectKeyInventoryByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/inventory/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if an InventoryEntry exists for a given `id`. Returns a `200 OK` status if the InventoryEntry exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/inventory/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/inventory/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  /**
   *	Produces the [InventoryEntryDeleted](ctp:api:type:InventoryEntryDeletedMessage) Message.
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/inventory/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInventoryKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/inventory/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if an InventoryEntry exists for a given `key`. Returns a `200 OK` status if the InventoryEntry exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/inventory/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/inventory/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  /**
   *	Produces the [InventoryEntryDeleted](ctp:api:type:InventoryEntryDeletedMessage) Message.
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/inventory/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyInventoryRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withId(childPathArgs) {
    return new ByProjectKeyInventoryByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withKey(childPathArgs) {
    return new ByProjectKeyInventoryKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/inventory',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if an InventoryEntry exists for a given Query Predicate. Returns a `200 OK` status if any Inventory Entries match the Query Predicate, a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/inventory',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Produces the [InventoryEntryCreated](ctp:api:type:InventoryEntryCreatedMessage) Message.
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/inventory',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyLoginRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Authenticates a global Customer not associated with a Store.
   *	For more information, see [Global versus Store-specific Customers](/../api/customers-overview#global-versus-store-specific-customers).
   *	If the Customer is registered in a Store, use the [Authenticate (sign in) Customer in Store](ctp:api:endpoint:/{projectKey}/in-store/key={storeKey}/login:POST) method.
   *
   *	Triggers [Cart merge during sign-in](/../api/customers-overview#cart-merge-during-sign-in).
   *
   *	If an account with the given credentials is not found, an [InvalidCredentials](ctp:api:type:InvalidCredentialsError) error is returned.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/login',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyMeBusinessUnitsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/me/business-units/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a BusinessUnit exists for a given `id`. Returns a `200 OK` status if the BusinessUnit exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/me/business-units/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/business-units/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/me/business-units/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyMeBusinessUnitsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/me/business-units/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a BusinessUnit exists for a given `key`. Returns a `200 OK` status if the BusinessUnit exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/me/business-units/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/business-units/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/me/business-units/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyMeBusinessUnitsRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withId(childPathArgs) {
    return new ByProjectKeyMeBusinessUnitsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withKey(childPathArgs) {
    return new ByProjectKeyMeBusinessUnitsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/me/business-units',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a BusinessUnit exists for a given Query Predicate. Returns a `200 OK` status if any BusinessUnits match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/me/business-units',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Automatically assigns the Associate to the Business Unit in the default [Associate Role](ctp:api:type:AssociateRole) defined in [BusinessUnitConfiguration](ctp:api:type:BusinessUnitConfiguration). If there is no default Associate Role configured, this request fails with an [InvalidOperation](ctp:api:type:InvalidOperationError) error. When creating a Division, the Associate must have the `AddChildUnits` [Permission](ctp:api:type:Permission) in the parent unit. If the required [Permission](/projects/associate-roles#permission) is missing, an [AssociateMissingPermission](/errors#associatemissingpermission) error is returned.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/business-units',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyMeCartsReplicateRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Creates a new Cart by replicating an existing Cart or Order of the authenticated Customer.
   *	This can be useful in cases where a customer wants to cancel a recent order to make some changes or reorder a previous order.
   *
   *	The replicated Cart preserves Customer information, Line Items and Custom Line Items, Custom Fields, Discount Codes, and other settings of the Cart or Order.
   *	If the Line Items become invalid, for example, due to removed Products or Prices, they are removed from the new Cart.
   *	If the Customer switches to another Customer Group, the new Cart is updated with the new value.
   *	It has up-to-date Tax Rates, Prices, and Line Item product data and is in `Active` [CartState](ctp:api:type:CartState).
   *
   *	The new Cart does not contain Payments or Deliveries. The [State](ctp:api:type:ItemState) of Line Items and Custom Line Items is reset to `initial`.
   *
   *	In case the Cart or Order to be replicated does not belong to the authenticaed Customer, the API returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/carts/replicate',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyMeCartsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/me/carts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Cart exists for a given `id`. Returns a `200 OK` status if the Cart exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/me/carts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/carts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/me/carts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyMeCartsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/me/carts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Cart exists for a given `key`. Returns a `200 OK` status if the Cart exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/me/carts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/carts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/me/carts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyMeCartsRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withKey(childPathArgs) {
    return new ByProjectKeyMeCartsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeyMeCartsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  replicate() {
    return new ByProjectKeyMeCartsReplicateRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/me/carts',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Cart exists for a given Query Predicate. Returns a `200 OK` status if any Carts match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/me/carts',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/carts',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyMeEmailConfirmRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	This is the last step in the [email verification process of a Customer](/../api/projects/customers#email-verification-of-customer).
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/email/confirm',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyMeLoginRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Retrieves the authenticated customer (that matches the given email/password pair).
   *
   *	If used with [an access token for an anonymous session](ctp:api:type:AnonymousSession), all Orders and Carts that belong to the `anonymousId` are assigned to the newly logged-in Customer.
   *
   *	- If the Customer does not have a Cart yet, the most recently modified anonymous cart becomes the Customer's Cart.
   *	- If the Customer already has a Cart, the most recently modified anonymous cart is handled in accordance with [AnonymousCartSignInMode](ctp:api:type:AnonymousCartSignInMode).
   *
   *	A Cart returned as part of the [CustomerSignInResult](ctp:api:type:CustomerSignInResult) is [recalculated](ctp:api:type:MyCartRecalculateAction) with up-to-date prices, taxes, discounts, and invalid line items removed.
   *
   *	If an account with the given credentials is not found, an [InvalidCredentials](ctp:api:type:InvalidCredentialsError) error is returned.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/login',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyMeOrdersQuotesRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	When creating [B2B Orders](/associates-overview#b2b-resources), the Customer must have the `CreateMyOrdersFromMyQuotes` [Permission](ctp:api:type:Permission).
   *
   *	Creating an Order produces the [OrderCreated](ctp:api:type:OrderCreatedMessage) Message.
   *
   *	Specific Error Codes:
   *
   *	- [OutOfStock](ctp:api:type:OutOfStockError)
   *	- [PriceChanged](ctp:api:type:PriceChangedError)
   *	- [InvalidItemShippingDetails](ctp:api:type:InvalidItemShippingDetailsError)
   *	- [CountryNotConfiguredInStore](ctp:api:type:CountryNotConfiguredInStoreError)
   *	- [AssociateMissingPermission](ctp:api:type:AssociateMissingPermissionError)
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/orders/quotes',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyMeOrdersByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/me/orders/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if an Order exists for a given `id`. Returns a `200 OK` status if the Order exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/me/orders/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }
}
class ByProjectKeyMeOrdersRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withId(childPathArgs) {
    return new ByProjectKeyMeOrdersByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  orderQuote() {
    return new ByProjectKeyMeOrdersQuotesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/me/orders',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if an Order exists for a given Query Predicate. Returns a `200 OK` status if any Orders match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/me/orders',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	The Cart must have a [shipping address set](ctp:api:type:CartSetShippingAddressAction) for taxes to be calculated. When creating [B2B Orders](/associates-overview#b2b-resources), the Customer must have the `CreateMyOrdersFromMyCarts` [Permission](ctp:api:type:Permission).
   *
   *	Creating an Order produces the [OrderCreated](ctp:api:type:OrderCreatedMessage) Message.
   *
   *	Specific Error Codes:
   *
   *	- [OutOfStock](ctp:api:type:OutOfStockError)
   *	- [PriceChanged](ctp:api:type:PriceChangedError)
   *	- [DiscountCodeNonApplicable](ctp:api:type:DiscountCodeNonApplicableError)
   *	- [AssociateMissingPermission](ctp:api:type:AssociateMissingPermissionError)
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/orders',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyMePasswordResetRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	This is the last step in the [password reset process of a Customer](/../api/projects/customers#password-reset-of-customer).
   *
   *	Resetting a password of the Customer produces the [CustomerPasswordUpdated](ctp:api:type:CustomerPasswordUpdatedMessage) Message with `reset=true`.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/password/reset',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyMePasswordRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  reset() {
    return new ByProjectKeyMePasswordResetRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	Changing the password of the Customer produces the [CustomerPasswordUpdated](ctp:api:type:CustomerPasswordUpdatedMessage) Message with `reset=false`.
   *
   *	If the current password does not match, an [InvalidCurrentPassword](ctp:api:type:InvalidCurrentPasswordError) error is returned.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/password',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyMePaymentsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/me/payments/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Payment exists for a given `id`. Returns a `200 OK` status if the Payment exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/me/payments/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  /**
   *	This endpoint can only update a Payment when it has no [Transactions](ctp:api:type:Transaction).
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/payments/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  /**
   *	This endpoint can only delete a Payment when it has no [Transactions](ctp:api:type:Transaction).
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/me/payments/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyMePaymentsRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withId(childPathArgs) {
    return new ByProjectKeyMePaymentsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/me/payments',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Payment exists for a given Query Predicate. Returns a `200 OK` status if any Payments match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/me/payments',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Creating a Payment produces the [PaymentCreated](ctp:api:type:PaymentCreatedMessage) Message.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/payments',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyMeQuoteRequestsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/me/quote-requests/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if my QuoteRequest exists for a given `id`. Returns a `200 OK` status if the QuoteRequest exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/me/quote-requests/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/quote-requests/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/me/quote-requests/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyMeQuoteRequestsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/me/quote-requests/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if my QuoteRequest exists for a given `key`. Returns a `200 OK` status if the QuoteRequest exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/me/quote-requests/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/quote-requests/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/me/quote-requests/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyMeQuoteRequestsRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withId(childPathArgs) {
    return new ByProjectKeyMeQuoteRequestsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withKey(childPathArgs) {
    return new ByProjectKeyMeQuoteRequestsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/me/quote-requests',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if my QuoteRequest exists for a given Query Predicate. Returns a `200 OK` status if any QuoteRequests match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/me/quote-requests',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/quote-requests',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyMeQuotesByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/me/quotes/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Quote exists for a given `id`. Returns a `200 OK` status if the Quote exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/me/quotes/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/quotes/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyMeQuotesKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/me/quotes/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Quote exists for a given `key`. Returns a `200 OK` status if the Quote exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/me/quotes/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/quotes/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyMeQuotesRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withId(childPathArgs) {
    return new ByProjectKeyMeQuotesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withKey(childPathArgs) {
    return new ByProjectKeyMeQuotesKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/me/quotes',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Quote exists for a given Query Predicate. Returns a `200 OK` status if any Quotes match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/me/quotes',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyMeShoppingListsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/me/shopping-lists/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a ShoppingList exists for a given `id`. Returns a `200 OK` status if the ShoppingList exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/me/shopping-lists/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/shopping-lists/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/me/shopping-lists/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyMeShoppingListsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/me/shopping-lists/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a ShoppingList exists for a given `key`. Returns a `200 OK` status if the ShoppingList exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/me/shopping-lists/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/shopping-lists/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/me/shopping-lists/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyMeShoppingListsRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withId(childPathArgs) {
    return new ByProjectKeyMeShoppingListsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withKey(childPathArgs) {
    return new ByProjectKeyMeShoppingListsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/me/shopping-lists',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a ShoppingList exists for a given Query Predicate. Returns a `200 OK` status if any ShoppingLists match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/me/shopping-lists',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/shopping-lists',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyMeSignupRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	If used with an [access token for an anonymous session](ctp:api:type:AnonymousSession), all Orders and Carts that belong to the `anonymousId` are assigned to the newly created Customer.
   *
   *	Creating a Customer produces the [CustomerCreated](ctp:api:type:CustomerCreatedMessage) Message.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/signup',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyMeRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  emailConfirm() {
    return new ByProjectKeyMeEmailConfirmRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  password() {
    return new ByProjectKeyMePasswordRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  signup() {
    return new ByProjectKeyMeSignupRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  login() {
    return new ByProjectKeyMeLoginRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  activeCart() {
    return new ByProjectKeyMeActiveCartRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	MyBusinessUnit creates and provides access to Business Units scoped to a specific user.
   */
  businessUnits() {
    return new ByProjectKeyMeBusinessUnitsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	A shopping cart holds product variants and can be ordered.
   */
  carts() {
    return new ByProjectKeyMeCartsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	An order can be created from a cart, usually after a checkout process has been completed.
   */
  orders() {
    return new ByProjectKeyMeOrdersRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	The My Payments endpoint creates and provides access to payments scoped to a specific user.
   */
  payments() {
    return new ByProjectKeyMePaymentsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	The My Quote Requests endpoint creates and provides access to Quote Requests scoped to a specific user.
   */
  quoteRequests() {
    return new ByProjectKeyMeQuoteRequestsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	The My Quote endpoint provides access to Quotes scoped to a specific user.
   */
  quotes() {
    return new ByProjectKeyMeQuotesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	The My Shopping Lists endpoint creates and provides access to Shopping Lists scoped to a specific user.
   */
  shoppingLists() {
    return new ByProjectKeyMeShoppingListsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/me',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/me',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyMessagesByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Deprecated scope: `view_orders:{projectKey}`
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/messages/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Message exists for a given `id`. Returns a `200 OK` status if the Message exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/messages/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }
}
class ByProjectKeyMessagesRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withId(childPathArgs) {
    return new ByProjectKeyMessagesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	Deprecated scope: `view_orders:{projectKey}`
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/messages',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Message exists for a given Query Predicate. Returns a `200 OK` status if any Messages match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/messages',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyOrdersEditsByIDApplyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Applying an OrderEdit produces the [OrderEditApplied](ctp:api:type:OrderEditAppliedMessage) Message.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/orders/edits/{ID}/apply',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyOrdersEditsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  apply() {
    return new ByProjectKeyOrdersEditsByIDApplyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/orders/edits/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if an OrderEdit exists for a given `id`. Returns a `200 OK` status if the OrderEdit exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/orders/edits/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/orders/edits/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/orders/edits/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyOrdersEditsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/orders/edits/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if an OrderEdit exists for a given `key`. Returns a `200 OK` status if the OrderEdit exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/orders/edits/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/orders/edits/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/orders/edits/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyOrdersEditsRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withKey(childPathArgs) {
    return new ByProjectKeyOrdersEditsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeyOrdersEditsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/orders/edits',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if an OrderEdit exists for a given Query Predicate. Returns a `200 OK` status if any OrderEdits match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/orders/edits',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	You can either create multiple Order Edits for an Order and apply them sequentially to an Order, or create multiple Order Edits parallelly (as alternatives to each other) and apply one of them to the Order.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/orders/edits',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyOrdersImportRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Importing an Order produces the [Order Imported](ctp:api:type:OrderImportedMessage) Message.
   *
   *	Specific Error Codes:
   *
   *	- [OutOfStock](ctp:api:type:OutOfStockError)
   *	- [CountryNotConfiguredInStore](ctp:api:type:CountryNotConfiguredInStoreError)
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/orders/import',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyOrdersQuotesRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Creating an Order produces the [OrderCreated](ctp:api:type:OrderCreatedMessage) Message.
   *
   *	Specific Error Codes:
   *
   *	- [OutOfStock](ctp:api:type:OutOfStockError)
   *	- [PriceChanged](ctp:api:type:PriceChangedError)
   *	- [InvalidItemShippingDetails](ctp:api:type:InvalidItemShippingDetailsError)
   *	- [InvalidOperation](ctp:api:type:InvalidOperationError)
   *	- [CountryNotConfiguredInStore](ctp:api:type:CountryNotConfiguredInStoreError)
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/orders/quotes',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyOrdersSearchRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/orders/search',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  /**
   *	Checks whether a search index for the Project's Orders exists.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/orders/search',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }
}
class ByProjectKeyOrdersByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/orders/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if an Order exists for a given `id`. Returns a `200 OK` status if the Order exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/orders/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/orders/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  /**
   *	Deleting an Order produces the [OrderDeleted](ctp:api:type:OrderDeletedMessage) Message.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/orders/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyOrdersOrderNumberByOrderNumberRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/orders/order-number={orderNumber}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if an Order exists for a given `orderNumber`. Returns a `200 OK` status if the Order exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/orders/order-number={orderNumber}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/orders/order-number={orderNumber}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  /**
   *	Deleting an Order produces the [OrderDeleted](ctp:api:type:OrderDeletedMessage) Message.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/orders/order-number={orderNumber}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyOrdersRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  importOrder() {
    return new ByProjectKeyOrdersImportRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  orderQuote() {
    return new ByProjectKeyOrdersQuotesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withOrderNumber(childPathArgs) {
    return new ByProjectKeyOrdersOrderNumberByOrderNumberRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	OrderEdit are containers for financial changes after an Order has been placed.
   */
  edits() {
    return new ByProjectKeyOrdersEditsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeyOrdersByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	This endpoint provides high performance search queries over Orders. The order search allows searching through all orders (currently supporting a limit of the 10.000.000 newest orders) in your project.
   *
   */
  search() {
    return new ByProjectKeyOrdersSearchRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/orders',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if an Order exists for a given Query Predicate. Returns a `200 OK` status if any Orders match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/orders',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Before you create an Order, the Cart must have a [shipping address set](ctp:api:type:CartSetShippingAddressAction).
   *	The shipping address is used for tax calculation for a Cart with `Platform` [TaxMode](ctp:api:type:TaxMode).
   *
   *	Creating an Order produces the [OrderCreated](ctp:api:type:OrderCreatedMessage) Message.
   *
   *	Specific Error Codes:
   *
   *	- [OutOfStock](ctp:api:type:OutOfStockError)
   *	- [PriceChanged](ctp:api:type:PriceChangedError)
   *	- [DiscountCodeNonApplicable](ctp:api:type:DiscountCodeNonApplicableError)
   *	- [ShippingMethodDoesNotMatchCart](ctp:api:type:ShippingMethodDoesNotMatchCartError)
   *	- [InvalidItemShippingDetails](ctp:api:type:InvalidItemShippingDetailsError)
   *	- [MatchingPriceNotFound](ctp:api:type:MatchingPriceNotFoundError)
   *	- [MissingTaxRateForCountry](ctp:api:type:MissingTaxRateForCountryError)
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/orders',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyPaymentsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/payments/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Payment exists for a given `id`. Returns a `200 OK` status if the Payment exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/payments/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/payments/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/payments/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyPaymentsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/payments/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Payment exists for a given `key`. Returns a `200 OK` status if the Payment exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/payments/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/payments/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/payments/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyPaymentsRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withKey(childPathArgs) {
    return new ByProjectKeyPaymentsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeyPaymentsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/payments',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Payment exists for a given Query Predicate. Returns a `200 OK` status if any Payments match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/payments',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Creating a Payment produces the [PaymentCreated](ctp:api:type:PaymentCreatedMessage) Message.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/payments',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyProductDiscountsMatchingRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	This endpoint can be used to simulate which Product Discounts would be applied if a specified Product Variant had a specified Price.
   *	Given Product and Product Variant IDs and a Price, this endpoint will return the [ProductDiscount](ctp:api:type:ProductDiscount) that would have been applied to that Price.
   *
   *	If a Product Discount could not be found that could be applied to the Price of a Product Variant, a [NoMatchingProductDiscountFound](ctp:api:type:NoMatchingProductDiscountFoundError) error is returned.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/product-discounts/matching',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyProductDiscountsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/product-discounts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a ProductDiscount exists for a given `id`. Returns a `200 OK` status if the ProductDiscount exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/product-discounts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/product-discounts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/product-discounts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyProductDiscountsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/product-discounts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a ProductDiscount exists for a given `key`. Returns a `200 OK` status if the ProductDiscount exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/product-discounts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/product-discounts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/product-discounts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyProductDiscountsRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  matching() {
    return new ByProjectKeyProductDiscountsMatchingRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withKey(childPathArgs) {
    return new ByProjectKeyProductDiscountsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeyProductDiscountsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/product-discounts',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a ProductDiscount exists for a given Query Predicate. Returns a `200 OK` status if any ProductDiscounts match the Query Predicate, or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/product-discounts',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/product-discounts',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyProductProjectionsSearchRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Product Projection Search
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/product-projections/search',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  /**
   *	Product Projection Search
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/product-projections/search',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyProductProjectionsSuggestRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/product-projections/suggest',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyProductProjectionsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Gets the current or staged representation of a [Product](ctp:api:type:Product) by its ID. When used with an API Client that has the `view_published_products:{projectKey}` scope, this endpoint only returns published (current) Product Projections.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/product-projections/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if the current or staged representation of a Product exists for a given `id`. Returns a `200 OK` status if the ProductProjection exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/product-projections/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }
}
class ByProjectKeyProductProjectionsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Gets the current or staged representation of a [Product](ctp:api:type:Product) found by Key.
   *	When used with an API Client that has the `view_published_products:{projectKey}` scope,
   *	this endpoint only returns published (current) Product Projections.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/product-projections/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if the current or staged representation of a Product exists for a given `key`. Returns a `200 OK` status if the ProductProjection exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/product-projections/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }
}
class ByProjectKeyProductProjectionsRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	This endpoint provides high performance search queries over ProductProjections. The query result contains the
   *	ProductProjections for which at least one ProductVariant matches the search query. This means that variants can
   *	be included in the result also for which the search query does not match. To determine which ProductVariants match
   *	the search query, the returned ProductProjections include the additional field isMatchingVariant.
   *
   */
  search() {
    return new ByProjectKeyProductProjectionsSearchRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	The source of data for suggestions is the searchKeyword field in a product
   */
  suggest() {
    return new ByProjectKeyProductProjectionsSuggestRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withKey(childPathArgs) {
    return new ByProjectKeyProductProjectionsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeyProductProjectionsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	Use the Product Projections query endpoint to get the current or staged representations of Products.
   *	When used with an API Client that has the `view_published_products:{projectKey}` scope,
   *	this endpoint only returns published (current) Product Projections.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/product-projections',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if the current or staged representation of a Product exists for a given Query Predicate. Returns a `200 OK` status if any ProductProjections match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/product-projections',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyProductSelectionsByIDProductsRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/product-selections/{ID}/products',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyProductSelectionsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  products() {
    return new ByProjectKeyProductSelectionsByIDProductsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/product-selections/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a ProductSelection exists for a given `id`. Returns a `200 OK` status if the ProductSelection exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/product-selections/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/product-selections/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  /**
   *	Deletion will only succeed if the Product Selection is not assigned to any [Store](ctp:api:type:Store).
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/product-selections/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyProductSelectionsKeyByKeyProductsRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/product-selections/key={key}/products',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyProductSelectionsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  products() {
    return new ByProjectKeyProductSelectionsKeyByKeyProductsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/product-selections/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a ProductSelection exists for a given `key`. Returns a `200 OK` status if the ProductSelection exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/product-selections/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/product-selections/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  /**
   *	Deletion will only succeed if the Product Selection is not assigned to any [Store](ctp:api:type:Store).
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/product-selections/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyProductSelectionsRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withKey(childPathArgs) {
    return new ByProjectKeyProductSelectionsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeyProductSelectionsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/product-selections',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a ProductSelection exists for a given Query Predicate. Returns a `200 OK` status if any ProductSelections match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/product-selections',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/product-selections',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyProductTailoringByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/product-tailoring/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/product-tailoring/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  /**
   *	Generates the [ProductTailoringDeleted](ctp:api:type:ProductTailoringDeletedMessage) Message.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/product-tailoring/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyProductTailoringKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/product-tailoring/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/product-tailoring/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  /**
   *	Generates the [ProductTailoringDeleted](ctp:api:type:ProductTailoringDeletedMessage) Message.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/product-tailoring/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyProductTailoringRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withKey(childPathArgs) {
    return new ByProjectKeyProductTailoringKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeyProductTailoringByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/product-tailoring',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Generates the [ProductTailoringCreated](ctp:api:type:ProductTailoringCreatedMessage) Message.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/product-tailoring',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyProductTypesByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/product-types/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a ProductType exists for a given `id`. Returns a `200 OK` status if the ProductType exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/product-types/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/product-types/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/product-types/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyProductTypesKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/product-types/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a ProductType exists for a given `key`. Returns a `200 OK` status if the ProductType exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/product-types/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/product-types/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/product-types/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyProductTypesRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withKey(childPathArgs) {
    return new ByProjectKeyProductTypesKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeyProductTypesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/product-types',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a ProductType exists for a given Query Predicate. Returns a `200 OK` status if any ProductTypes match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/product-types',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/product-types',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyProductsSearchRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/products/search',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyProductsByIDImagesRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Upload a JPEG, PNG and GIF file to a [ProductVariant](ctp:api:type:ProductVariant). The maximum file size of the image is 10MB. `variant` or `sku` is required to update a specific ProductVariant. The image is uploaded to the Master Variant if `variant` or `sku` are not included. Produces the [ProductImageAdded](/projects/messages#product-image-added) Message when the `Small` version of the image has been uploaded to the CDN.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/products/{ID}/images',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyProductsByIDProductSelectionsRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/products/{ID}/product-selections',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyProductsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  images() {
    return new ByProjectKeyProductsByIDImagesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  productSelections() {
    return new ByProjectKeyProductsByIDProductSelectionsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	If [Price selection](ctp:api:type:ProductPriceSelection) query parameters are provided, the selected Prices are added to the response.
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/products/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Product exists for a given `id`. Returns a `200 OK` status if the Product exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/products/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  /**
   *	If [Price selection](ctp:api:type:ProductPriceSelection) query parameters are provided, the selected Prices are added to the response.
   *
   *	A failed response can return a [DuplicatePriceScope](ctp:api:type:DuplicatePriceScopeError), [DuplicateVariantValues](ctp:api:type:DuplicateVariantValuesError), [DuplicateAttributeValue](ctp:api:type:DuplicateAttributeValueError), or [DuplicateAttributeValues](ctp:api:type:DuplicateAttributeValuesError) error.
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/products/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  /**
   *	If [Price selection](ctp:api:type:ProductPriceSelection) query parameters are provided, the selected Prices are added to the response.
   *	Produces the [ProductDeleted](/projects/messages#product-deleted) Message.
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/products/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyProductsKeyByKeyProductSelectionsRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/products/key={key}/product-selections',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyProductsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  productSelections() {
    return new ByProjectKeyProductsKeyByKeyProductSelectionsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	If [Price selection](ctp:api:type:ProductPriceSelection) query parameters are provided, the selected Prices are added to the response.
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/products/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Product exists for a given `key`. Returns a `200 OK` status if the Product exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/products/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  /**
   *	A failed response can return a [DuplicatePriceScope](ctp:api:type:DuplicatePriceScopeError), [DuplicateVariantValues](ctp:api:type:DuplicateVariantValuesError), [DuplicateAttributeValue](ctp:api:type:DuplicateAttributeValueError), or [DuplicateAttributeValues](ctp:api:type:DuplicateAttributeValuesError) error.
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/products/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  /**
   *	If [Price selection](ctp:api:type:ProductPriceSelection) query parameters are provided, the selected Prices are added to the response.
   *	Produces the [ProductDeleted](/projects/messages#product-deleted) Message.
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/products/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyProductsRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withKey(childPathArgs) {
    return new ByProjectKeyProductsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeyProductsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	This endpoint provides high-performance search queries over Products. Product Search allows searching through all products with a current projection in your Project.
   *
   */
  search() {
    return new ByProjectKeyProductsSearchRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	If [Price selection](ctp:api:type:ProductPriceSelection) query parameters are provided, the selected Prices are added to the response.
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/products',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Product exists for a given Query Predicate. Returns a `200 OK` status if any Products match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/products',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	To create a new Product, send a representation that is going to become the initial _staged_ and _current_ representation of the new Product in the catalog.
   *	If [Price Selection](ctp:api:type:ProductPriceSelection) query parameters are provided, selected Prices will be added to the response.
   *	Produces the [ProductCreated](/projects/messages#product-created) Message.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/products',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyQuoteRequestsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/quote-requests/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a QuoteRequest exists for a given `id`. Returns a `200 OK` status if the QuoteRequest exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/quote-requests/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/quote-requests/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/quote-requests/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyQuoteRequestsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/quote-requests/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a QuoteRequest exists for a given `key`. Returns a `200 OK` status if the QuoteRequest exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/quote-requests/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/quote-requests/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/quote-requests/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyQuoteRequestsRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withKey(childPathArgs) {
    return new ByProjectKeyQuoteRequestsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeyQuoteRequestsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/quote-requests',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a QuoteRequest exists for a given Query Predicate. Returns a `200 OK` status if any QuoteRequests match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/quote-requests',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/quote-requests',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyQuotesByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/quotes/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Quote exists for a given `id`. Returns a `200 OK` status if the Quote exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/quotes/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/quotes/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/quotes/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyQuotesKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/quotes/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Quote exists for a given `key`. Returns a `200 OK` status if the Quote exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/quotes/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/quotes/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/quotes/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyQuotesRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withKey(childPathArgs) {
    return new ByProjectKeyQuotesKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeyQuotesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/quotes',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Quote exists for a given Query Predicate. Returns a `200 OK` status if any Quotes match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/quotes',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/quotes',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyReviewsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/reviews/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Review exists for a given `id`. Returns a `200 OK` status if the Review exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/reviews/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/reviews/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/reviews/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyReviewsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/reviews/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Review exists for a given `key`. Returns a `200 OK` status if the Review exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/reviews/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/reviews/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/reviews/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyReviewsRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withKey(childPathArgs) {
    return new ByProjectKeyReviewsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeyReviewsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/reviews',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Review exists for a given Query Predicate. Returns a `200 OK` status if any Reviews match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/reviews',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/reviews',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyShippingMethodsMatchingCartLocationRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Retrieves all the ShippingMethods that can ship to the given [Location](ctp:api:type:Location)
   *	with a `predicate` that matches the given Cart.
   *	Each ShippingMethod contains exactly one ShippingRate with the flag `isMatching` set to `true`.
   *	This ShippingRate is used when the ShippingMethod is [added to the Cart](ctp:api:type:CartSetShippingMethodAction).
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/shipping-methods/matching-cart-location',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a ShippingMethod that can ship to the given [Location](ctp:api:type:Location) exists for the given Cart. Returns a `200 OK` status if the ShippingMethod exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/shipping-methods/matching-cart-location',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyShippingMethodsMatchingCartRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Retrieves all the ShippingMethods that can ship to the shipping address of the given Cart.
   *	Each ShippingMethod contains exactly one ShippingRate with the flag `isMatching` set to `true`.
   *	This ShippingRate is used when the ShippingMethod is [added to the Cart](ctp:api:type:CartSetShippingMethodAction).
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/shipping-methods/matching-cart',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a ShippingMethod exists for the given Cart. Returns a `200 OK` status if the ShippingMethod exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/shipping-methods/matching-cart',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyShippingMethodsMatchingLocationRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Retrieves all the ShippingMethods that can ship to the given [Location](/projects/zones#location).
   *	ShippingMethods that have a `predicate` defined are automatically disqualified.
   *	If the `currency` parameter is given, then the ShippingMethods must also have a rate defined in the specified currency.
   *	Each ShippingMethod contains at least one ShippingRate with the flag `isMatching` set to `true`.
   *	If the `currency` parameter is given, exactly one ShippingRate will contain it.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/shipping-methods/matching-location',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a ShippingMethod that can ship to the given [Location](ctp:api:type:Location) exists. Returns a `200 OK` status if the ShippingMethod exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/shipping-methods/matching-location',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyShippingMethodsMatchingOrdereditRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	Retrieves all the ShippingMethods that can ship to the given [Location](ctp:api:type:Location) for an [OrderEdit](ctp:api:type:OrderEdit).
   *
   *	If the OrderEdit preview cannot be generated, an [EditPreviewFailed](ctp:api:type:EditPreviewFailedError) error is returned.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/shipping-methods/matching-orderedit',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a ShippingMethod that can ship to the given [Location](ctp:api:type:Location) exists for the given [OrderEdit](ctp:api:type:OrderEdit). Returns a `200 OK` status if the ShippingMethod exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/shipping-methods/matching-orderedit',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyShippingMethodsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/shipping-methods/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a ShippingMethod exists for a given `id`. Returns a `200 OK` status if the ShippingMethod exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/shipping-methods/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/shipping-methods/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/shipping-methods/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyShippingMethodsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/shipping-methods/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a ShippingMethod exists for a given `key`. Returns a `200 OK` status if the ShippingMethod exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/shipping-methods/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/shipping-methods/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/shipping-methods/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyShippingMethodsRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withKey(childPathArgs) {
    return new ByProjectKeyShippingMethodsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	Get ShippingMethods for a cart
   */
  matchingCart() {
    return new ByProjectKeyShippingMethodsMatchingCartRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	Get ShippingMethods for a cart and location
   */
  matchingCartLocation() {
    return new ByProjectKeyShippingMethodsMatchingCartLocationRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	Get ShippingMethods for an order edit
   */
  matchingOrderedit() {
    return new ByProjectKeyShippingMethodsMatchingOrdereditRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	Get ShippingMethods for a location
   */
  matchingLocation() {
    return new ByProjectKeyShippingMethodsMatchingLocationRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeyShippingMethodsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/shipping-methods',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a ShippingMethod exists for a given Query Predicate. Returns a `200 OK` status if any ShippingMethods match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/shipping-methods',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/shipping-methods',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyShoppingListsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/shopping-lists/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a ShoppingList exists for a given `id`. Returns a `200 OK` status if the ShoppingList exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/shopping-lists/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/shopping-lists/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/shopping-lists/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyShoppingListsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/shopping-lists/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a ShoppingList exists for a given `key`. Returns a `200 OK` status if the ShoppingList exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/shopping-lists/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/shopping-lists/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/shopping-lists/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyShoppingListsRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withKey(childPathArgs) {
    return new ByProjectKeyShoppingListsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeyShoppingListsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/shopping-lists',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a ShoppingList exists for a given Query Predicate. Returns a `200 OK` status if any ShoppingLists match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/shopping-lists',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/shopping-lists',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyStagedQuotesByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/staged-quotes/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a StagedQuote exists for a given `id`. Returns a `200 OK` status if the StagedQuote exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/staged-quotes/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/staged-quotes/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/staged-quotes/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyStagedQuotesKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/staged-quotes/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a StagedQuote exists for a given `key`. Returns a `200 OK` status if the StagedQuote exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/staged-quotes/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/staged-quotes/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/staged-quotes/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyStagedQuotesRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withKey(childPathArgs) {
    return new ByProjectKeyStagedQuotesKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeyStagedQuotesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/staged-quotes',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a StagedQuote exists for a given Query Predicate. Returns a `200 OK` status if any StagedQuotes match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/staged-quotes',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/staged-quotes',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyStandalonePricesByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/standalone-prices/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a StandalonePrice exists for a given `id`. Returns a `200 OK` status if the StandalonePrice exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/standalone-prices/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/standalone-prices/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  /**
   *	Produces the [StandalonePriceDeleted](ctp:api:type:StandalonePriceDeletedMessage) Message.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/standalone-prices/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyStandalonePricesKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/standalone-prices/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a StandalonePrice exists for a given `key`. Returns a `200 OK` status if the StandalonePrice exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/standalone-prices/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/standalone-prices/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  /**
   *	Produces the [StandalonePriceDeleted](ctp:api:type:StandalonePriceDeletedMessage) Message.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/standalone-prices/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyStandalonePricesRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withKey(childPathArgs) {
    return new ByProjectKeyStandalonePricesKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeyStandalonePricesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/standalone-prices',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a StandalonePrice exists for a given Query Predicate. Returns a `200 OK` status if any StandalonePrices match the Query Predicate, or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/standalone-prices',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Produces the [StandalonePriceCreated](ctp:api:type:StandalonePriceCreatedMessage) Message.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/standalone-prices',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyStatesByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/states/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a State exists for a given `id`. Returns a `200 OK` status if the State exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/states/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/states/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/states/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyStatesKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/states/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a State exists for a given `key`. Returns a `200 OK` status if the State exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/states/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/states/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/states/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyStatesRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withKey(childPathArgs) {
    return new ByProjectKeyStatesKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeyStatesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/states',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a State exists for a given Query Predicate. Returns a `200 OK` status if any States match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/states',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/states',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyStoresByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/stores/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Store exists for a given `id`. Returns a `200 OK` status if the Store exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/stores/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/stores/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/stores/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyStoresKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/stores/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Store exists for a given `key`. Returns a `200 OK` status if the Store exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/stores/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/stores/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/stores/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyStoresRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withKey(childPathArgs) {
    return new ByProjectKeyStoresKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeyStoresByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/stores',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Store exists for a given Query Predicate. Returns a `200 OK` status if any Stores match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/stores',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/stores',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeySubscriptionsByIDHealthRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  /**
   *	This endpoint can be polled by a monitoring or alerting system that checks the health of your Subscriptions. To ease integration with such systems this endpoint does not require [Authorization](/../api/authorization).
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/subscriptions/{ID}/health',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }
}
class ByProjectKeySubscriptionsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withIdHealth() {
    return new ByProjectKeySubscriptionsByIDHealthRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/subscriptions/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Subscription exists for a given `id`. Returns a `200 OK` status if the Subscription exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/subscriptions/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/subscriptions/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/subscriptions/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeySubscriptionsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/subscriptions/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Subscription exists for a given `key`. Returns a `200 OK` status if the Subscription exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/subscriptions/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/subscriptions/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/subscriptions/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeySubscriptionsRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withKey(childPathArgs) {
    return new ByProjectKeySubscriptionsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeySubscriptionsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/subscriptions',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Subscription exists for a given Query Predicate. Returns a `200 OK` status if any Subscriptions match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/subscriptions',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	A test message is sent to ensure the correct configuration of the Destination. If the message cannot be delivered, the Subscription will not be created. The payload of the test message is a notification of type [ResourceCreated](/../api/projects/subscriptions#resourcecreateddeliverypayload) for the `resourceTypeId` `subscription`.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/subscriptions',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyTaxCategoriesByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/tax-categories/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a TaxCategory exists for a given `id`. Returns a `200 OK` status if the TaxCategory exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/tax-categories/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/tax-categories/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/tax-categories/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyTaxCategoriesKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/tax-categories/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a TaxCategory exists for a given `key`. Returns a `200 OK` status if the Tax Category exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/tax-categories/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/tax-categories/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/tax-categories/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyTaxCategoriesRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withKey(childPathArgs) {
    return new ByProjectKeyTaxCategoriesKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeyTaxCategoriesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/tax-categories',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a TaxCategory exists for a given Query Predicate. Returns a `200 OK` status if any TaxCategories match the Query Predicate, or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/tax-categories',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/tax-categories',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyTypesByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/types/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Type exists for a given `id`. Returns a `200 OK` status if the Type exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/types/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/types/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/types/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyTypesKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/types/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Type exists for a given `key`. Returns a `200 OK` status if the Type exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/types/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/types/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/types/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyTypesRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withKey(childPathArgs) {
    return new ByProjectKeyTypesKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeyTypesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/types',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Type exists for a given Query Predicate. Returns a `200 OK` status if any Types match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/types',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/types',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyZonesByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/zones/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Zone exists for a given `id`. Returns a `200 OK` status if the Zone exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/zones/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/zones/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/zones/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyZonesKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/zones/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Zone exists for a given `key`. Returns a `200 OK` status if the Zone exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/zones/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/zones/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }

  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/zones/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyZonesRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  withKey(childPathArgs) {
    return new ByProjectKeyZonesKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  withId(childPathArgs) {
    return new ByProjectKeyZonesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/zones',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Zone exists for a given Query Predicate. Returns a `200 OK` status if any Zones match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/zones',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/zones',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      queryParams: methodArgs == null ? void 0 : methodArgs.queryArgs,
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ByProjectKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }

  asAssociate() {
    return new ByProjectKeyAsAssociateRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	An Associate Role enables permissions over a Business Unit to an Associate.
   */
  associateRoles() {
    return new ByProjectKeyAssociateRolesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	A Business Unit can represent a Company or a Division.
   */
  businessUnits() {
    return new ByProjectKeyBusinessUnitsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	Categories are used to organize products in a hierarchical structure.
   */
  categories() {
    return new ByProjectKeyCategoriesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	A shopping cart holds product variants and can be ordered.
   */
  carts() {
    return new ByProjectKeyCartsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	Cart discounts are used to change the prices of different elements within a cart.
   */
  cartDiscounts() {
    return new ByProjectKeyCartDiscountsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	Channels represent a source or destination of different entities. They can be used to model warehouses or stores.
   *
   */
  channels() {
    return new ByProjectKeyChannelsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	A Customer is a person purchasing products. Carts, Orders, Quotes, Reviews and Payments can be associated to a Customer.
   *
   */
  customers() {
    return new ByProjectKeyCustomersRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	customer-groups are used to evaluate products and channels.
   */
  customerGroups() {
    return new ByProjectKeyCustomerGroupsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	Store custom JSON values.
   */
  customObjects() {
    return new ByProjectKeyCustomObjectsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	Discount Codes can be added to a discount-code to enable certain discount-code discounts.
   */
  discountCodes() {
    return new ByProjectKeyDiscountCodesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	commercetools Composable Commerce provides a GraphQL API
   */
  graphql() {
    return new ByProjectKeyGraphqlRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	Inventory allows you to track stock quantities.
   */
  inventory() {
    return new ByProjectKeyInventoryRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	Retrieves the authenticated customer.
   */
  login() {
    return new ByProjectKeyLoginRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	A message represents a change or an action performed on a resource (like an Order or a Product).
   */
  messages() {
    return new ByProjectKeyMessagesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	An order can be created from a order, usually after a checkout process has been completed.
   */
  orders() {
    return new ByProjectKeyOrdersRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	Payments hold information about the current state of receiving and/or refunding money
   */
  payments() {
    return new ByProjectKeyPaymentsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	Products themselves are not sellable. Instead, they act as a parent structure for sellable Product Variants.
   *
   */
  products() {
    return new ByProjectKeyProductsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	Product discounts are used to change certain product prices.
   */
  productDiscounts() {
    return new ByProjectKeyProductDiscountsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	A projected representation of a product shows the product with its current or staged data. The current or staged
   *	representation of a product in a catalog is called a product projection.
   *
   */
  productProjections() {
    return new ByProjectKeyProductProjectionsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	Manage individual Store assortments through Product Selections.
   *
   *	After you have created Product Selections and populated them with Products,
   *	you can manage Store assortments by assigning Product Selections to Stores.
   *	Product Selections may be used by a single Store or shared across several Stores.
   *
   *	As a good practice, we recommend first creating Products in the project, and then creating Product Selection.
   *
   */
  productSelections() {
    return new ByProjectKeyProductSelectionsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	Product tailoring are used to contextualize product data for specific stores.
   */
  productTailoring() {
    return new ByProjectKeyProductTailoringRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	Product Types are used to describe common characteristics, most importantly common custom attributes,
   *	of many concrete products.
   *
   */
  productTypes() {
    return new ByProjectKeyProductTypesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	A quote holds the negotiated offer.
   */
  quotes() {
    return new ByProjectKeyQuotesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	A request for a Quote holds product variants and can be ordered.
   */
  quoteRequests() {
    return new ByProjectKeyQuoteRequestsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	A staged quote holds the negotiation between the [Buyer](/../api/quotes-overview#buyer) and the [Seller](/../api/quotes-overview#seller).
   */
  stagedQuotes() {
    return new ByProjectKeyStagedQuotesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	Reviews are used to evaluate products and channels.
   */
  reviews() {
    return new ByProjectKeyReviewsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	ShippingMethods define where orders can be shipped and what the costs are.
   */
  shippingMethods() {
    return new ByProjectKeyShippingMethodsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	shopping-lists e.g. for wishlist support
   */
  shoppingLists() {
    return new ByProjectKeyShoppingListsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	commercetools Composable Commerce allows you to model states of certain objects, such as orders, line items, products,
   *	reviews, and payments in order to define finite state machines reflecting the business logic you'd like to
   *	implement.
   *
   */
  states() {
    return new ByProjectKeyStatesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	Subscriptions allow you to be notified of new messages or changes via a Message Queue of your choice
   */
  subscriptions() {
    return new ByProjectKeySubscriptionsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	Tax Categories define how products are to be taxed in different countries.
   */
  taxCategories() {
    return new ByProjectKeyTaxCategoriesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	Types define custom fields that are used to enhance resources as you need.
   */
  types() {
    return new ByProjectKeyTypesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	Zones allow defining ShippingRates for specific Locations.
   */
  zones() {
    return new ByProjectKeyZonesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  me() {
    return new ByProjectKeyMeRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	Extend the behavior of an API with your business logic
   */
  extensions() {
    return new ByProjectKeyExtensionsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	Manage your API Clients via an API. Useful for Infrastructure-as-Code tooling, and regularly rotating API secrets.
   *
   */
  apiClients() {
    return new ByProjectKeyApiClientsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	Stores let you model the context your customers shop in.
   */
  stores() {
    return new ByProjectKeyStoresRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  inStoreKeyWithStoreKeyValue(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	A standalone price assigns a price to a product variant for a given scope. The API will use the standalone prices associated with a Product if its field [`priceMode`](/projects/products#pricemode) is set to `Standalone` [ProductPriceMode](ctp:api:type:ProductPriceModeEnum).
   */
  standalonePrices() {
    return new ByProjectKeyStandalonePricesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  inBusinessUnitKeyWithBusinessUnitKeyValue(childPathArgs) {
    return new ByProjectKeyInBusinessUnitKeyByBusinessUnitKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  /**
   *	Attribute groups ... TODO
   */
  attributeGroups() {
    return new ByProjectKeyAttributeGroupsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri,
    });
  }

  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  /**
   *	Checks if a Project exists for a given `projectKey`. Returns a `200 OK` status if the Project exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
    }, this.args.executeRequest);
  }

  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs == null ? void 0 : methodArgs.headers,
      },
      body: methodArgs == null ? void 0 : methodArgs.body,
    }, this.args.executeRequest);
  }
}
class ApiRoot {
  constructor(args) {
    _defineProperty(this, 'executeRequest', void 0);
    _defineProperty(this, 'baseUri', void 0);
    this.executeRequest = args.executeRequest;
    this.baseUri = args.baseUri || 'https://api.europe-west1.gcp.commercetools.com';
  }

  /**
   *	The Project endpoint is used to retrieve certain information from a project.
   */
  withProjectKey(childPathArgs) {
    return new ByProjectKeyRequestBuilder({
      pathArgs: {
        ...childPathArgs,
      },
      executeRequest: this.executeRequest,
      baseUri: this.baseUri,
    });
  }
}
function createApiBuilderFromCtpClient(ctpClient2, baseUri) {
  return new ApiRoot({
    executeRequest: ctpClient2.execute,
    baseUri,
  });
}
function showToast(error) {
  const bodyApp = document.querySelector('#app');
  const modalContainerParams = {
    tag: 'div',
    classNames: ['modal_container'],
  };
  const toastContainerParams = {
    tag: 'div',
    classNames: ['toast_container'],
  };
  const infoMsgParams = {
    tag: 'h1',
    textContent: 'Oops! Something wrong. Wait until window is closed & try again',
    classNames: ['info_msg'],
  };
  const errorMsgParams = {
    tag: 'h3',
    textContent: `${error}`,
    classNames: ['error_msg'],
  };
  const timerParams = {
    tag: 'div',
    classNames: ['timer'],
  };
  const toastContainer = createElement$1(toastContainerParams);
  const modalContainer = createElement$1(modalContainerParams);
  const infoMsg = createElement$1(infoMsgParams);
  const errorMsg = createElement$1(errorMsgParams);
  const timer = createElement$1(timerParams);
  addInnerComponent(modalContainer, toastContainer);
  addInnerComponent(toastContainer, infoMsg);
  addInnerComponent(toastContainer, errorMsg);
  addInnerComponent(toastContainer, timer);
  if (bodyApp) {
    addInnerComponent(bodyApp, modalContainer);
  }
  let countdown = 5;
  const intervalId = setInterval(() => {
    countdown--;
    timer.textContent = `This window will be closed in ${countdown} seconds.`;
    if (countdown === 1) {
      clearInterval(intervalId);
      modalContainer.remove();
    }
  }, 1e3);
}
function isCustomError(error) {
  return typeof error === 'object' && error !== null && 'body' in error && typeof error.body === 'object' && 'message' in error.body;
}
function createInput(id, classes2, validationType, type = 'text') {
  const inputParams = {
    tag: 'input',
    attributes: {
      id,
      type,
      name: id,
      'data-validation-type': validationType,
      required: '',
    },
    classNames: classes2[1],
  };
  const labelParams = {
    tag: 'label',
    textContent: id,
    attributes: {
      for: id,
    },
    classNames: classes2[0],
  };
  const input = createElement$1(inputParams);
  const label = createElement$1(labelParams);
  return [label, input];
}
function createErrorElement() {
  return createElement$1({
    tag: 'span',
    classNames: ['error'],
  });
}
function filterArray(form) {
  return Array.from(form.elements).filter(
    (element) => element.tagName === 'INPUT' && element.getAttribute('type') !== 'checkbox' && element.getAttribute('hide') !== '',
  );
}
function isEmptyArray(arr) {
  if (arr.length === 0) {
    return true;
  } else {
    return false;
  }
}
function calculateAge(date) {
  const currentDate = /* @__PURE__ */ new Date();
  let age = currentDate.getFullYear() - date.getFullYear();
  if (currentDate.getMonth() < date.getMonth() || currentDate.getMonth() === date.getMonth() && currentDate.getDate() < date.getDate()) {
    age--;
  }
  return age;
}
function checkDaysInMonth(month, year) {
  return new Date(+year, +month, 0).getDate();
}
var countryListJs = { exports: {} };
const AS$8 = 'Asia';
const EU = 'Europe';
const AF$8 = 'Africa';
const NA$8 = 'North America';
const SA$8 = 'South America';
const AN$1 = 'Antarctica';
const OC = 'Oceania';
const require$$0$2 = {
  AS: AS$8,
  EU,
  AF: AF$8,
  NA: NA$8,
  SA: SA$8,
  AN: AN$1,
  OC,
};
const BD$8 = 'AS';
const BE$8 = 'EU';
const BF$7 = 'AF';
const BG$7 = 'EU';
const BA$7 = 'EU';
const BB$7 = 'NA';
const WF$7 = 'OC';
const BL$7 = 'NA';
const BM$7 = 'NA';
const BN$7 = 'AS';
const BO$8 = 'SA';
const BH$7 = 'AS';
const BI$7 = 'AF';
const BJ$7 = 'AF';
const BT$7 = 'AS';
const JM$7 = 'NA';
const BV$7 = 'AN';
const BW$7 = 'AF';
const WS$7 = 'OC';
const BQ$6 = 'NA';
const BR$8 = 'SA';
const BS$7 = 'NA';
const JE$7 = 'EU';
const BY$7 = 'EU';
const BZ$7 = 'NA';
const RU$7 = 'EU';
const RW$7 = 'AF';
const RS$7 = 'EU';
const TL$7 = 'OC';
const RE$7 = 'AF';
const TM$7 = 'AS';
const TJ$7 = 'AS';
const RO$7 = 'EU';
const TK$7 = 'OC';
const GW$7 = 'AF';
const GU$7 = 'OC';
const GT$7 = 'NA';
const GS$7 = 'AN';
const GR$7 = 'EU';
const GQ$7 = 'AF';
const GP$7 = 'NA';
const JP$8 = 'AS';
const GY$7 = 'SA';
const GG$7 = 'EU';
const GF$7 = 'SA';
const GE$7 = 'AS';
const GD$7 = 'NA';
const GB$8 = 'EU';
const GA$7 = 'AF';
const SV$7 = 'NA';
const GN$7 = 'AF';
const GM$7 = 'AF';
const GL$7 = 'NA';
const GI$7 = 'EU';
const GH$7 = 'AF';
const OM$7 = 'AS';
const TN$7 = 'AF';
const JO$8 = 'AS';
const HR$7 = 'EU';
const HT$7 = 'NA';
const HU$7 = 'EU';
const HK$7 = 'AS';
const HN$7 = 'NA';
const HM$7 = 'AN';
const VE$7 = 'SA';
const PR$7 = 'NA';
const PS$7 = 'AS';
const PW$7 = 'OC';
const PT$7 = 'EU';
const SJ$7 = 'EU';
const PY$7 = 'SA';
const IQ$7 = 'AS';
const PA$7 = 'NA';
const PF$7 = 'OC';
const PG$7 = 'OC';
const PE$8 = 'SA';
const PK$8 = 'AS';
const PH$8 = 'AS';
const PN$7 = 'OC';
const PL$7 = 'EU';
const PM$7 = 'NA';
const ZM$7 = 'AF';
const EH$7 = 'AF';
const EE$7 = 'EU';
const EG$7 = 'AF';
const ZA$7 = 'AF';
const EC$7 = 'SA';
const IT$8 = 'EU';
const VN$8 = 'AS';
const SB$7 = 'OC';
const ET$8 = 'AF';
const SO$7 = 'AF';
const ZW$7 = 'AF';
const SA$7 = 'AS';
const ES$8 = 'EU';
const ER$7 = 'AF';
const ME$7 = 'EU';
const MD$7 = 'EU';
const MG$7 = 'AF';
const MF$7 = 'NA';
const MA$7 = 'AF';
const MC$7 = 'EU';
const UZ$7 = 'AS';
const MM$7 = 'AS';
const ML$7 = 'AF';
const MO$7 = 'AS';
const MN$7 = 'AS';
const MH$7 = 'OC';
const MK$7 = 'EU';
const MU$7 = 'AF';
const MT$7 = 'EU';
const MW$7 = 'AF';
const MV$7 = 'AS';
const MQ$7 = 'NA';
const MP$7 = 'OC';
const MS$7 = 'NA';
const MR$7 = 'AF';
const IM$7 = 'EU';
const UG$7 = 'AF';
const TZ$7 = 'AF';
const MY$7 = 'AS';
const MX$8 = 'NA';
const IL$7 = 'AS';
const FR$7 = 'EU';
const IO$7 = 'AS';
const SH$7 = 'AF';
const FI$7 = 'EU';
const FJ$7 = 'OC';
const FK$7 = 'SA';
const FM$7 = 'OC';
const FO$7 = 'EU';
const NI$7 = 'NA';
const NL$8 = 'EU';
const NO$7 = 'EU';
const NA$7 = 'AF';
const VU$7 = 'OC';
const NC$7 = 'OC';
const NE$7 = 'AF';
const NF$7 = 'OC';
const NG$8 = 'AF';
const NZ$7 = 'OC';
const NP$7 = 'AS';
const NR$7 = 'OC';
const NU$7 = 'OC';
const CK$7 = 'OC';
const XK$6 = 'EU';
const CI$7 = 'AF';
const CH$7 = 'EU';
const CO$7 = 'SA';
const CN$8 = 'AS';
const CM$7 = 'AF';
const CL$8 = 'SA';
const CC$7 = 'AS';
const CA$8 = 'NA';
const CG$7 = 'AF';
const CF$7 = 'AF';
const CD$7 = 'AF';
const CZ$7 = 'EU';
const CY$7 = 'EU';
const CX$7 = 'AS';
const CR$7 = 'NA';
const CW$6 = 'NA';
const CV$7 = 'AF';
const CU$8 = 'NA';
const SZ$7 = 'AF';
const SY$7 = 'AS';
const SX$6 = 'NA';
const KG$7 = 'AS';
const KE$7 = 'AF';
const SS$7 = 'AF';
const SR$7 = 'SA';
const KI$7 = 'OC';
const KH$8 = 'AS';
const KN$7 = 'NA';
const KM$7 = 'AF';
const ST$7 = 'AF';
const SK$7 = 'EU';
const KR$7 = 'AS';
const SI$7 = 'EU';
const KP$7 = 'AS';
const KW$7 = 'AS';
const SN$7 = 'AF';
const SM$7 = 'EU';
const SL$7 = 'AF';
const SC$7 = 'AF';
const KZ$7 = 'AS';
const KY$7 = 'NA';
const SG$7 = 'AS';
const SE$7 = 'EU';
const SD$7 = 'AF';
const DO$7 = 'NA';
const DM$7 = 'NA';
const DJ$7 = 'AF';
const DK$8 = 'EU';
const VG$7 = 'NA';
const DE$8 = 'EU';
const YE$7 = 'AS';
const DZ$7 = 'AF';
const US$8 = 'NA';
const UY$7 = 'SA';
const YT$7 = 'AF';
const UM$7 = 'OC';
const LB$7 = 'AS';
const LC$7 = 'NA';
const LA$7 = 'AS';
const TV$7 = 'OC';
const TW$7 = 'AS';
const TT$7 = 'NA';
const TR$8 = 'AS';
const LK$7 = 'AS';
const LI$7 = 'EU';
const LV$7 = 'EU';
const TO$7 = 'OC';
const LT$7 = 'EU';
const LU$7 = 'EU';
const LR$7 = 'AF';
const LS$7 = 'AF';
const TH$7 = 'AS';
const TF$7 = 'AN';
const TG$7 = 'AF';
const TD$7 = 'AF';
const TC$7 = 'NA';
const LY$7 = 'AF';
const VA$7 = 'EU';
const VC$7 = 'NA';
const AE$7 = 'AS';
const AD$7 = 'EU';
const AG$7 = 'NA';
const AF$7 = 'AS';
const AI$7 = 'NA';
const VI$7 = 'NA';
const IS$7 = 'EU';
const IR$7 = 'AS';
const AM$7 = 'AS';
const AL$7 = 'EU';
const AO$7 = 'AF';
const AQ$7 = 'AN';
const AS$7 = 'OC';
const AR$8 = 'SA';
const AU$8 = 'OC';
const AT$8 = 'EU';
const AW$7 = 'NA';
const IN$8 = 'AS';
const AX$7 = 'EU';
const AZ$7 = 'AS';
const IE$7 = 'EU';
const ID$8 = 'AS';
const UA$7 = 'EU';
const QA$7 = 'AS';
const MZ$7 = 'AF';
const require$$1$2 = {
  BD: BD$8,
  BE: BE$8,
  BF: BF$7,
  BG: BG$7,
  BA: BA$7,
  BB: BB$7,
  WF: WF$7,
  BL: BL$7,
  BM: BM$7,
  BN: BN$7,
  BO: BO$8,
  BH: BH$7,
  BI: BI$7,
  BJ: BJ$7,
  BT: BT$7,
  JM: JM$7,
  BV: BV$7,
  BW: BW$7,
  WS: WS$7,
  BQ: BQ$6,
  BR: BR$8,
  BS: BS$7,
  JE: JE$7,
  BY: BY$7,
  BZ: BZ$7,
  RU: RU$7,
  RW: RW$7,
  RS: RS$7,
  TL: TL$7,
  RE: RE$7,
  TM: TM$7,
  TJ: TJ$7,
  RO: RO$7,
  TK: TK$7,
  GW: GW$7,
  GU: GU$7,
  GT: GT$7,
  GS: GS$7,
  GR: GR$7,
  GQ: GQ$7,
  GP: GP$7,
  JP: JP$8,
  GY: GY$7,
  GG: GG$7,
  GF: GF$7,
  GE: GE$7,
  GD: GD$7,
  GB: GB$8,
  GA: GA$7,
  SV: SV$7,
  GN: GN$7,
  GM: GM$7,
  GL: GL$7,
  GI: GI$7,
  GH: GH$7,
  OM: OM$7,
  TN: TN$7,
  JO: JO$8,
  HR: HR$7,
  HT: HT$7,
  HU: HU$7,
  HK: HK$7,
  HN: HN$7,
  HM: HM$7,
  VE: VE$7,
  PR: PR$7,
  PS: PS$7,
  PW: PW$7,
  PT: PT$7,
  SJ: SJ$7,
  PY: PY$7,
  IQ: IQ$7,
  PA: PA$7,
  PF: PF$7,
  PG: PG$7,
  PE: PE$8,
  PK: PK$8,
  PH: PH$8,
  PN: PN$7,
  PL: PL$7,
  PM: PM$7,
  ZM: ZM$7,
  EH: EH$7,
  EE: EE$7,
  EG: EG$7,
  ZA: ZA$7,
  EC: EC$7,
  IT: IT$8,
  VN: VN$8,
  SB: SB$7,
  ET: ET$8,
  SO: SO$7,
  ZW: ZW$7,
  SA: SA$7,
  ES: ES$8,
  ER: ER$7,
  ME: ME$7,
  MD: MD$7,
  MG: MG$7,
  MF: MF$7,
  MA: MA$7,
  MC: MC$7,
  UZ: UZ$7,
  MM: MM$7,
  ML: ML$7,
  MO: MO$7,
  MN: MN$7,
  MH: MH$7,
  MK: MK$7,
  MU: MU$7,
  MT: MT$7,
  MW: MW$7,
  MV: MV$7,
  MQ: MQ$7,
  MP: MP$7,
  MS: MS$7,
  MR: MR$7,
  IM: IM$7,
  UG: UG$7,
  TZ: TZ$7,
  MY: MY$7,
  MX: MX$8,
  IL: IL$7,
  FR: FR$7,
  IO: IO$7,
  SH: SH$7,
  FI: FI$7,
  FJ: FJ$7,
  FK: FK$7,
  FM: FM$7,
  FO: FO$7,
  NI: NI$7,
  NL: NL$8,
  NO: NO$7,
  NA: NA$7,
  VU: VU$7,
  NC: NC$7,
  NE: NE$7,
  NF: NF$7,
  NG: NG$8,
  NZ: NZ$7,
  NP: NP$7,
  NR: NR$7,
  NU: NU$7,
  CK: CK$7,
  XK: XK$6,
  CI: CI$7,
  CH: CH$7,
  CO: CO$7,
  CN: CN$8,
  CM: CM$7,
  CL: CL$8,
  CC: CC$7,
  CA: CA$8,
  CG: CG$7,
  CF: CF$7,
  CD: CD$7,
  CZ: CZ$7,
  CY: CY$7,
  CX: CX$7,
  CR: CR$7,
  CW: CW$6,
  CV: CV$7,
  CU: CU$8,
  SZ: SZ$7,
  SY: SY$7,
  SX: SX$6,
  KG: KG$7,
  KE: KE$7,
  SS: SS$7,
  SR: SR$7,
  KI: KI$7,
  KH: KH$8,
  KN: KN$7,
  KM: KM$7,
  ST: ST$7,
  SK: SK$7,
  KR: KR$7,
  SI: SI$7,
  KP: KP$7,
  KW: KW$7,
  SN: SN$7,
  SM: SM$7,
  SL: SL$7,
  SC: SC$7,
  KZ: KZ$7,
  KY: KY$7,
  SG: SG$7,
  SE: SE$7,
  SD: SD$7,
  DO: DO$7,
  DM: DM$7,
  DJ: DJ$7,
  DK: DK$8,
  VG: VG$7,
  DE: DE$8,
  YE: YE$7,
  DZ: DZ$7,
  US: US$8,
  UY: UY$7,
  YT: YT$7,
  UM: UM$7,
  LB: LB$7,
  LC: LC$7,
  LA: LA$7,
  TV: TV$7,
  TW: TW$7,
  TT: TT$7,
  TR: TR$8,
  LK: LK$7,
  LI: LI$7,
  LV: LV$7,
  TO: TO$7,
  LT: LT$7,
  LU: LU$7,
  LR: LR$7,
  LS: LS$7,
  TH: TH$7,
  TF: TF$7,
  TG: TG$7,
  TD: TD$7,
  TC: TC$7,
  LY: LY$7,
  VA: VA$7,
  VC: VC$7,
  AE: AE$7,
  AD: AD$7,
  AG: AG$7,
  AF: AF$7,
  AI: AI$7,
  VI: VI$7,
  IS: IS$7,
  IR: IR$7,
  AM: AM$7,
  AL: AL$7,
  AO: AO$7,
  AQ: AQ$7,
  AS: AS$7,
  AR: AR$8,
  AU: AU$8,
  AT: AT$8,
  AW: AW$7,
  IN: IN$8,
  AX: AX$7,
  AZ: AZ$7,
  IE: IE$7,
  ID: ID$8,
  UA: UA$7,
  QA: QA$7,
  MZ: MZ$7,
};
const BD$7 = 'BGD';
const BE$7 = 'BEL';
const BF$6 = 'BFA';
const BG$6 = 'BGR';
const BA$6 = 'BIH';
const BB$6 = 'BRB';
const WF$6 = 'WLF';
const BL$6 = 'BLM';
const BM$6 = 'BMU';
const BN$6 = 'BRN';
const BO$7 = 'BOL';
const BH$6 = 'BHR';
const BI$6 = 'BDI';
const BJ$6 = 'BEN';
const BT$6 = 'BTN';
const JM$6 = 'JAM';
const BV$6 = 'BVT';
const BW$6 = 'BWA';
const WS$6 = 'WSM';
const BQ$5 = 'BES';
const BR$7 = 'BRA';
const BS$6 = 'BHS';
const JE$6 = 'JEY';
const BY$6 = 'BLR';
const BZ$6 = 'BLZ';
const RU$6 = 'RUS';
const RW$6 = 'RWA';
const RS$6 = 'SRB';
const TL$6 = 'TLS';
const RE$6 = 'REU';
const TM$6 = 'TKM';
const TJ$6 = 'TJK';
const RO$6 = 'ROU';
const TK$6 = 'TKL';
const GW$6 = 'GNB';
const GU$6 = 'GUM';
const GT$6 = 'GTM';
const GS$6 = 'SGS';
const GR$6 = 'GRC';
const GQ$6 = 'GNQ';
const GP$6 = 'GLP';
const JP$7 = 'JPN';
const GY$6 = 'GUY';
const GG$6 = 'GGY';
const GF$6 = 'GUF';
const GE$6 = 'GEO';
const GD$6 = 'GRD';
const GB$7 = 'GBR';
const GA$6 = 'GAB';
const SV$6 = 'SLV';
const GN$6 = 'GIN';
const GM$6 = 'GMB';
const GL$6 = 'GRL';
const GI$6 = 'GIB';
const GH$6 = 'GHA';
const OM$6 = 'OMN';
const TN$6 = 'TUN';
const JO$7 = 'JOR';
const HR$6 = 'HRV';
const HT$6 = 'HTI';
const HU$6 = 'HUN';
const HK$6 = 'HKG';
const HN$6 = 'HND';
const HM$6 = 'HMD';
const VE$6 = 'VEN';
const PR$6 = 'PRI';
const PS$6 = 'PSE';
const PW$6 = 'PLW';
const PT$6 = 'PRT';
const SJ$6 = 'SJM';
const PY$6 = 'PRY';
const IQ$6 = 'IRQ';
const PA$6 = 'PAN';
const PF$6 = 'PYF';
const PG$6 = 'PNG';
const PE$7 = 'PER';
const PK$7 = 'PAK';
const PH$7 = 'PHL';
const PN$6 = 'PCN';
const PL$6 = 'POL';
const PM$6 = 'SPM';
const ZM$6 = 'ZMB';
const EH$6 = 'ESH';
const EE$6 = 'EST';
const EG$6 = 'EGY';
const ZA$6 = 'ZAF';
const EC$6 = 'ECU';
const IT$7 = 'ITA';
const VN$7 = 'VNM';
const SB$6 = 'SLB';
const ET$7 = 'ETH';
const SO$6 = 'SOM';
const ZW$6 = 'ZWE';
const SA$6 = 'SAU';
const ES$7 = 'ESP';
const ER$6 = 'ERI';
const ME$6 = 'MNE';
const MD$6 = 'MDA';
const MG$6 = 'MDG';
const MF$6 = 'MAF';
const MA$6 = 'MAR';
const MC$6 = 'MCO';
const UZ$6 = 'UZB';
const MM$6 = 'MMR';
const ML$6 = 'MLI';
const MO$6 = 'MAC';
const MN$6 = 'MNG';
const MH$6 = 'MHL';
const MK$6 = 'MKD';
const MU$6 = 'MUS';
const MT$6 = 'MLT';
const MW$6 = 'MWI';
const MV$6 = 'MDV';
const MQ$6 = 'MTQ';
const MP$6 = 'MNP';
const MS$6 = 'MSR';
const MR$6 = 'MRT';
const IM$6 = 'IMN';
const UG$6 = 'UGA';
const TZ$6 = 'TZA';
const MY$6 = 'MYS';
const MX$7 = 'MEX';
const IL$6 = 'ISR';
const FR$6 = 'FRA';
const IO$6 = 'IOT';
const SH$6 = 'SHN';
const FI$6 = 'FIN';
const FJ$6 = 'FJI';
const FK$6 = 'FLK';
const FM$6 = 'FSM';
const FO$6 = 'FRO';
const NI$6 = 'NIC';
const NL$7 = 'NLD';
const NO$6 = 'NOR';
const NA$6 = 'NAM';
const VU$6 = 'VUT';
const NC$6 = 'NCL';
const NE$6 = 'NER';
const NF$6 = 'NFK';
const NG$7 = 'NGA';
const NZ$6 = 'NZL';
const NP$6 = 'NPL';
const NR$6 = 'NRU';
const NU$6 = 'NIU';
const CK$6 = 'COK';
const XK$5 = 'XKX';
const CI$6 = 'CIV';
const CH$6 = 'CHE';
const CO$6 = 'COL';
const CN$7 = 'CHN';
const CM$6 = 'CMR';
const CL$7 = 'CHL';
const CC$6 = 'CCK';
const CA$7 = 'CAN';
const CG$6 = 'COG';
const CF$6 = 'CAF';
const CD$6 = 'COD';
const CZ$6 = 'CZE';
const CY$6 = 'CYP';
const CX$6 = 'CXR';
const CR$6 = 'CRI';
const CW$5 = 'CUW';
const CV$6 = 'CPV';
const CU$7 = 'CUB';
const SZ$6 = 'SWZ';
const SY$6 = 'SYR';
const SX$5 = 'SXM';
const KG$6 = 'KGZ';
const KE$6 = 'KEN';
const SS$6 = 'SSD';
const SR$6 = 'SUR';
const KI$6 = 'KIR';
const KH$7 = 'KHM';
const KN$6 = 'KNA';
const KM$6 = 'COM';
const ST$6 = 'STP';
const SK$6 = 'SVK';
const KR$6 = 'KOR';
const SI$6 = 'SVN';
const KP$6 = 'PRK';
const KW$6 = 'KWT';
const SN$6 = 'SEN';
const SM$6 = 'SMR';
const SL$6 = 'SLE';
const SC$6 = 'SYC';
const KZ$6 = 'KAZ';
const KY$6 = 'CYM';
const SG$6 = 'SGP';
const SE$6 = 'SWE';
const SD$6 = 'SDN';
const DO$6 = 'DOM';
const DM$6 = 'DMA';
const DJ$6 = 'DJI';
const DK$7 = 'DNK';
const VG$6 = 'VGB';
const DE$7 = 'DEU';
const YE$6 = 'YEM';
const DZ$6 = 'DZA';
const US$7 = 'USA';
const UY$6 = 'URY';
const YT$6 = 'MYT';
const UM$6 = 'UMI';
const LB$6 = 'LBN';
const LC$6 = 'LCA';
const LA$6 = 'LAO';
const TV$6 = 'TUV';
const TW$6 = 'TWN';
const TT$6 = 'TTO';
const TR$7 = 'TUR';
const LK$6 = 'LKA';
const LI$6 = 'LIE';
const LV$6 = 'LVA';
const TO$6 = 'TON';
const LT$6 = 'LTU';
const LU$6 = 'LUX';
const LR$6 = 'LBR';
const LS$6 = 'LSO';
const TH$6 = 'THA';
const TF$6 = 'ATF';
const TG$6 = 'TGO';
const TD$6 = 'TCD';
const TC$6 = 'TCA';
const LY$6 = 'LBY';
const VA$6 = 'VAT';
const VC$6 = 'VCT';
const AE$6 = 'ARE';
const AD$6 = 'AND';
const AG$6 = 'ATG';
const AF$6 = 'AFG';
const AI$6 = 'AIA';
const VI$6 = 'VIR';
const IS$6 = 'ISL';
const IR$6 = 'IRN';
const AM$6 = 'ARM';
const AL$6 = 'ALB';
const AO$6 = 'AGO';
const AQ$6 = 'ATA';
const AS$6 = 'ASM';
const AR$7 = 'ARG';
const AU$7 = 'AUS';
const AT$7 = 'AUT';
const AW$6 = 'ABW';
const IN$7 = 'IND';
const AX$6 = 'ALA';
const AZ$6 = 'AZE';
const IE$6 = 'IRL';
const ID$7 = 'IDN';
const UA$6 = 'UKR';
const QA$6 = 'QAT';
const MZ$6 = 'MOZ';
const require$$2$1 = {
  BD: BD$7,
  BE: BE$7,
  BF: BF$6,
  BG: BG$6,
  BA: BA$6,
  BB: BB$6,
  WF: WF$6,
  BL: BL$6,
  BM: BM$6,
  BN: BN$6,
  BO: BO$7,
  BH: BH$6,
  BI: BI$6,
  BJ: BJ$6,
  BT: BT$6,
  JM: JM$6,
  BV: BV$6,
  BW: BW$6,
  WS: WS$6,
  BQ: BQ$5,
  BR: BR$7,
  BS: BS$6,
  JE: JE$6,
  BY: BY$6,
  BZ: BZ$6,
  RU: RU$6,
  RW: RW$6,
  RS: RS$6,
  TL: TL$6,
  RE: RE$6,
  TM: TM$6,
  TJ: TJ$6,
  RO: RO$6,
  TK: TK$6,
  GW: GW$6,
  GU: GU$6,
  GT: GT$6,
  GS: GS$6,
  GR: GR$6,
  GQ: GQ$6,
  GP: GP$6,
  JP: JP$7,
  GY: GY$6,
  GG: GG$6,
  GF: GF$6,
  GE: GE$6,
  GD: GD$6,
  GB: GB$7,
  GA: GA$6,
  SV: SV$6,
  GN: GN$6,
  GM: GM$6,
  GL: GL$6,
  GI: GI$6,
  GH: GH$6,
  OM: OM$6,
  TN: TN$6,
  JO: JO$7,
  HR: HR$6,
  HT: HT$6,
  HU: HU$6,
  HK: HK$6,
  HN: HN$6,
  HM: HM$6,
  VE: VE$6,
  PR: PR$6,
  PS: PS$6,
  PW: PW$6,
  PT: PT$6,
  SJ: SJ$6,
  PY: PY$6,
  IQ: IQ$6,
  PA: PA$6,
  PF: PF$6,
  PG: PG$6,
  PE: PE$7,
  PK: PK$7,
  PH: PH$7,
  PN: PN$6,
  PL: PL$6,
  PM: PM$6,
  ZM: ZM$6,
  EH: EH$6,
  EE: EE$6,
  EG: EG$6,
  ZA: ZA$6,
  EC: EC$6,
  IT: IT$7,
  VN: VN$7,
  SB: SB$6,
  ET: ET$7,
  SO: SO$6,
  ZW: ZW$6,
  SA: SA$6,
  ES: ES$7,
  ER: ER$6,
  ME: ME$6,
  MD: MD$6,
  MG: MG$6,
  MF: MF$6,
  MA: MA$6,
  MC: MC$6,
  UZ: UZ$6,
  MM: MM$6,
  ML: ML$6,
  MO: MO$6,
  MN: MN$6,
  MH: MH$6,
  MK: MK$6,
  MU: MU$6,
  MT: MT$6,
  MW: MW$6,
  MV: MV$6,
  MQ: MQ$6,
  MP: MP$6,
  MS: MS$6,
  MR: MR$6,
  IM: IM$6,
  UG: UG$6,
  TZ: TZ$6,
  MY: MY$6,
  MX: MX$7,
  IL: IL$6,
  FR: FR$6,
  IO: IO$6,
  SH: SH$6,
  FI: FI$6,
  FJ: FJ$6,
  FK: FK$6,
  FM: FM$6,
  FO: FO$6,
  NI: NI$6,
  NL: NL$7,
  NO: NO$6,
  NA: NA$6,
  VU: VU$6,
  NC: NC$6,
  NE: NE$6,
  NF: NF$6,
  NG: NG$7,
  NZ: NZ$6,
  NP: NP$6,
  NR: NR$6,
  NU: NU$6,
  CK: CK$6,
  XK: XK$5,
  CI: CI$6,
  CH: CH$6,
  CO: CO$6,
  CN: CN$7,
  CM: CM$6,
  CL: CL$7,
  CC: CC$6,
  CA: CA$7,
  CG: CG$6,
  CF: CF$6,
  CD: CD$6,
  CZ: CZ$6,
  CY: CY$6,
  CX: CX$6,
  CR: CR$6,
  CW: CW$5,
  CV: CV$6,
  CU: CU$7,
  SZ: SZ$6,
  SY: SY$6,
  SX: SX$5,
  KG: KG$6,
  KE: KE$6,
  SS: SS$6,
  SR: SR$6,
  KI: KI$6,
  KH: KH$7,
  KN: KN$6,
  KM: KM$6,
  ST: ST$6,
  SK: SK$6,
  KR: KR$6,
  SI: SI$6,
  KP: KP$6,
  KW: KW$6,
  SN: SN$6,
  SM: SM$6,
  SL: SL$6,
  SC: SC$6,
  KZ: KZ$6,
  KY: KY$6,
  SG: SG$6,
  SE: SE$6,
  SD: SD$6,
  DO: DO$6,
  DM: DM$6,
  DJ: DJ$6,
  DK: DK$7,
  VG: VG$6,
  DE: DE$7,
  YE: YE$6,
  DZ: DZ$6,
  US: US$7,
  UY: UY$6,
  YT: YT$6,
  UM: UM$6,
  LB: LB$6,
  LC: LC$6,
  LA: LA$6,
  TV: TV$6,
  TW: TW$6,
  TT: TT$6,
  TR: TR$7,
  LK: LK$6,
  LI: LI$6,
  LV: LV$6,
  TO: TO$6,
  LT: LT$6,
  LU: LU$6,
  LR: LR$6,
  LS: LS$6,
  TH: TH$6,
  TF: TF$6,
  TG: TG$6,
  TD: TD$6,
  TC: TC$6,
  LY: LY$6,
  VA: VA$6,
  VC: VC$6,
  AE: AE$6,
  AD: AD$6,
  AG: AG$6,
  AF: AF$6,
  AI: AI$6,
  VI: VI$6,
  IS: IS$6,
  IR: IR$6,
  AM: AM$6,
  AL: AL$6,
  AO: AO$6,
  AQ: AQ$6,
  AS: AS$6,
  AR: AR$7,
  AU: AU$7,
  AT: AT$7,
  AW: AW$6,
  IN: IN$7,
  AX: AX$6,
  AZ: AZ$6,
  IE: IE$6,
  ID: ID$7,
  UA: UA$6,
  QA: QA$6,
  MZ: MZ$6,
};
const BD$6 = 'Dhaka';
const BE$6 = 'Brussels';
const BF$5 = 'Ouagadougou';
const BG$5 = 'Sofia';
const BA$5 = 'Sarajevo';
const BB$5 = 'Bridgetown';
const WF$5 = 'Mata Utu';
const BL$5 = 'Gustavia';
const BM$5 = 'Hamilton';
const BN$5 = 'Bandar Seri Begawan';
const BO$6 = 'Sucre';
const BH$5 = 'Manama';
const BI$5 = 'Bujumbura';
const BJ$5 = 'Porto-Novo';
const BT$5 = 'Thimphu';
const JM$5 = 'Kingston';
const BV$5 = '';
const BW$5 = 'Gaborone';
const WS$5 = 'Apia';
const BQ$4 = '';
const BR$6 = 'Brasilia';
const BS$5 = 'Nassau';
const JE$5 = 'Saint Helier';
const BY$5 = 'Minsk';
const BZ$5 = 'Belmopan';
const RU$5 = 'Moscow';
const RW$5 = 'Kigali';
const RS$5 = 'Belgrade';
const TL$5 = 'Dili';
const RE$5 = 'Saint-Denis';
const TM$5 = 'Ashgabat';
const TJ$5 = 'Dushanbe';
const RO$5 = 'Bucharest';
const TK$5 = '';
const GW$5 = 'Bissau';
const GU$5 = 'Hagatna';
const GT$5 = 'Guatemala City';
const GS$5 = 'Grytviken';
const GR$5 = 'Athens';
const GQ$5 = 'Malabo';
const GP$5 = 'Basse-Terre';
const JP$6 = 'Tokyo';
const GY$5 = 'Georgetown';
const GG$5 = 'St Peter Port';
const GF$5 = 'Cayenne';
const GE$5 = 'Tbilisi';
const GD$5 = "St. George's";
const GB$6 = 'London';
const GA$5 = 'Libreville';
const SV$5 = 'San Salvador';
const GN$5 = 'Conakry';
const GM$5 = 'Banjul';
const GL$5 = 'Nuuk';
const GI$5 = 'Gibraltar';
const GH$5 = 'Accra';
const OM$5 = 'Muscat';
const TN$5 = 'Tunis';
const JO$6 = 'Amman';
const HR$5 = 'Zagreb';
const HT$5 = 'Port-au-Prince';
const HU$5 = 'Budapest';
const HK$5 = 'Hong Kong';
const HN$5 = 'Tegucigalpa';
const HM$5 = '';
const VE$5 = 'Caracas';
const PR$5 = 'San Juan';
const PS$5 = 'East Jerusalem';
const PW$5 = 'Melekeok';
const PT$5 = 'Lisbon';
const SJ$5 = 'Longyearbyen';
const PY$5 = 'Asuncion';
const IQ$5 = 'Baghdad';
const PA$5 = 'Panama City';
const PF$5 = 'Papeete';
const PG$5 = 'Port Moresby';
const PE$6 = 'Lima';
const PK$6 = 'Islamabad';
const PH$6 = 'Manila';
const PN$5 = 'Adamstown';
const PL$5 = 'Warsaw';
const PM$5 = 'Saint-Pierre';
const ZM$5 = 'Lusaka';
const EH$5 = 'El-Aaiun';
const EE$5 = 'Tallinn';
const EG$5 = 'Cairo';
const ZA$5 = 'Pretoria';
const EC$5 = 'Quito';
const IT$6 = 'Rome';
const VN$6 = 'Hanoi';
const SB$5 = 'Honiara';
const ET$6 = 'Addis Ababa';
const SO$5 = 'Mogadishu';
const ZW$5 = 'Harare';
const SA$5 = 'Riyadh';
const ES$6 = 'Madrid';
const ER$5 = 'Asmara';
const ME$5 = 'Podgorica';
const MD$5 = 'Chisinau';
const MG$5 = 'Antananarivo';
const MF$5 = 'Marigot';
const MA$5 = 'Rabat';
const MC$5 = 'Monaco';
const UZ$5 = 'Tashkent';
const MM$5 = 'Nay Pyi Taw';
const ML$5 = 'Bamako';
const MO$5 = 'Macao';
const MN$5 = 'Ulan Bator';
const MH$5 = 'Majuro';
const MK$5 = 'Skopje';
const MU$5 = 'Port Louis';
const MT$5 = 'Valletta';
const MW$5 = 'Lilongwe';
const MV$5 = 'Male';
const MQ$5 = 'Fort-de-France';
const MP$5 = 'Saipan';
const MS$5 = 'Plymouth';
const MR$5 = 'Nouakchott';
const IM$5 = 'Douglas, Isle of Man';
const UG$5 = 'Kampala';
const TZ$5 = 'Dodoma';
const MY$5 = 'Kuala Lumpur';
const MX$6 = 'Mexico City';
const IL$5 = 'Jerusalem';
const FR$5 = 'Paris';
const IO$5 = 'Diego Garcia';
const SH$5 = 'Jamestown';
const FI$5 = 'Helsinki';
const FJ$5 = 'Suva';
const FK$5 = 'Stanley';
const FM$5 = 'Palikir';
const FO$5 = 'Torshavn';
const NI$5 = 'Managua';
const NL$6 = 'Amsterdam';
const NO$5 = 'Oslo';
const NA$5 = 'Windhoek';
const VU$5 = 'Port Vila';
const NC$5 = 'Noumea';
const NE$5 = 'Niamey';
const NF$5 = 'Kingston';
const NG$6 = 'Abuja';
const NZ$5 = 'Wellington';
const NP$5 = 'Kathmandu';
const NR$5 = 'Yaren';
const NU$5 = 'Alofi';
const CK$5 = 'Avarua';
const XK$4 = 'Pristina';
const CI$5 = 'Yamoussoukro';
const CH$5 = 'Berne';
const CO$5 = 'Bogota';
const CN$6 = 'Beijing';
const CM$5 = 'Yaounde';
const CL$6 = 'Santiago';
const CC$5 = 'West Island';
const CA$6 = 'Ottawa';
const CG$5 = 'Brazzaville';
const CF$5 = 'Bangui';
const CD$5 = 'Kinshasa';
const CZ$5 = 'Prague';
const CY$5 = 'Nicosia';
const CX$5 = 'Flying Fish Cove';
const CR$5 = 'San Jose';
const CW$4 = ' Willemstad';
const CV$5 = 'Praia';
const CU$6 = 'Havana';
const SZ$5 = 'Mbabane';
const SY$5 = 'Damascus';
const SX$4 = 'Philipsburg';
const KG$5 = 'Bishkek';
const KE$5 = 'Nairobi';
const SS$5 = 'Juba';
const SR$5 = 'Paramaribo';
const KI$5 = 'Tarawa';
const KH$6 = 'Phnom Penh';
const KN$5 = 'Basseterre';
const KM$5 = 'Moroni';
const ST$5 = 'Sao Tome';
const SK$5 = 'Bratislava';
const KR$5 = 'Seoul';
const SI$5 = 'Ljubljana';
const KP$5 = 'Pyongyang';
const KW$5 = 'Kuwait City';
const SN$5 = 'Dakar';
const SM$5 = 'San Marino';
const SL$5 = 'Freetown';
const SC$5 = 'Victoria';
const KZ$5 = 'Astana';
const KY$5 = 'George Town';
const SG$5 = 'Singapur';
const SE$5 = 'Stockholm';
const SD$5 = 'Khartoum';
const DO$5 = 'Santo Domingo';
const DM$5 = 'Roseau';
const DJ$5 = 'Djibouti';
const DK$6 = 'Copenhagen';
const VG$5 = 'Road Town';
const DE$6 = 'Berlin';
const YE$5 = 'Sanaa';
const DZ$5 = 'Algiers';
const US$6 = 'Washington';
const UY$5 = 'Montevideo';
const YT$5 = 'Mamoudzou';
const UM$5 = '';
const LB$5 = 'Beirut';
const LC$5 = 'Castries';
const LA$5 = 'Vientiane';
const TV$5 = 'Funafuti';
const TW$5 = 'Taipei';
const TT$5 = 'Port of Spain';
const TR$6 = 'Ankara';
const LK$5 = 'Colombo';
const LI$5 = 'Vaduz';
const LV$5 = 'Riga';
const TO$5 = "Nuku'alofa";
const LT$5 = 'Vilnius';
const LU$5 = 'Luxembourg';
const LR$5 = 'Monrovia';
const LS$5 = 'Maseru';
const TH$5 = 'Bangkok';
const TF$5 = 'Port-aux-Francais';
const TG$5 = 'Lome';
const TD$5 = "N'Djamena";
const TC$5 = 'Cockburn Town';
const LY$5 = 'Tripolis';
const VA$5 = 'Vatican City';
const VC$5 = 'Kingstown';
const AE$5 = 'Abu Dhabi';
const AD$5 = 'Andorra la Vella';
const AG$5 = "St. John's";
const AF$5 = 'Kabul';
const AI$5 = 'The Valley';
const VI$5 = 'Charlotte Amalie';
const IS$5 = 'Reykjavik';
const IR$5 = 'Tehran';
const AM$5 = 'Yerevan';
const AL$5 = 'Tirana';
const AO$5 = 'Luanda';
const AQ$5 = '';
const AS$5 = 'Pago Pago';
const AR$6 = 'Buenos Aires';
const AU$6 = 'Canberra';
const AT$6 = 'Vienna';
const AW$5 = 'Oranjestad';
const IN$6 = 'New Delhi';
const AX$5 = 'Mariehamn';
const AZ$5 = 'Baku';
const IE$5 = 'Dublin';
const ID$6 = 'Jakarta';
const UA$5 = 'Kiev';
const QA$5 = 'Doha';
const MZ$5 = 'Maputo';
const require$$3$1 = {
  BD: BD$6,
  BE: BE$6,
  BF: BF$5,
  BG: BG$5,
  BA: BA$5,
  BB: BB$5,
  WF: WF$5,
  BL: BL$5,
  BM: BM$5,
  BN: BN$5,
  BO: BO$6,
  BH: BH$5,
  BI: BI$5,
  BJ: BJ$5,
  BT: BT$5,
  JM: JM$5,
  BV: BV$5,
  BW: BW$5,
  WS: WS$5,
  BQ: BQ$4,
  BR: BR$6,
  BS: BS$5,
  JE: JE$5,
  BY: BY$5,
  BZ: BZ$5,
  RU: RU$5,
  RW: RW$5,
  RS: RS$5,
  TL: TL$5,
  RE: RE$5,
  TM: TM$5,
  TJ: TJ$5,
  RO: RO$5,
  TK: TK$5,
  GW: GW$5,
  GU: GU$5,
  GT: GT$5,
  GS: GS$5,
  GR: GR$5,
  GQ: GQ$5,
  GP: GP$5,
  JP: JP$6,
  GY: GY$5,
  GG: GG$5,
  GF: GF$5,
  GE: GE$5,
  GD: GD$5,
  GB: GB$6,
  GA: GA$5,
  SV: SV$5,
  GN: GN$5,
  GM: GM$5,
  GL: GL$5,
  GI: GI$5,
  GH: GH$5,
  OM: OM$5,
  TN: TN$5,
  JO: JO$6,
  HR: HR$5,
  HT: HT$5,
  HU: HU$5,
  HK: HK$5,
  HN: HN$5,
  HM: HM$5,
  VE: VE$5,
  PR: PR$5,
  PS: PS$5,
  PW: PW$5,
  PT: PT$5,
  SJ: SJ$5,
  PY: PY$5,
  IQ: IQ$5,
  PA: PA$5,
  PF: PF$5,
  PG: PG$5,
  PE: PE$6,
  PK: PK$6,
  PH: PH$6,
  PN: PN$5,
  PL: PL$5,
  PM: PM$5,
  ZM: ZM$5,
  EH: EH$5,
  EE: EE$5,
  EG: EG$5,
  ZA: ZA$5,
  EC: EC$5,
  IT: IT$6,
  VN: VN$6,
  SB: SB$5,
  ET: ET$6,
  SO: SO$5,
  ZW: ZW$5,
  SA: SA$5,
  ES: ES$6,
  ER: ER$5,
  ME: ME$5,
  MD: MD$5,
  MG: MG$5,
  MF: MF$5,
  MA: MA$5,
  MC: MC$5,
  UZ: UZ$5,
  MM: MM$5,
  ML: ML$5,
  MO: MO$5,
  MN: MN$5,
  MH: MH$5,
  MK: MK$5,
  MU: MU$5,
  MT: MT$5,
  MW: MW$5,
  MV: MV$5,
  MQ: MQ$5,
  MP: MP$5,
  MS: MS$5,
  MR: MR$5,
  IM: IM$5,
  UG: UG$5,
  TZ: TZ$5,
  MY: MY$5,
  MX: MX$6,
  IL: IL$5,
  FR: FR$5,
  IO: IO$5,
  SH: SH$5,
  FI: FI$5,
  FJ: FJ$5,
  FK: FK$5,
  FM: FM$5,
  FO: FO$5,
  NI: NI$5,
  NL: NL$6,
  NO: NO$5,
  NA: NA$5,
  VU: VU$5,
  NC: NC$5,
  NE: NE$5,
  NF: NF$5,
  NG: NG$6,
  NZ: NZ$5,
  NP: NP$5,
  NR: NR$5,
  NU: NU$5,
  CK: CK$5,
  XK: XK$4,
  CI: CI$5,
  CH: CH$5,
  CO: CO$5,
  CN: CN$6,
  CM: CM$5,
  CL: CL$6,
  CC: CC$5,
  CA: CA$6,
  CG: CG$5,
  CF: CF$5,
  CD: CD$5,
  CZ: CZ$5,
  CY: CY$5,
  CX: CX$5,
  CR: CR$5,
  CW: CW$4,
  CV: CV$5,
  CU: CU$6,
  SZ: SZ$5,
  SY: SY$5,
  SX: SX$4,
  KG: KG$5,
  KE: KE$5,
  SS: SS$5,
  SR: SR$5,
  KI: KI$5,
  KH: KH$6,
  KN: KN$5,
  KM: KM$5,
  ST: ST$5,
  SK: SK$5,
  KR: KR$5,
  SI: SI$5,
  KP: KP$5,
  KW: KW$5,
  SN: SN$5,
  SM: SM$5,
  SL: SL$5,
  SC: SC$5,
  KZ: KZ$5,
  KY: KY$5,
  SG: SG$5,
  SE: SE$5,
  SD: SD$5,
  DO: DO$5,
  DM: DM$5,
  DJ: DJ$5,
  DK: DK$6,
  VG: VG$5,
  DE: DE$6,
  YE: YE$5,
  DZ: DZ$5,
  US: US$6,
  UY: UY$5,
  YT: YT$5,
  UM: UM$5,
  LB: LB$5,
  LC: LC$5,
  LA: LA$5,
  TV: TV$5,
  TW: TW$5,
  TT: TT$5,
  TR: TR$6,
  LK: LK$5,
  LI: LI$5,
  LV: LV$5,
  TO: TO$5,
  LT: LT$5,
  LU: LU$5,
  LR: LR$5,
  LS: LS$5,
  TH: TH$5,
  TF: TF$5,
  TG: TG$5,
  TD: TD$5,
  TC: TC$5,
  LY: LY$5,
  VA: VA$5,
  VC: VC$5,
  AE: AE$5,
  AD: AD$5,
  AG: AG$5,
  AF: AF$5,
  AI: AI$5,
  VI: VI$5,
  IS: IS$5,
  IR: IR$5,
  AM: AM$5,
  AL: AL$5,
  AO: AO$5,
  AQ: AQ$5,
  AS: AS$5,
  AR: AR$6,
  AU: AU$6,
  AT: AT$6,
  AW: AW$5,
  IN: IN$6,
  AX: AX$5,
  AZ: AZ$5,
  IE: IE$5,
  ID: ID$6,
  UA: UA$5,
  QA: QA$5,
  MZ: MZ$5,
};
const BD$5 = 'BDT';
const BE$5 = 'EUR';
const BF$4 = 'XOF';
const BG$4 = 'BGN';
const BA$4 = 'BAM';
const BB$4 = 'BBD';
const WF$4 = 'XPF';
const BL$4 = 'EUR';
const BM$4 = 'BMD';
const BN$4 = 'BND';
const BO$5 = 'BOB';
const BH$4 = 'BHD';
const BI$4 = 'BIF';
const BJ$4 = 'XOF';
const BT$4 = 'BTN';
const JM$4 = 'JMD';
const BV$4 = 'NOK';
const BW$4 = 'BWP';
const WS$4 = 'WST';
const BQ$3 = 'USD';
const BR$5 = 'BRL';
const BS$4 = 'BSD';
const JE$4 = 'GBP';
const BY$4 = 'BYR';
const BZ$4 = 'BZD';
const RU$4 = 'RUB';
const RW$4 = 'RWF';
const RS$4 = 'RSD';
const TL$4 = 'USD';
const RE$4 = 'EUR';
const TM$4 = 'TMT';
const TJ$4 = 'TJS';
const RO$4 = 'RON';
const TK$4 = 'NZD';
const GW$4 = 'XOF';
const GU$4 = 'USD';
const GT$4 = 'GTQ';
const GS$4 = 'GBP';
const GR$4 = 'EUR';
const GQ$4 = 'XAF';
const GP$4 = 'EUR';
const JP$5 = 'JPY';
const GY$4 = 'GYD';
const GG$4 = 'GBP';
const GF$4 = 'EUR';
const GE$4 = 'GEL';
const GD$4 = 'XCD';
const GB$5 = 'GBP';
const GA$4 = 'XAF';
const SV$4 = 'USD';
const GN$4 = 'GNF';
const GM$4 = 'GMD';
const GL$4 = 'DKK';
const GI$4 = 'GIP';
const GH$4 = 'GHS';
const OM$4 = 'OMR';
const TN$4 = 'TND';
const JO$5 = 'JOD';
const HR$4 = 'HRK';
const HT$4 = 'HTG';
const HU$4 = 'HUF';
const HK$4 = 'HKD';
const HN$4 = 'HNL';
const HM$4 = 'AUD';
const VE$4 = 'VEF';
const PR$4 = 'USD';
const PS$4 = 'ILS';
const PW$4 = 'USD';
const PT$4 = 'EUR';
const SJ$4 = 'NOK';
const PY$4 = 'PYG';
const IQ$4 = 'IQD';
const PA$4 = 'PAB';
const PF$4 = 'XPF';
const PG$4 = 'PGK';
const PE$5 = 'PEN';
const PK$5 = 'PKR';
const PH$5 = 'PHP';
const PN$4 = 'NZD';
const PL$4 = 'PLN';
const PM$4 = 'EUR';
const ZM$4 = 'ZMK';
const EH$4 = 'MAD';
const EE$4 = 'EUR';
const EG$4 = 'EGP';
const ZA$4 = 'ZAR';
const EC$4 = 'USD';
const IT$5 = 'EUR';
const VN$5 = 'VND';
const SB$4 = 'SBD';
const ET$5 = 'ETB';
const SO$4 = 'SOS';
const ZW$4 = 'ZWL';
const SA$4 = 'SAR';
const ES$5 = 'EUR';
const ER$4 = 'ERN';
const ME$4 = 'EUR';
const MD$4 = 'MDL';
const MG$4 = 'MGA';
const MF$4 = 'EUR';
const MA$4 = 'MAD';
const MC$4 = 'EUR';
const UZ$4 = 'UZS';
const MM$4 = 'MMK';
const ML$4 = 'XOF';
const MO$4 = 'MOP';
const MN$4 = 'MNT';
const MH$4 = 'USD';
const MK$4 = 'MKD';
const MU$4 = 'MUR';
const MT$4 = 'EUR';
const MW$4 = 'MWK';
const MV$4 = 'MVR';
const MQ$4 = 'EUR';
const MP$4 = 'USD';
const MS$4 = 'XCD';
const MR$4 = 'MRO';
const IM$4 = 'GBP';
const UG$4 = 'UGX';
const TZ$4 = 'TZS';
const MY$4 = 'MYR';
const MX$5 = 'MXN';
const IL$4 = 'ILS';
const FR$4 = 'EUR';
const IO$4 = 'USD';
const SH$4 = 'SHP';
const FI$4 = 'EUR';
const FJ$4 = 'FJD';
const FK$4 = 'FKP';
const FM$4 = 'USD';
const FO$4 = 'DKK';
const NI$4 = 'NIO';
const NL$5 = 'EUR';
const NO$4 = 'NOK';
const NA$4 = 'NAD';
const VU$4 = 'VUV';
const NC$4 = 'XPF';
const NE$4 = 'XOF';
const NF$4 = 'AUD';
const NG$5 = 'NGN';
const NZ$4 = 'NZD';
const NP$4 = 'NPR';
const NR$4 = 'AUD';
const NU$4 = 'NZD';
const CK$4 = 'NZD';
const XK$3 = 'EUR';
const CI$4 = 'XOF';
const CH$4 = 'CHF';
const CO$4 = 'COP';
const CN$5 = 'CNY';
const CM$4 = 'XAF';
const CL$5 = 'CLP';
const CC$4 = 'AUD';
const CA$5 = 'CAD';
const CG$4 = 'XAF';
const CF$4 = 'XAF';
const CD$4 = 'CDF';
const CZ$4 = 'CZK';
const CY$4 = 'EUR';
const CX$4 = 'AUD';
const CR$4 = 'CRC';
const CW$3 = 'ANG';
const CV$4 = 'CVE';
const CU$5 = 'CUP';
const SZ$4 = 'SZL';
const SY$4 = 'SYP';
const SX$3 = 'ANG';
const KG$4 = 'KGS';
const KE$4 = 'KES';
const SS$4 = 'SSP';
const SR$4 = 'SRD';
const KI$4 = 'AUD';
const KH$5 = 'KHR';
const KN$4 = 'XCD';
const KM$4 = 'KMF';
const ST$4 = 'STD';
const SK$4 = 'EUR';
const KR$4 = 'KRW';
const SI$4 = 'EUR';
const KP$4 = 'KPW';
const KW$4 = 'KWD';
const SN$4 = 'XOF';
const SM$4 = 'EUR';
const SL$4 = 'SLL';
const SC$4 = 'SCR';
const KZ$4 = 'KZT';
const KY$4 = 'KYD';
const SG$4 = 'SGD';
const SE$4 = 'SEK';
const SD$4 = 'SDG';
const DO$4 = 'DOP';
const DM$4 = 'XCD';
const DJ$4 = 'DJF';
const DK$5 = 'DKK';
const VG$4 = 'USD';
const DE$5 = 'EUR';
const YE$4 = 'YER';
const DZ$4 = 'DZD';
const US$5 = 'USD';
const UY$4 = 'UYU';
const YT$4 = 'EUR';
const UM$4 = 'USD';
const LB$4 = 'LBP';
const LC$4 = 'XCD';
const LA$4 = 'LAK';
const TV$4 = 'AUD';
const TW$4 = 'TWD';
const TT$4 = 'TTD';
const TR$5 = 'TRY';
const LK$4 = 'LKR';
const LI$4 = 'CHF';
const LV$4 = 'EUR';
const TO$4 = 'TOP';
const LT$4 = 'LTL';
const LU$4 = 'EUR';
const LR$4 = 'LRD';
const LS$4 = 'LSL';
const TH$4 = 'THB';
const TF$4 = 'EUR';
const TG$4 = 'XOF';
const TD$4 = 'XAF';
const TC$4 = 'USD';
const LY$4 = 'LYD';
const VA$4 = 'EUR';
const VC$4 = 'XCD';
const AE$4 = 'AED';
const AD$4 = 'EUR';
const AG$4 = 'XCD';
const AF$4 = 'AFN';
const AI$4 = 'XCD';
const VI$4 = 'USD';
const IS$4 = 'ISK';
const IR$4 = 'IRR';
const AM$4 = 'AMD';
const AL$4 = 'ALL';
const AO$4 = 'AOA';
const AQ$4 = 'XCD';
const AS$4 = 'USD';
const AR$5 = 'ARS';
const AU$5 = 'AUD';
const AT$5 = 'EUR';
const AW$4 = 'AWG';
const IN$5 = 'INR';
const AX$4 = 'EUR';
const AZ$4 = 'AZN';
const IE$4 = 'EUR';
const ID$5 = 'IDR';
const UA$4 = 'UAH';
const QA$4 = 'QAR';
const MZ$4 = 'MZN';
const require$$4$1 = {
  BD: BD$5,
  BE: BE$5,
  BF: BF$4,
  BG: BG$4,
  BA: BA$4,
  BB: BB$4,
  WF: WF$4,
  BL: BL$4,
  BM: BM$4,
  BN: BN$4,
  BO: BO$5,
  BH: BH$4,
  BI: BI$4,
  BJ: BJ$4,
  BT: BT$4,
  JM: JM$4,
  BV: BV$4,
  BW: BW$4,
  WS: WS$4,
  BQ: BQ$3,
  BR: BR$5,
  BS: BS$4,
  JE: JE$4,
  BY: BY$4,
  BZ: BZ$4,
  RU: RU$4,
  RW: RW$4,
  RS: RS$4,
  TL: TL$4,
  RE: RE$4,
  TM: TM$4,
  TJ: TJ$4,
  RO: RO$4,
  TK: TK$4,
  GW: GW$4,
  GU: GU$4,
  GT: GT$4,
  GS: GS$4,
  GR: GR$4,
  GQ: GQ$4,
  GP: GP$4,
  JP: JP$5,
  GY: GY$4,
  GG: GG$4,
  GF: GF$4,
  GE: GE$4,
  GD: GD$4,
  GB: GB$5,
  GA: GA$4,
  SV: SV$4,
  GN: GN$4,
  GM: GM$4,
  GL: GL$4,
  GI: GI$4,
  GH: GH$4,
  OM: OM$4,
  TN: TN$4,
  JO: JO$5,
  HR: HR$4,
  HT: HT$4,
  HU: HU$4,
  HK: HK$4,
  HN: HN$4,
  HM: HM$4,
  VE: VE$4,
  PR: PR$4,
  PS: PS$4,
  PW: PW$4,
  PT: PT$4,
  SJ: SJ$4,
  PY: PY$4,
  IQ: IQ$4,
  PA: PA$4,
  PF: PF$4,
  PG: PG$4,
  PE: PE$5,
  PK: PK$5,
  PH: PH$5,
  PN: PN$4,
  PL: PL$4,
  PM: PM$4,
  ZM: ZM$4,
  EH: EH$4,
  EE: EE$4,
  EG: EG$4,
  ZA: ZA$4,
  EC: EC$4,
  IT: IT$5,
  VN: VN$5,
  SB: SB$4,
  ET: ET$5,
  SO: SO$4,
  ZW: ZW$4,
  SA: SA$4,
  ES: ES$5,
  ER: ER$4,
  ME: ME$4,
  MD: MD$4,
  MG: MG$4,
  MF: MF$4,
  MA: MA$4,
  MC: MC$4,
  UZ: UZ$4,
  MM: MM$4,
  ML: ML$4,
  MO: MO$4,
  MN: MN$4,
  MH: MH$4,
  MK: MK$4,
  MU: MU$4,
  MT: MT$4,
  MW: MW$4,
  MV: MV$4,
  MQ: MQ$4,
  MP: MP$4,
  MS: MS$4,
  MR: MR$4,
  IM: IM$4,
  UG: UG$4,
  TZ: TZ$4,
  MY: MY$4,
  MX: MX$5,
  IL: IL$4,
  FR: FR$4,
  IO: IO$4,
  SH: SH$4,
  FI: FI$4,
  FJ: FJ$4,
  FK: FK$4,
  FM: FM$4,
  FO: FO$4,
  NI: NI$4,
  NL: NL$5,
  NO: NO$4,
  NA: NA$4,
  VU: VU$4,
  NC: NC$4,
  NE: NE$4,
  NF: NF$4,
  NG: NG$5,
  NZ: NZ$4,
  NP: NP$4,
  NR: NR$4,
  NU: NU$4,
  CK: CK$4,
  XK: XK$3,
  CI: CI$4,
  CH: CH$4,
  CO: CO$4,
  CN: CN$5,
  CM: CM$4,
  CL: CL$5,
  CC: CC$4,
  CA: CA$5,
  CG: CG$4,
  CF: CF$4,
  CD: CD$4,
  CZ: CZ$4,
  CY: CY$4,
  CX: CX$4,
  CR: CR$4,
  CW: CW$3,
  CV: CV$4,
  CU: CU$5,
  SZ: SZ$4,
  SY: SY$4,
  SX: SX$3,
  KG: KG$4,
  KE: KE$4,
  SS: SS$4,
  SR: SR$4,
  KI: KI$4,
  KH: KH$5,
  KN: KN$4,
  KM: KM$4,
  ST: ST$4,
  SK: SK$4,
  KR: KR$4,
  SI: SI$4,
  KP: KP$4,
  KW: KW$4,
  SN: SN$4,
  SM: SM$4,
  SL: SL$4,
  SC: SC$4,
  KZ: KZ$4,
  KY: KY$4,
  SG: SG$4,
  SE: SE$4,
  SD: SD$4,
  DO: DO$4,
  DM: DM$4,
  DJ: DJ$4,
  DK: DK$5,
  VG: VG$4,
  DE: DE$5,
  YE: YE$4,
  DZ: DZ$4,
  US: US$5,
  UY: UY$4,
  YT: YT$4,
  UM: UM$4,
  LB: LB$4,
  LC: LC$4,
  LA: LA$4,
  TV: TV$4,
  TW: TW$4,
  TT: TT$4,
  TR: TR$5,
  LK: LK$4,
  LI: LI$4,
  LV: LV$4,
  TO: TO$4,
  LT: LT$4,
  LU: LU$4,
  LR: LR$4,
  LS: LS$4,
  TH: TH$4,
  TF: TF$4,
  TG: TG$4,
  TD: TD$4,
  TC: TC$4,
  LY: LY$4,
  VA: VA$4,
  VC: VC$4,
  AE: AE$4,
  AD: AD$4,
  AG: AG$4,
  AF: AF$4,
  AI: AI$4,
  VI: VI$4,
  IS: IS$4,
  IR: IR$4,
  AM: AM$4,
  AL: AL$4,
  AO: AO$4,
  AQ: AQ$4,
  AS: AS$4,
  AR: AR$5,
  AU: AU$5,
  AT: AT$5,
  AW: AW$4,
  IN: IN$5,
  AX: AX$4,
  AZ: AZ$4,
  IE: IE$4,
  ID: ID$5,
  UA: UA$4,
  QA: QA$4,
  MZ: MZ$4,
};
const USD = {
  symbol: '$',
  decimal: '2',
};
const CAD = {
  symbol: 'CA$',
  decimal: '2',
};
const EUR = {
  symbol: '€',
  decimal: '2',
};
const AED = {
  symbol: 'AED',
  decimal: '2',
};
const AFN = {
  symbol: 'Af',
  decimal: '0',
};
const ALL = {
  symbol: 'ALL',
  decimal: '0',
};
const AMD = {
  symbol: 'AMD',
  decimal: '0',
};
const ARS = {
  symbol: 'AR$',
  decimal: '2',
};
const AUD = {
  symbol: 'AU$',
  decimal: '2',
};
const AZN = {
  symbol: 'man.',
  decimal: '2',
};
const BAM = {
  symbol: 'KM',
  decimal: '2',
};
const BDT = {
  symbol: 'Tk',
  decimal: '2',
};
const BGN = {
  symbol: 'BGN',
  decimal: '2',
};
const BHD = {
  symbol: 'BD',
  decimal: '3',
};
const BIF = {
  symbol: 'FBu',
  decimal: '0',
};
const BND = {
  symbol: 'BN$',
  decimal: '2',
};
const BOB = {
  symbol: 'Bs',
  decimal: '2',
};
const BRL = {
  symbol: 'R$',
  decimal: '2',
};
const BWP = {
  symbol: 'BWP',
  decimal: '2',
};
const BYR = {
  symbol: 'BYR',
  decimal: '0',
};
const BZD = {
  symbol: 'BZ$',
  decimal: '2',
};
const CDF = {
  symbol: 'CDF',
  decimal: '2',
};
const CHF = {
  symbol: 'CHF',
  decimal: '2',
};
const CLP = {
  symbol: 'CL$',
  decimal: '0',
};
const CNY = {
  symbol: 'CN¥',
  decimal: '2',
};
const COP = {
  symbol: 'CO$',
  decimal: '0',
};
const CRC = {
  symbol: '₡',
  decimal: '0',
};
const CVE = {
  symbol: 'CV$',
  decimal: '2',
};
const CZK = {
  symbol: 'Kč',
  decimal: '2',
};
const DJF = {
  symbol: 'Fdj',
  decimal: '0',
};
const DKK = {
  symbol: 'Dkr',
  decimal: '2',
};
const DOP = {
  symbol: 'RD$',
  decimal: '2',
};
const DZD = {
  symbol: 'DA',
  decimal: '2',
};
const EEK = {
  symbol: 'Ekr',
  decimal: '2',
};
const EGP = {
  symbol: 'EGP',
  decimal: '2',
};
const ERN = {
  symbol: 'Nfk',
  decimal: '2',
};
const ETB = {
  symbol: 'Br',
  decimal: '2',
};
const GBP = {
  symbol: '£',
  decimal: '2',
};
const GEL = {
  symbol: 'GEL',
  decimal: '2',
};
const GHS = {
  symbol: 'GH₵',
  decimal: '2',
};
const GNF = {
  symbol: 'FG',
  decimal: '0',
};
const GTQ = {
  symbol: 'GTQ',
  decimal: '2',
};
const HKD = {
  symbol: 'HK$',
  decimal: '2',
};
const HNL = {
  symbol: 'HNL',
  decimal: '2',
};
const HRK = {
  symbol: 'kn',
  decimal: '2',
};
const HUF = {
  symbol: 'Ft',
  decimal: '0',
};
const IDR = {
  symbol: 'Rp',
  decimal: '0',
};
const ILS = {
  symbol: '₪',
  decimal: '2',
};
const INR = {
  symbol: 'Rs',
  decimal: '2',
};
const IQD = {
  symbol: 'IQD',
  decimal: '0',
};
const IRR = {
  symbol: 'IRR',
  decimal: '0',
};
const ISK = {
  symbol: 'Ikr',
  decimal: '0',
};
const JMD = {
  symbol: 'J$',
  decimal: '2',
};
const JOD = {
  symbol: 'JD',
  decimal: '3',
};
const JPY = {
  symbol: '¥',
  decimal: '0',
};
const KES = {
  symbol: 'Ksh',
  decimal: '2',
};
const KHR = {
  symbol: 'KHR',
  decimal: '2',
};
const KMF = {
  symbol: 'CF',
  decimal: '0',
};
const KRW = {
  symbol: '₩',
  decimal: '0',
};
const KWD = {
  symbol: 'KD',
  decimal: '3',
};
const KZT = {
  symbol: 'KZT',
  decimal: '2',
};
const LBP = {
  symbol: 'LB£',
  decimal: '0',
};
const LKR = {
  symbol: 'SLRs',
  decimal: '2',
};
const LTL = {
  symbol: 'Lt',
  decimal: '2',
};
const LVL = {
  symbol: 'Ls',
  decimal: '2',
};
const LYD = {
  symbol: 'LD',
  decimal: '3',
};
const MAD = {
  symbol: 'MAD',
  decimal: '2',
};
const MDL = {
  symbol: 'MDL',
  decimal: '2',
};
const MGA = {
  symbol: 'MGA',
  decimal: '0',
};
const MKD$1 = {
  symbol: 'MKD',
  decimal: '2',
};
const MMK = {
  symbol: 'MMK',
  decimal: '0',
};
const MOP = {
  symbol: 'MOP$',
  decimal: '2',
};
const MUR = {
  symbol: 'MURs',
  decimal: '0',
};
const MXN = {
  symbol: 'MX$',
  decimal: '2',
};
const MYR = {
  symbol: 'RM',
  decimal: '2',
};
const MZN = {
  symbol: 'MTn',
  decimal: '2',
};
const NAD = {
  symbol: 'N$',
  decimal: '2',
};
const NGN = {
  symbol: '₦',
  decimal: '2',
};
const NIO = {
  symbol: 'C$',
  decimal: '2',
};
const NOK = {
  symbol: 'Nkr',
  decimal: '2',
};
const NPR = {
  symbol: 'NPRs',
  decimal: '2',
};
const NZD = {
  symbol: 'NZ$',
  decimal: '2',
};
const OMR = {
  symbol: 'OMR',
  decimal: '3',
};
const PAB = {
  symbol: 'B/.',
  decimal: '2',
};
const PEN = {
  symbol: 'S/.',
  decimal: '2',
};
const PHP = {
  symbol: '₱',
  decimal: '2',
};
const PKR = {
  symbol: 'PKRs',
  decimal: '0',
};
const PLN = {
  symbol: 'zł',
  decimal: '2',
};
const PYG = {
  symbol: '₲',
  decimal: '0',
};
const QAR = {
  symbol: 'QR',
  decimal: '2',
};
const RON = {
  symbol: 'RON',
  decimal: '2',
};
const RSD = {
  symbol: 'din.',
  decimal: '0',
};
const RUB = {
  symbol: 'RUB',
  decimal: '2',
};
const RWF = {
  symbol: 'RWF',
  decimal: '0',
};
const SAR = {
  symbol: 'SR',
  decimal: '2',
};
const SDG = {
  symbol: 'SDG',
  decimal: '2',
};
const SEK = {
  symbol: 'Skr',
  decimal: '2',
};
const SGD = {
  symbol: 'S$',
  decimal: '2',
};
const SOS = {
  symbol: 'Ssh',
  decimal: '0',
};
const SYP = {
  symbol: 'SY£',
  decimal: '0',
};
const THB = {
  symbol: '฿',
  decimal: '2',
};
const TND = {
  symbol: 'DT',
  decimal: '3',
};
const TOP = {
  symbol: 'T$',
  decimal: '2',
};
const TRY = {
  symbol: 'TL',
  decimal: '2',
};
const TTD = {
  symbol: 'TT$',
  decimal: '2',
};
const TWD = {
  symbol: 'NT$',
  decimal: '2',
};
const TZS = {
  symbol: 'TSh',
  decimal: '0',
};
const UAH = {
  symbol: '₴',
  decimal: '2',
};
const UGX = {
  symbol: 'USh',
  decimal: '0',
};
const UYU = {
  symbol: '$U',
  decimal: '2',
};
const UZS = {
  symbol: 'UZS',
  decimal: '0',
};
const VEF = {
  symbol: 'Bs.F.',
  decimal: '2',
};
const VND = {
  symbol: '₫',
  decimal: '0',
};
const XAF = {
  symbol: 'FCFA',
  decimal: '0',
};
const XOF = {
  symbol: 'CFA',
  decimal: '0',
};
const YER = {
  symbol: 'YR',
  decimal: '0',
};
const ZAR = {
  symbol: 'R',
  decimal: '2',
};
const ZMK = {
  symbol: 'ZK',
  decimal: '0',
};
const BBD = {
  symbol: 'Bds$',
  decimal: '2',
};
const XPF = {
  symbol: 'F',
  decimal: '0',
};
const BMD = {
  symbol: 'BD$',
  decimal: '2',
};
const BTN$1 = {
  symbol: 'Ch',
  decimal: '2',
};
const WST = {
  symbol: 'WS$',
  decimal: '2',
};
const BSD = {
  symbol: 'BS$',
  decimal: '2',
};
const TMT = {
  symbol: 'm',
  decimal: '2',
};
const TJS = {
  symbol: 'TJS',
  decimal: '2',
};
const GYD = {
  symbol: 'G$',
  decimal: '2',
};
const XCD = {
  symbol: 'EC$',
  decimal: '2',
};
const GMD = {
  symbol: 'D',
  decimal: '2',
};
const GIP = {
  symbol: '£',
  decimal: '2',
};
const HTG = {
  symbol: 'G',
  decimal: '2',
};
const PGK = {
  symbol: 'K',
  decimal: '2',
};
const SBD = {
  symbol: 'SI$',
  decimal: '2',
};
const ZWL = {
  symbol: 'Z$',
  decimal: '2',
};
const MNT = {
  symbol: '₮',
  decimal: '2',
};
const MWK = {
  symbol: 'MK',
  decimal: '2',
};
const MVR = {
  symbol: 'ރ',
  decimal: '2',
};
const MRO = {
  symbol: 'UM',
  decimal: '0',
};
const SHP = {
  symbol: '£',
  decimal: '2',
};
const FJD = {
  symbol: 'FJ$',
  decimal: '2',
};
const FKP = {
  symbol: '£',
  decimal: '2',
};
const VUV = {
  symbol: 'VT',
  decimal: '0',
};
const ANG = {
  symbol: 'ƒ',
  decimal: '2',
};
const CUP = {
  symbol: '$MN',
  decimal: '2',
};
const SZL = {
  symbol: 'L',
  decimal: '0',
};
const KGS = {
  symbol: 'som',
  decimal: '2',
};
const SSP = {
  symbol: '£',
  decimal: '2',
};
const SRD = {
  symbol: '$',
  decimal: '2',
};
const STD = {
  symbol: 'Db',
  decimal: '2',
};
const KPW = {
  symbol: '₩',
  decimal: '2',
};
const SLL = {
  symbol: 'Le',
  decimal: '2',
};
const SCR = {
  symbol: 'SR',
  decimal: '2',
};
const KYD = {
  symbol: 'CI$',
  decimal: '2',
};
const LAK = {
  symbol: '₭',
  decimal: '2',
};
const LRD = {
  symbol: 'L$',
  decimal: '2',
};
const LSL = {
  symbol: 'L',
  decimal: '2',
};
const AOA = {
  symbol: 'Kz',
  decimal: '2',
};
const AWG = {
  symbol: 'Afl.',
  decimal: '2',
};
const require$$5$1 = {
  USD,
  CAD,
  EUR,
  AED,
  AFN,
  ALL,
  AMD,
  ARS,
  AUD,
  AZN,
  BAM,
  BDT,
  BGN,
  BHD,
  BIF,
  BND,
  BOB,
  BRL,
  BWP,
  BYR,
  BZD,
  CDF,
  CHF,
  CLP,
  CNY,
  COP,
  CRC,
  CVE,
  CZK,
  DJF,
  DKK,
  DOP,
  DZD,
  EEK,
  EGP,
  ERN,
  ETB,
  GBP,
  GEL,
  GHS,
  GNF,
  GTQ,
  HKD,
  HNL,
  HRK,
  HUF,
  IDR,
  ILS,
  INR,
  IQD,
  IRR,
  ISK,
  JMD,
  JOD,
  JPY,
  KES,
  KHR,
  KMF,
  KRW,
  KWD,
  KZT,
  LBP,
  LKR,
  LTL,
  LVL,
  LYD,
  MAD,
  MDL,
  MGA,
  MKD: MKD$1,
  MMK,
  MOP,
  MUR,
  MXN,
  MYR,
  MZN,
  NAD,
  NGN,
  NIO,
  NOK,
  NPR,
  NZD,
  OMR,
  PAB,
  PEN,
  PHP,
  PKR,
  PLN,
  PYG,
  QAR,
  RON,
  RSD,
  RUB,
  RWF,
  SAR,
  SDG,
  SEK,
  SGD,
  SOS,
  SYP,
  THB,
  TND,
  TOP,
  TRY,
  TTD,
  TWD,
  TZS,
  UAH,
  UGX,
  UYU,
  UZS,
  VEF,
  VND,
  XAF,
  XOF,
  YER,
  ZAR,
  ZMK,
  BBD,
  XPF,
  BMD,
  BTN: BTN$1,
  WST,
  BSD,
  TMT,
  TJS,
  GYD,
  XCD,
  GMD,
  GIP,
  HTG,
  PGK,
  SBD,
  ZWL,
  MNT,
  MWK,
  MVR,
  MRO,
  SHP,
  FJD,
  FKP,
  VUV,
  ANG,
  CUP,
  SZL,
  KGS,
  SSP,
  SRD,
  STD,
  KPW,
  SLL,
  SCR,
  KYD,
  LAK,
  LRD,
  LSL,
  AOA,
  AWG,
};
const BD$4 = 'Bangladesh';
const BE$4 = 'Belgium';
const BF$3 = 'Burkina Faso';
const BG$3 = 'Bulgaria';
const BA$3 = 'Bosnia and Herzegovina';
const BB$3 = 'Barbados';
const WF$3 = 'Wallis and Futuna';
const BL$3 = 'Saint Barthelemy';
const BM$3 = 'Bermuda';
const BN$3 = 'Brunei';
const BO$4 = 'Bolivia';
const BH$3 = 'Bahrain';
const BI$3 = 'Burundi';
const BJ$3 = 'Benin';
const BT$3 = 'Bhutan';
const JM$3 = 'Jamaica';
const BV$3 = 'Bouvet Island';
const BW$3 = 'Botswana';
const WS$3 = 'Samoa';
const BQ$2 = 'Bonaire, Saint Eustatius and Saba ';
const BR$4 = 'Brazil';
const BS$3 = 'Bahamas';
const JE$3 = 'Jersey';
const BY$3 = 'Belarus';
const BZ$3 = 'Belize';
const RU$3 = 'Russia';
const RW$3 = 'Rwanda';
const RS$3 = 'Serbia';
const TL$3 = 'East Timor';
const RE$3 = 'Reunion';
const TM$3 = 'Turkmenistan';
const TJ$3 = 'Tajikistan';
const RO$3 = 'Romania';
const TK$3 = 'Tokelau';
const GW$3 = 'Guinea-Bissau';
const GU$3 = 'Guam';
const GT$3 = 'Guatemala';
const GS$3 = 'South Georgia and the South Sandwich Islands';
const GR$3 = 'Greece';
const GQ$3 = 'Equatorial Guinea';
const GP$3 = 'Guadeloupe';
const JP$4 = 'Japan';
const GY$3 = 'Guyana';
const GG$3 = 'Guernsey';
const GF$3 = 'French Guiana';
const GE$3 = 'Georgia';
const GD$3 = 'Grenada';
const GB$4 = 'United Kingdom';
const GA$3 = 'Gabon';
const SV$3 = 'El Salvador';
const GN$3 = 'Guinea';
const GM$3 = 'Gambia';
const GL$3 = 'Greenland';
const GI$3 = 'Gibraltar';
const GH$3 = 'Ghana';
const OM$3 = 'Oman';
const TN$3 = 'Tunisia';
const JO$4 = 'Jordan';
const HR$3 = 'Croatia';
const HT$3 = 'Haiti';
const HU$3 = 'Hungary';
const HK$3 = 'Hong Kong';
const HN$3 = 'Honduras';
const HM$3 = 'Heard Island and McDonald Islands';
const VE$3 = 'Venezuela';
const PR$3 = 'Puerto Rico';
const PS$3 = 'Palestinian Territory';
const PW$3 = 'Palau';
const PT$3 = 'Portugal';
const SJ$3 = 'Svalbard and Jan Mayen';
const PY$3 = 'Paraguay';
const IQ$3 = 'Iraq';
const PA$3 = 'Panama';
const PF$3 = 'French Polynesia';
const PG$3 = 'Papua New Guinea';
const PE$4 = 'Peru';
const PK$4 = 'Pakistan';
const PH$4 = 'Philippines';
const PN$3 = 'Pitcairn';
const PL$3 = 'Poland';
const PM$3 = 'Saint Pierre and Miquelon';
const ZM$3 = 'Zambia';
const EH$3 = 'Western Sahara';
const EE$3 = 'Estonia';
const EG$3 = 'Egypt';
const ZA$3 = 'South Africa';
const EC$3 = 'Ecuador';
const IT$4 = 'Italy';
const VN$4 = 'Vietnam';
const SB$3 = 'Solomon Islands';
const ET$4 = 'Ethiopia';
const SO$3 = 'Somalia';
const ZW$3 = 'Zimbabwe';
const SA$3 = 'Saudi Arabia';
const ES$4 = 'Spain';
const ER$3 = 'Eritrea';
const ME$3 = 'Montenegro';
const MD$3 = 'Moldova';
const MG$3 = 'Madagascar';
const MF$3 = 'Saint Martin';
const MA$3 = 'Morocco';
const MC$3 = 'Monaco';
const UZ$3 = 'Uzbekistan';
const MM$3 = 'Myanmar';
const ML$3 = 'Mali';
const MO$3 = 'Macao';
const MN$3 = 'Mongolia';
const MH$3 = 'Marshall Islands';
const MK$3 = 'Macedonia';
const MU$3 = 'Mauritius';
const MT$3 = 'Malta';
const MW$3 = 'Malawi';
const MV$3 = 'Maldives';
const MQ$3 = 'Martinique';
const MP$3 = 'Northern Mariana Islands';
const MS$3 = 'Montserrat';
const MR$3 = 'Mauritania';
const IM$3 = 'Isle of Man';
const UG$3 = 'Uganda';
const TZ$3 = 'Tanzania';
const MY$3 = 'Malaysia';
const MX$4 = 'Mexico';
const IL$3 = 'Israel';
const FR$3 = 'France';
const IO$3 = 'British Indian Ocean Territory';
const SH$3 = 'Saint Helena';
const FI$3 = 'Finland';
const FJ$3 = 'Fiji';
const FK$3 = 'Falkland Islands';
const FM$3 = 'Micronesia';
const FO$3 = 'Faroe Islands';
const NI$3 = 'Nicaragua';
const NL$4 = 'Netherlands';
const NO$3 = 'Norway';
const NA$3 = 'Namibia';
const VU$3 = 'Vanuatu';
const NC$3 = 'New Caledonia';
const NE$3 = 'Niger';
const NF$3 = 'Norfolk Island';
const NG$4 = 'Nigeria';
const NZ$3 = 'New Zealand';
const NP$3 = 'Nepal';
const NR$3 = 'Nauru';
const NU$3 = 'Niue';
const CK$3 = 'Cook Islands';
const XK$2 = 'Kosovo';
const CI$3 = 'Ivory Coast';
const CH$3 = 'Switzerland';
const CO$3 = 'Colombia';
const CN$4 = 'China';
const CM$3 = 'Cameroon';
const CL$4 = 'Chile';
const CC$3 = 'Cocos Islands';
const CA$4 = 'Canada';
const CG$3 = 'Republic of the Congo';
const CF$3 = 'Central African Republic';
const CD$3 = 'Democratic Republic of the Congo';
const CZ$3 = 'Czech Republic';
const CY$3 = 'Cyprus';
const CX$3 = 'Christmas Island';
const CR$3 = 'Costa Rica';
const CW$2 = 'Curacao';
const CV$3 = 'Cape Verde';
const CU$4 = 'Cuba';
const SZ$3 = 'Swaziland';
const SY$3 = 'Syria';
const SX$2 = 'Sint Maarten';
const KG$3 = 'Kyrgyzstan';
const KE$3 = 'Kenya';
const SS$3 = 'South Sudan';
const SR$3 = 'Suriname';
const KI$3 = 'Kiribati';
const KH$4 = 'Cambodia';
const KN$3 = 'Saint Kitts and Nevis';
const KM$3 = 'Comoros';
const ST$3 = 'Sao Tome and Principe';
const SK$3 = 'Slovakia';
const KR$3 = 'South Korea';
const SI$3 = 'Slovenia';
const KP$3 = 'North Korea';
const KW$3 = 'Kuwait';
const SN$3 = 'Senegal';
const SM$3 = 'San Marino';
const SL$3 = 'Sierra Leone';
const SC$3 = 'Seychelles';
const KZ$3 = 'Kazakhstan';
const KY$3 = 'Cayman Islands';
const SG$3 = 'Singapore';
const SE$3 = 'Sweden';
const SD$3 = 'Sudan';
const DO$3 = 'Dominican Republic';
const DM$3 = 'Dominica';
const DJ$3 = 'Djibouti';
const DK$4 = 'Denmark';
const VG$3 = 'British Virgin Islands';
const DE$4 = 'Germany';
const YE$3 = 'Yemen';
const DZ$3 = 'Algeria';
const US$4 = 'United States';
const UY$3 = 'Uruguay';
const YT$3 = 'Mayotte';
const UM$3 = 'United States Minor Outlying Islands';
const LB$3 = 'Lebanon';
const LC$3 = 'Saint Lucia';
const LA$3 = 'Laos';
const TV$3 = 'Tuvalu';
const TW$3 = 'Taiwan';
const TT$3 = 'Trinidad and Tobago';
const TR$4 = 'Turkey';
const LK$3 = 'Sri Lanka';
const LI$3 = 'Liechtenstein';
const LV$3 = 'Latvia';
const TO$3 = 'Tonga';
const LT$3 = 'Lithuania';
const LU$3 = 'Luxembourg';
const LR$3 = 'Liberia';
const LS$3 = 'Lesotho';
const TH$3 = 'Thailand';
const TF$3 = 'French Southern Territories';
const TG$3 = 'Togo';
const TD$3 = 'Chad';
const TC$3 = 'Turks and Caicos Islands';
const LY$3 = 'Libya';
const VA$3 = 'Vatican';
const VC$3 = 'Saint Vincent and the Grenadines';
const AE$3 = 'United Arab Emirates';
const AD$3 = 'Andorra';
const AG$3 = 'Antigua and Barbuda';
const AF$3 = 'Afghanistan';
const AI$3 = 'Anguilla';
const VI$3 = 'U.S. Virgin Islands';
const IS$3 = 'Iceland';
const IR$3 = 'Iran';
const AM$3 = 'Armenia';
const AL$3 = 'Albania';
const AO$3 = 'Angola';
const AQ$3 = 'Antarctica';
const AS$3 = 'American Samoa';
const AR$4 = 'Argentina';
const AU$4 = 'Australia';
const AT$4 = 'Austria';
const AW$3 = 'Aruba';
const IN$4 = 'India';
const AX$3 = 'Aland Islands';
const AZ$3 = 'Azerbaijan';
const IE$3 = 'Ireland';
const ID$4 = 'Indonesia';
const UA$3 = 'Ukraine';
const QA$3 = 'Qatar';
const MZ$3 = 'Mozambique';
const require$$6$1 = {
  BD: BD$4,
  BE: BE$4,
  BF: BF$3,
  BG: BG$3,
  BA: BA$3,
  BB: BB$3,
  WF: WF$3,
  BL: BL$3,
  BM: BM$3,
  BN: BN$3,
  BO: BO$4,
  BH: BH$3,
  BI: BI$3,
  BJ: BJ$3,
  BT: BT$3,
  JM: JM$3,
  BV: BV$3,
  BW: BW$3,
  WS: WS$3,
  BQ: BQ$2,
  BR: BR$4,
  BS: BS$3,
  JE: JE$3,
  BY: BY$3,
  BZ: BZ$3,
  RU: RU$3,
  RW: RW$3,
  RS: RS$3,
  TL: TL$3,
  RE: RE$3,
  TM: TM$3,
  TJ: TJ$3,
  RO: RO$3,
  TK: TK$3,
  GW: GW$3,
  GU: GU$3,
  GT: GT$3,
  GS: GS$3,
  GR: GR$3,
  GQ: GQ$3,
  GP: GP$3,
  JP: JP$4,
  GY: GY$3,
  GG: GG$3,
  GF: GF$3,
  GE: GE$3,
  GD: GD$3,
  GB: GB$4,
  GA: GA$3,
  SV: SV$3,
  GN: GN$3,
  GM: GM$3,
  GL: GL$3,
  GI: GI$3,
  GH: GH$3,
  OM: OM$3,
  TN: TN$3,
  JO: JO$4,
  HR: HR$3,
  HT: HT$3,
  HU: HU$3,
  HK: HK$3,
  HN: HN$3,
  HM: HM$3,
  VE: VE$3,
  PR: PR$3,
  PS: PS$3,
  PW: PW$3,
  PT: PT$3,
  SJ: SJ$3,
  PY: PY$3,
  IQ: IQ$3,
  PA: PA$3,
  PF: PF$3,
  PG: PG$3,
  PE: PE$4,
  PK: PK$4,
  PH: PH$4,
  PN: PN$3,
  PL: PL$3,
  PM: PM$3,
  ZM: ZM$3,
  EH: EH$3,
  EE: EE$3,
  EG: EG$3,
  ZA: ZA$3,
  EC: EC$3,
  IT: IT$4,
  VN: VN$4,
  SB: SB$3,
  ET: ET$4,
  SO: SO$3,
  ZW: ZW$3,
  SA: SA$3,
  ES: ES$4,
  ER: ER$3,
  ME: ME$3,
  MD: MD$3,
  MG: MG$3,
  MF: MF$3,
  MA: MA$3,
  MC: MC$3,
  UZ: UZ$3,
  MM: MM$3,
  ML: ML$3,
  MO: MO$3,
  MN: MN$3,
  MH: MH$3,
  MK: MK$3,
  MU: MU$3,
  MT: MT$3,
  MW: MW$3,
  MV: MV$3,
  MQ: MQ$3,
  MP: MP$3,
  MS: MS$3,
  MR: MR$3,
  IM: IM$3,
  UG: UG$3,
  TZ: TZ$3,
  MY: MY$3,
  MX: MX$4,
  IL: IL$3,
  FR: FR$3,
  IO: IO$3,
  SH: SH$3,
  FI: FI$3,
  FJ: FJ$3,
  FK: FK$3,
  FM: FM$3,
  FO: FO$3,
  NI: NI$3,
  NL: NL$4,
  NO: NO$3,
  NA: NA$3,
  VU: VU$3,
  NC: NC$3,
  NE: NE$3,
  NF: NF$3,
  NG: NG$4,
  NZ: NZ$3,
  NP: NP$3,
  NR: NR$3,
  NU: NU$3,
  CK: CK$3,
  XK: XK$2,
  CI: CI$3,
  CH: CH$3,
  CO: CO$3,
  CN: CN$4,
  CM: CM$3,
  CL: CL$4,
  CC: CC$3,
  CA: CA$4,
  CG: CG$3,
  CF: CF$3,
  CD: CD$3,
  CZ: CZ$3,
  CY: CY$3,
  CX: CX$3,
  CR: CR$3,
  CW: CW$2,
  CV: CV$3,
  CU: CU$4,
  SZ: SZ$3,
  SY: SY$3,
  SX: SX$2,
  KG: KG$3,
  KE: KE$3,
  SS: SS$3,
  SR: SR$3,
  KI: KI$3,
  KH: KH$4,
  KN: KN$3,
  KM: KM$3,
  ST: ST$3,
  SK: SK$3,
  KR: KR$3,
  SI: SI$3,
  KP: KP$3,
  KW: KW$3,
  SN: SN$3,
  SM: SM$3,
  SL: SL$3,
  SC: SC$3,
  KZ: KZ$3,
  KY: KY$3,
  SG: SG$3,
  SE: SE$3,
  SD: SD$3,
  DO: DO$3,
  DM: DM$3,
  DJ: DJ$3,
  DK: DK$4,
  VG: VG$3,
  DE: DE$4,
  YE: YE$3,
  DZ: DZ$3,
  US: US$4,
  UY: UY$3,
  YT: YT$3,
  UM: UM$3,
  LB: LB$3,
  LC: LC$3,
  LA: LA$3,
  TV: TV$3,
  TW: TW$3,
  TT: TT$3,
  TR: TR$4,
  LK: LK$3,
  LI: LI$3,
  LV: LV$3,
  TO: TO$3,
  LT: LT$3,
  LU: LU$3,
  LR: LR$3,
  LS: LS$3,
  TH: TH$3,
  TF: TF$3,
  TG: TG$3,
  TD: TD$3,
  TC: TC$3,
  LY: LY$3,
  VA: VA$3,
  VC: VC$3,
  AE: AE$3,
  AD: AD$3,
  AG: AG$3,
  AF: AF$3,
  AI: AI$3,
  VI: VI$3,
  IS: IS$3,
  IR: IR$3,
  AM: AM$3,
  AL: AL$3,
  AO: AO$3,
  AQ: AQ$3,
  AS: AS$3,
  AR: AR$4,
  AU: AU$4,
  AT: AT$4,
  AW: AW$3,
  IN: IN$4,
  AX: AX$3,
  AZ: AZ$3,
  IE: IE$3,
  ID: ID$4,
  UA: UA$3,
  QA: QA$3,
  MZ: MZ$3,
};
const BD$3 = '880';
const BE$3 = '32';
const BF$2 = '226';
const BG$2 = '359';
const BA$2 = '387';
const BB$2 = '+1-246';
const WF$2 = '681';
const BL$2 = '590';
const BM$2 = '+1-441';
const BN$2 = '673';
const BO$3 = '591';
const BH$2 = '973';
const BI$2 = '257';
const BJ$2 = '229';
const BT$2 = '975';
const JM$2 = '+1-876';
const BV$2 = '';
const BW$2 = '267';
const WS$2 = '685';
const BQ$1 = '599';
const BR$3 = '55';
const BS$2 = '+1-242';
const JE$2 = '+44-1534';
const BY$2 = '375';
const BZ$2 = '501';
const RU$2 = '7';
const RW$2 = '250';
const RS$2 = '381';
const TL$2 = '670';
const RE$2 = '262';
const TM$2 = '993';
const TJ$2 = '992';
const RO$2 = '40';
const TK$2 = '690';
const GW$2 = '245';
const GU$2 = '+1-671';
const GT$2 = '502';
const GS$2 = '';
const GR$2 = '30';
const GQ$2 = '240';
const GP$2 = '590';
const JP$3 = '81';
const GY$2 = '592';
const GG$2 = '+44-1481';
const GF$2 = '594';
const GE$2 = '995';
const GD$2 = '+1-473';
const GB$3 = '44';
const GA$2 = '241';
const SV$2 = '503';
const GN$2 = '224';
const GM$2 = '220';
const GL$2 = '299';
const GI$2 = '350';
const GH$2 = '233';
const OM$2 = '968';
const TN$2 = '216';
const JO$3 = '962';
const HR$2 = '385';
const HT$2 = '509';
const HU$2 = '36';
const HK$2 = '852';
const HN$2 = '504';
const HM$2 = ' ';
const VE$2 = '58';
const PR$2 = '+1-787 and 1-939';
const PS$2 = '970';
const PW$2 = '680';
const PT$2 = '351';
const SJ$2 = '47';
const PY$2 = '595';
const IQ$2 = '964';
const PA$2 = '507';
const PF$2 = '689';
const PG$2 = '675';
const PE$3 = '51';
const PK$3 = '92';
const PH$3 = '63';
const PN$2 = '870';
const PL$2 = '48';
const PM$2 = '508';
const ZM$2 = '260';
const EH$2 = '212';
const EE$2 = '372';
const EG$2 = '20';
const ZA$2 = '27';
const EC$2 = '593';
const IT$3 = '39';
const VN$3 = '84';
const SB$2 = '677';
const ET$3 = '251';
const SO$2 = '252';
const ZW$2 = '263';
const SA$2 = '966';
const ES$3 = '34';
const ER$2 = '291';
const ME$2 = '382';
const MD$2 = '373';
const MG$2 = '261';
const MF$2 = '590';
const MA$2 = '212';
const MC$2 = '377';
const UZ$2 = '998';
const MM$2 = '95';
const ML$2 = '223';
const MO$2 = '853';
const MN$2 = '976';
const MH$2 = '692';
const MK$2 = '389';
const MU$2 = '230';
const MT$2 = '356';
const MW$2 = '265';
const MV$2 = '960';
const MQ$2 = '596';
const MP$2 = '+1-670';
const MS$2 = '+1-664';
const MR$2 = '222';
const IM$2 = '+44-1624';
const UG$2 = '256';
const TZ$2 = '255';
const MY$2 = '60';
const MX$3 = '52';
const IL$2 = '972';
const FR$2 = '33';
const IO$2 = '246';
const SH$2 = '290';
const FI$2 = '358';
const FJ$2 = '679';
const FK$2 = '500';
const FM$2 = '691';
const FO$2 = '298';
const NI$2 = '505';
const NL$3 = '31';
const NO$2 = '47';
const NA$2 = '264';
const VU$2 = '678';
const NC$2 = '687';
const NE$2 = '227';
const NF$2 = '672';
const NG$3 = '234';
const NZ$2 = '64';
const NP$2 = '977';
const NR$2 = '674';
const NU$2 = '683';
const CK$2 = '682';
const XK$1 = '';
const CI$2 = '225';
const CH$2 = '41';
const CO$2 = '57';
const CN$3 = '86';
const CM$2 = '237';
const CL$3 = '56';
const CC$2 = '61';
const CA$3 = '1';
const CG$2 = '242';
const CF$2 = '236';
const CD$2 = '243';
const CZ$2 = '420';
const CY$2 = '357';
const CX$2 = '61';
const CR$2 = '506';
const CW$1 = '599';
const CV$2 = '238';
const CU$3 = '53';
const SZ$2 = '268';
const SY$2 = '963';
const SX$1 = '599';
const KG$2 = '996';
const KE$2 = '254';
const SS$2 = '211';
const SR$2 = '597';
const KI$2 = '686';
const KH$3 = '855';
const KN$2 = '+1-869';
const KM$2 = '269';
const ST$2 = '239';
const SK$2 = '421';
const KR$2 = '82';
const SI$2 = '386';
const KP$2 = '850';
const KW$2 = '965';
const SN$2 = '221';
const SM$2 = '378';
const SL$2 = '232';
const SC$2 = '248';
const KZ$2 = '7';
const KY$2 = '+1-345';
const SG$2 = '65';
const SE$2 = '46';
const SD$2 = '249';
const DO$2 = '+1-809 and 1-829';
const DM$2 = '+1-767';
const DJ$2 = '253';
const DK$3 = '45';
const VG$2 = '+1-284';
const DE$3 = '49';
const YE$2 = '967';
const DZ$2 = '213';
const US$3 = '1';
const UY$2 = '598';
const YT$2 = '262';
const UM$2 = '1';
const LB$2 = '961';
const LC$2 = '+1-758';
const LA$2 = '856';
const TV$2 = '688';
const TW$2 = '886';
const TT$2 = '+1-868';
const TR$3 = '90';
const LK$2 = '94';
const LI$2 = '423';
const LV$2 = '371';
const TO$2 = '676';
const LT$2 = '370';
const LU$2 = '352';
const LR$2 = '231';
const LS$2 = '266';
const TH$2 = '66';
const TF$2 = '';
const TG$2 = '228';
const TD$2 = '235';
const TC$2 = '+1-649';
const LY$2 = '218';
const VA$2 = '379';
const VC$2 = '+1-784';
const AE$2 = '971';
const AD$2 = '376';
const AG$2 = '+1-268';
const AF$2 = '93';
const AI$2 = '+1-264';
const VI$2 = '+1-340';
const IS$2 = '354';
const IR$2 = '98';
const AM$2 = '374';
const AL$2 = '355';
const AO$2 = '244';
const AQ$2 = '';
const AS$2 = '+1-684';
const AR$3 = '54';
const AU$3 = '61';
const AT$3 = '43';
const AW$2 = '297';
const IN$3 = '91';
const AX$2 = '+358-18';
const AZ$2 = '994';
const IE$2 = '353';
const ID$3 = '62';
const UA$2 = '380';
const QA$2 = '974';
const MZ$2 = '258';
const require$$7$1 = {
  BD: BD$3,
  BE: BE$3,
  BF: BF$2,
  BG: BG$2,
  BA: BA$2,
  BB: BB$2,
  WF: WF$2,
  BL: BL$2,
  BM: BM$2,
  BN: BN$2,
  BO: BO$3,
  BH: BH$2,
  BI: BI$2,
  BJ: BJ$2,
  BT: BT$2,
  JM: JM$2,
  BV: BV$2,
  BW: BW$2,
  WS: WS$2,
  BQ: BQ$1,
  BR: BR$3,
  BS: BS$2,
  JE: JE$2,
  BY: BY$2,
  BZ: BZ$2,
  RU: RU$2,
  RW: RW$2,
  RS: RS$2,
  TL: TL$2,
  RE: RE$2,
  TM: TM$2,
  TJ: TJ$2,
  RO: RO$2,
  TK: TK$2,
  GW: GW$2,
  GU: GU$2,
  GT: GT$2,
  GS: GS$2,
  GR: GR$2,
  GQ: GQ$2,
  GP: GP$2,
  JP: JP$3,
  GY: GY$2,
  GG: GG$2,
  GF: GF$2,
  GE: GE$2,
  GD: GD$2,
  GB: GB$3,
  GA: GA$2,
  SV: SV$2,
  GN: GN$2,
  GM: GM$2,
  GL: GL$2,
  GI: GI$2,
  GH: GH$2,
  OM: OM$2,
  TN: TN$2,
  JO: JO$3,
  HR: HR$2,
  HT: HT$2,
  HU: HU$2,
  HK: HK$2,
  HN: HN$2,
  HM: HM$2,
  VE: VE$2,
  PR: PR$2,
  PS: PS$2,
  PW: PW$2,
  PT: PT$2,
  SJ: SJ$2,
  PY: PY$2,
  IQ: IQ$2,
  PA: PA$2,
  PF: PF$2,
  PG: PG$2,
  PE: PE$3,
  PK: PK$3,
  PH: PH$3,
  PN: PN$2,
  PL: PL$2,
  PM: PM$2,
  ZM: ZM$2,
  EH: EH$2,
  EE: EE$2,
  EG: EG$2,
  ZA: ZA$2,
  EC: EC$2,
  IT: IT$3,
  VN: VN$3,
  SB: SB$2,
  ET: ET$3,
  SO: SO$2,
  ZW: ZW$2,
  SA: SA$2,
  ES: ES$3,
  ER: ER$2,
  ME: ME$2,
  MD: MD$2,
  MG: MG$2,
  MF: MF$2,
  MA: MA$2,
  MC: MC$2,
  UZ: UZ$2,
  MM: MM$2,
  ML: ML$2,
  MO: MO$2,
  MN: MN$2,
  MH: MH$2,
  MK: MK$2,
  MU: MU$2,
  MT: MT$2,
  MW: MW$2,
  MV: MV$2,
  MQ: MQ$2,
  MP: MP$2,
  MS: MS$2,
  MR: MR$2,
  IM: IM$2,
  UG: UG$2,
  TZ: TZ$2,
  MY: MY$2,
  MX: MX$3,
  IL: IL$2,
  FR: FR$2,
  IO: IO$2,
  SH: SH$2,
  FI: FI$2,
  FJ: FJ$2,
  FK: FK$2,
  FM: FM$2,
  FO: FO$2,
  NI: NI$2,
  NL: NL$3,
  NO: NO$2,
  NA: NA$2,
  VU: VU$2,
  NC: NC$2,
  NE: NE$2,
  NF: NF$2,
  NG: NG$3,
  NZ: NZ$2,
  NP: NP$2,
  NR: NR$2,
  NU: NU$2,
  CK: CK$2,
  XK: XK$1,
  CI: CI$2,
  CH: CH$2,
  CO: CO$2,
  CN: CN$3,
  CM: CM$2,
  CL: CL$3,
  CC: CC$2,
  CA: CA$3,
  CG: CG$2,
  CF: CF$2,
  CD: CD$2,
  CZ: CZ$2,
  CY: CY$2,
  CX: CX$2,
  CR: CR$2,
  CW: CW$1,
  CV: CV$2,
  CU: CU$3,
  SZ: SZ$2,
  SY: SY$2,
  SX: SX$1,
  KG: KG$2,
  KE: KE$2,
  SS: SS$2,
  SR: SR$2,
  KI: KI$2,
  KH: KH$3,
  KN: KN$2,
  KM: KM$2,
  ST: ST$2,
  SK: SK$2,
  KR: KR$2,
  SI: SI$2,
  KP: KP$2,
  KW: KW$2,
  SN: SN$2,
  SM: SM$2,
  SL: SL$2,
  SC: SC$2,
  KZ: KZ$2,
  KY: KY$2,
  SG: SG$2,
  SE: SE$2,
  SD: SD$2,
  DO: DO$2,
  DM: DM$2,
  DJ: DJ$2,
  DK: DK$3,
  VG: VG$2,
  DE: DE$3,
  YE: YE$2,
  DZ: DZ$2,
  US: US$3,
  UY: UY$2,
  YT: YT$2,
  UM: UM$2,
  LB: LB$2,
  LC: LC$2,
  LA: LA$2,
  TV: TV$2,
  TW: TW$2,
  TT: TT$2,
  TR: TR$3,
  LK: LK$2,
  LI: LI$2,
  LV: LV$2,
  TO: TO$2,
  LT: LT$2,
  LU: LU$2,
  LR: LR$2,
  LS: LS$2,
  TH: TH$2,
  TF: TF$2,
  TG: TG$2,
  TD: TD$2,
  TC: TC$2,
  LY: LY$2,
  VA: VA$2,
  VC: VC$2,
  AE: AE$2,
  AD: AD$2,
  AG: AG$2,
  AF: AF$2,
  AI: AI$2,
  VI: VI$2,
  IS: IS$2,
  IR: IR$2,
  AM: AM$2,
  AL: AL$2,
  AO: AO$2,
  AQ: AQ$2,
  AS: AS$2,
  AR: AR$3,
  AU: AU$3,
  AT: AT$3,
  AW: AW$2,
  IN: IN$3,
  AX: AX$2,
  AZ: AZ$2,
  IE: IE$2,
  ID: ID$3,
  UA: UA$2,
  QA: QA$2,
  MZ: MZ$2,
};
const AD$1 = 'Southern Europe';
const AE$1 = 'Western Asia, Middle East';
const AF$1 = 'Central Asia';
const AG$1 = 'Caribbean';
const AI$1 = 'Caribbean';
const AL$1 = 'Balkans';
const AM$1 = 'Western Asia';
const AO$1 = 'Central Africa';
const AQ$1 = 'Antarctica';
const AR$2 = 'South America';
const AS$1 = 'American Samoa';
const AT$2 = 'Western Europe';
const AU$2 = 'Oceania';
const AW$1 = 'Caribbean';
const AX$1 = 'Scandinavia';
const AZ$1 = 'Western Asia';
const BA$1 = 'Balkans';
const BB$1 = 'Caribbean';
const BD$2 = 'Southern Asia';
const BE$2 = 'Western Europe';
const BF$1 = 'Western Africa';
const BG$1 = 'Central Europe';
const BH$1 = 'Western Asia, Middle East';
const BI$1 = 'East Africa, Central Africa';
const BJ$1 = 'Western Africa';
const BL$1 = 'Caribbean';
const BM$1 = 'Caribbean, North America';
const BN$1 = 'South-East Asia';
const BO$2 = 'South America';
const BQ = 'Caribbean';
const BR$2 = 'South America';
const BS$1 = 'Caribbean';
const BT$1 = 'Southern Asia';
const BV$1 = 'Scandinavia, Nordic Countries';
const BW$1 = 'Southern Africa';
const BY$1 = 'Central Europe';
const BZ$1 = 'Caribbean';
const CA$2 = 'North America';
const CC$1 = 'Central America';
const CD$1 = 'Central Africa';
const CF$1 = 'Central Africa';
const CG$1 = 'Central Africa';
const CH$1 = 'Western Europe';
const CI$1 = 'Western Africa';
const CK$1 = 'Oceania';
const CL$2 = 'South America';
const CM$1 = 'Central Africa';
const CN$2 = 'East Asia';
const CO$1 = 'South America';
const CR$1 = 'Central America';
const CU$2 = 'Caribbean';
const CV$1 = 'Western Africa';
const CW = 'Caribbean';
const CX$1 = 'Oceania';
const CY$1 = 'Western Asia';
const CZ$1 = 'Central Europe';
const DE$2 = 'Western Europe';
const DJ$1 = 'East Africa';
const DK$2 = 'Scandinavia, Nordic Countries';
const DM$1 = 'Caribbean';
const DO$1 = 'Caribbean';
const DZ$1 = 'Northern Africa';
const EC$1 = 'South America';
const EE$1 = 'Baltic Countries';
const EG$1 = 'Northern Africa';
const EH$1 = 'Western Sahara';
const ER$1 = 'East Africa';
const ES$2 = 'Southern Europe';
const ET$2 = 'East Africa';
const FI$1 = 'Nordic Countries';
const FJ$1 = 'Oceania';
const FK$1 = 'South America';
const FM$1 = 'Oceania';
const FO$1 = 'Scandinavia, Nordic Countries';
const FR$1 = 'Western Europe';
const GA$1 = 'Central Africa';
const GB$2 = 'Western Europe';
const GD$1 = 'Caribbean';
const GE$1 = 'Western Asia';
const GF$1 = 'South America';
const GG$1 = 'Western Europe';
const GH$1 = 'Western African';
const GI$1 = 'Southern Europe';
const GL$1 = 'North America';
const GM$1 = 'Western Africa';
const GN$1 = 'Western Africa';
const GP$1 = 'Caribbean';
const GQ$1 = 'Central Africa';
const GR$1 = 'Southern Europe';
const GS$1 = 'South America';
const GT$1 = 'Central America';
const GU$1 = 'Oceania';
const GW$1 = 'Western Africa';
const GY$1 = 'Caribbean';
const HK$1 = 'East Asia';
const HM$1 = 'Oceania';
const HN$1 = 'Central America';
const HR$1 = 'Balkans';
const HT$1 = 'Caribbean';
const HU$1 = 'Central Europe';
const ID$2 = 'South-East Asia, Oceania';
const IE$1 = 'Western Europe';
const IL$1 = 'Western Asia, Middle East';
const IM$1 = 'Western Europe';
const IN$2 = 'Southern Asia';
const IO$1 = 'Southern Asia';
const IQ$1 = 'Western Asia, Middle East';
const IR$1 = 'Western Asia, Middle East';
const IS$1 = 'Scandinavia, Nordic Countries';
const IT$2 = 'Southern Europe';
const JE$1 = 'Western Europe';
const JM$1 = 'Caribbean';
const JO$2 = 'Western Asia, Middle East';
const JP$2 = 'East Asia';
const KE$1 = 'East Africa';
const KG$1 = 'Central Asia';
const KH$2 = 'South-East Asia';
const KI$1 = 'Oceania';
const KM$1 = 'East Africa';
const KN$1 = 'Caribbean';
const KP$1 = 'East Asia';
const KR$1 = 'East Asia';
const KW$1 = 'Western Asia, Middle East';
const KY$1 = 'Caribbean';
const KZ$1 = 'Central Asia';
const LA$1 = 'South-East Asia';
const LB$1 = 'Western Asia, Middle East';
const LC$1 = 'Caribbean';
const LI$1 = 'Western Europe';
const LK$1 = 'Southern Asia';
const LR$1 = 'Western Africa';
const LS$1 = 'Southern Africa';
const LT$1 = 'Baltic Countries';
const LU$1 = 'Western Europe';
const LV$1 = 'Baltic Countries';
const LY$1 = 'Northern Africa';
const MA$1 = 'Northern Africa';
const MC$1 = 'Western Europe';
const MD$1 = 'Central Europe';
const ME$1 = 'Balkans';
const MF$1 = 'Caribbean';
const MG$1 = 'East Africa, Southern Africa';
const MH$1 = 'Oceania';
const MK$1 = 'Balkans';
const ML$1 = 'Western Africa';
const MM$1 = 'South-East Asia';
const MN$1 = 'East Asia';
const MO$1 = 'East Asia';
const MP$1 = 'South-East Asia';
const MQ$1 = 'Caribbean';
const MR$1 = 'Western Africa';
const MS$1 = 'Caribbean';
const MT$1 = 'Southern Europe';
const MU$1 = 'East Africa';
const MV$1 = 'Southern Asia';
const MW$1 = 'East Africa, Southern Africa';
const MX$2 = 'North America';
const MY$1 = 'South-East Asia';
const MZ$1 = 'East Africa, Southern Africa';
const NA$1 = 'Southern Africa';
const NC$1 = 'Oceania';
const NE$1 = 'Western Africa';
const NF$1 = 'Oceania';
const NG$2 = 'Western Africa';
const NI$1 = 'Central America';
const NL$2 = 'Western Europe, Nordic Countries';
const NO$1 = 'Scandinavia, Nordic Countries';
const NP$1 = 'Southern Asia';
const NR$1 = 'Oceania';
const NU$1 = 'Oceania';
const NZ$1 = 'Oceania';
const OM$1 = 'Western Asia, Middle East';
const PA$1 = 'Central America';
const PE$2 = 'South America';
const PF$1 = 'Oceania';
const PG$1 = 'Oceania';
const PH$2 = 'South-East Asia';
const PK$2 = 'Southern Asia';
const PL$1 = 'Central Europe';
const PM$1 = 'North America';
const PN$1 = 'Oceania';
const PR$1 = 'Caribbean';
const PS$1 = 'Western Asia, Middle East';
const PT$1 = 'Southern Europe';
const PW$1 = 'Oceania';
const PY$1 = 'South America';
const QA$1 = 'Western Asia, Middle East';
const RE$1 = 'East Africa';
const RO$1 = 'Central Europe';
const RS$1 = 'Balkans';
const RU$1 = 'Eastern Europe';
const RW$1 = 'East Africa, Central Africa';
const SA$1 = 'Western Asia, Middle East';
const SB$1 = 'Oceania';
const SC$1 = 'East Africa';
const SD$1 = 'Northern Africa, East Africa';
const SE$1 = 'Scandinavia, Nordic Countries';
const SG$1 = 'South-East Asia';
const SH$1 = 'Western Africa';
const SI$1 = 'Balkans';
const SJ$1 = 'Scandinavia';
const SK$1 = 'Central Europe';
const SL$1 = 'Western Africa';
const SM$1 = 'Southern Europe';
const SN$1 = 'Western Africa';
const SO$1 = 'East Africa';
const SR$1 = 'South America';
const SS$1 = 'East Africa, Northern Africa';
const ST$1 = 'Central Africa';
const SV$1 = 'Central America';
const SX = 'Caribbean';
const SY$1 = 'Western Asia, Middle East';
const SZ$1 = 'Southern Africa';
const TC$1 = 'Caribbean';
const TD$1 = 'Central Africa';
const TF$1 = 'Oceania';
const TG$1 = 'Western Africa';
const TH$1 = 'South-East Asia';
const TJ$1 = 'Central Asia';
const TK$1 = 'Oceania';
const TL$1 = 'South-East Asia';
const TM$1 = 'Central Asia';
const TN$1 = 'Northern Africa';
const TO$1 = 'Oceania';
const TR$2 = 'Western Asia, Middle East';
const TT$1 = 'Caribbean';
const TV$1 = 'Oceania';
const TW$1 = 'East Asia';
const TZ$1 = 'East Africa';
const UA$1 = 'Central Europe';
const UG$1 = 'East Africa';
const UM$1 = 'Oceania';
const US$2 = 'North America';
const UY$1 = 'South America';
const UZ$1 = 'Central Asia';
const VA$1 = 'Southern Europe';
const VC$1 = 'Caribbean';
const VE$1 = 'South America';
const VG$1 = 'Caribbean';
const VI$1 = 'Caribbean';
const VN$2 = 'South-East Asia';
const VU$1 = 'Oceania';
const WF$1 = 'Oceania';
const WS$1 = 'Oceania';
const XK = 'Balkans';
const YE$1 = 'Western Asia, Middle East';
const YT$1 = 'East Africa';
const ZA$1 = 'Southern Africa';
const ZM$1 = 'East Africa, Southern Africa';
const ZW$1 = 'East Africa, Southern Africa';
const require$$8$1 = {
  AD: AD$1,
  AE: AE$1,
  AF: AF$1,
  AG: AG$1,
  AI: AI$1,
  AL: AL$1,
  AM: AM$1,
  AO: AO$1,
  AQ: AQ$1,
  AR: AR$2,
  AS: AS$1,
  AT: AT$2,
  AU: AU$2,
  AW: AW$1,
  AX: AX$1,
  AZ: AZ$1,
  BA: BA$1,
  BB: BB$1,
  BD: BD$2,
  BE: BE$2,
  BF: BF$1,
  BG: BG$1,
  BH: BH$1,
  BI: BI$1,
  BJ: BJ$1,
  BL: BL$1,
  BM: BM$1,
  BN: BN$1,
  BO: BO$2,
  BQ,
  BR: BR$2,
  BS: BS$1,
  BT: BT$1,
  BV: BV$1,
  BW: BW$1,
  BY: BY$1,
  BZ: BZ$1,
  CA: CA$2,
  CC: CC$1,
  CD: CD$1,
  CF: CF$1,
  CG: CG$1,
  CH: CH$1,
  CI: CI$1,
  CK: CK$1,
  CL: CL$2,
  CM: CM$1,
  CN: CN$2,
  CO: CO$1,
  CR: CR$1,
  CU: CU$2,
  CV: CV$1,
  CW,
  CX: CX$1,
  CY: CY$1,
  CZ: CZ$1,
  DE: DE$2,
  DJ: DJ$1,
  DK: DK$2,
  DM: DM$1,
  DO: DO$1,
  DZ: DZ$1,
  EC: EC$1,
  EE: EE$1,
  EG: EG$1,
  EH: EH$1,
  ER: ER$1,
  ES: ES$2,
  ET: ET$2,
  FI: FI$1,
  FJ: FJ$1,
  FK: FK$1,
  FM: FM$1,
  FO: FO$1,
  FR: FR$1,
  GA: GA$1,
  GB: GB$2,
  GD: GD$1,
  GE: GE$1,
  GF: GF$1,
  GG: GG$1,
  GH: GH$1,
  GI: GI$1,
  GL: GL$1,
  GM: GM$1,
  GN: GN$1,
  GP: GP$1,
  GQ: GQ$1,
  GR: GR$1,
  GS: GS$1,
  GT: GT$1,
  GU: GU$1,
  GW: GW$1,
  GY: GY$1,
  HK: HK$1,
  HM: HM$1,
  HN: HN$1,
  HR: HR$1,
  HT: HT$1,
  HU: HU$1,
  ID: ID$2,
  IE: IE$1,
  IL: IL$1,
  IM: IM$1,
  IN: IN$2,
  IO: IO$1,
  IQ: IQ$1,
  IR: IR$1,
  IS: IS$1,
  IT: IT$2,
  JE: JE$1,
  JM: JM$1,
  JO: JO$2,
  JP: JP$2,
  KE: KE$1,
  KG: KG$1,
  KH: KH$2,
  KI: KI$1,
  KM: KM$1,
  KN: KN$1,
  KP: KP$1,
  KR: KR$1,
  KW: KW$1,
  KY: KY$1,
  KZ: KZ$1,
  LA: LA$1,
  LB: LB$1,
  LC: LC$1,
  LI: LI$1,
  LK: LK$1,
  LR: LR$1,
  LS: LS$1,
  LT: LT$1,
  LU: LU$1,
  LV: LV$1,
  LY: LY$1,
  MA: MA$1,
  MC: MC$1,
  MD: MD$1,
  ME: ME$1,
  MF: MF$1,
  MG: MG$1,
  MH: MH$1,
  MK: MK$1,
  ML: ML$1,
  MM: MM$1,
  MN: MN$1,
  MO: MO$1,
  MP: MP$1,
  MQ: MQ$1,
  MR: MR$1,
  MS: MS$1,
  MT: MT$1,
  MU: MU$1,
  MV: MV$1,
  MW: MW$1,
  MX: MX$2,
  MY: MY$1,
  MZ: MZ$1,
  NA: NA$1,
  NC: NC$1,
  NE: NE$1,
  NF: NF$1,
  NG: NG$2,
  NI: NI$1,
  NL: NL$2,
  NO: NO$1,
  NP: NP$1,
  NR: NR$1,
  NU: NU$1,
  NZ: NZ$1,
  OM: OM$1,
  PA: PA$1,
  PE: PE$2,
  PF: PF$1,
  PG: PG$1,
  PH: PH$2,
  PK: PK$2,
  PL: PL$1,
  PM: PM$1,
  PN: PN$1,
  PR: PR$1,
  PS: PS$1,
  PT: PT$1,
  PW: PW$1,
  PY: PY$1,
  QA: QA$1,
  RE: RE$1,
  RO: RO$1,
  RS: RS$1,
  RU: RU$1,
  RW: RW$1,
  SA: SA$1,
  SB: SB$1,
  SC: SC$1,
  SD: SD$1,
  SE: SE$1,
  SG: SG$1,
  SH: SH$1,
  SI: SI$1,
  SJ: SJ$1,
  SK: SK$1,
  SL: SL$1,
  SM: SM$1,
  SN: SN$1,
  SO: SO$1,
  SR: SR$1,
  SS: SS$1,
  ST: ST$1,
  SV: SV$1,
  SX,
  SY: SY$1,
  SZ: SZ$1,
  TC: TC$1,
  TD: TD$1,
  TF: TF$1,
  TG: TG$1,
  TH: TH$1,
  TJ: TJ$1,
  TK: TK$1,
  TL: TL$1,
  TM: TM$1,
  TN: TN$1,
  TO: TO$1,
  TR: TR$2,
  TT: TT$1,
  TV: TV$1,
  TW: TW$1,
  TZ: TZ$1,
  UA: UA$1,
  UG: UG$1,
  UM: UM$1,
  US: US$2,
  UY: UY$1,
  UZ: UZ$1,
  VA: VA$1,
  VC: VC$1,
  VE: VE$1,
  VG: VG$1,
  VI: VI$1,
  VN: VN$2,
  VU: VU$1,
  WF: WF$1,
  WS: WS$1,
  XK,
  YE: YE$1,
  YT: YT$1,
  ZA: ZA$1,
  ZM: ZM$1,
  ZW: ZW$1,
};
const AR$1 = [
  {
    name: 'Ciudad Autónoma de Buenos Aires',
    alias: [
      'Ciudad Autonoma de Buenos Aires',
    ],
  },
  {
    name: 'Buenos Aires',
    alias: null,
  },
  {
    name: 'Catamarca',
    alias: null,
  },
  {
    name: 'Chaco',
    alias: null,
  },
  {
    name: 'Chubut',
    alias: null,
  },
  {
    name: 'Córdoba',
    alias: [
      'Cordoba',
    ],
  },
  {
    name: 'Corrientes',
    alias: null,
  },
  {
    name: 'Entre Ríos',
    alias: [
      'Entre Rios',
    ],
  },
  {
    name: 'Formosa',
    alias: null,
  },
  {
    name: 'Jujuy',
    alias: null,
  },
  {
    name: 'La Pampa',
    alias: null,
  },
  {
    name: 'La Rioja',
    alias: null,
  },
  {
    name: 'Mendoza',
    alias: null,
  },
  {
    name: 'Misiones',
    alias: null,
  },
  {
    name: 'Neuquén',
    alias: [
      'Neuquen',
    ],
  },
  {
    name: 'Río Negro',
    alias: [
      'Rio Negro',
    ],
  },
  {
    name: 'Salta',
    alias: null,
  },
  {
    name: 'San Juan',
    alias: null,
  },
  {
    name: 'San Luis',
    alias: null,
  },
  {
    name: 'Santa Cruz',
    alias: null,
  },
  {
    name: 'Santa Fe',
    alias: null,
  },
  {
    name: 'Santiago del Estero',
    alias: null,
  },
  {
    name: 'Tierra del Fuego, Antártida e Islas del Atlántico Sur',
    alias: [
      'Tierra del Fuego, Antartida e Islas del Atlantico Sur',
    ],
  },
  {
    name: 'Tucumán',
    alias: [
      'Tucuman',
    ],
  },
];
const AT$1 = [
  {
    short: 'B',
    name: 'Burgenland',
    alias: null,
  },
  {
    short: 'K',
    name: 'Kärnten',
    alias: [
      'Karnten',
    ],
  },
  {
    short: 'NÖ',
    name: 'Niederösterreich',
    alias: [
      'Niederosterreich',
    ],
  },
  {
    short: 'OÖ',
    name: 'Oberösterreich',
    alias: [
      'Oberosterreich',
    ],
  },
  {
    short: 'S',
    name: 'Salzburg',
    alias: null,
  },
  {
    short: 'ST',
    name: 'Steiermark',
    alias: null,
  },
  {
    short: 'T',
    name: 'Tirol',
    alias: null,
  },
  {
    short: 'V',
    name: 'Vorarlberg',
    alias: null,
  },
  {
    short: 'W',
    name: 'Wien',
    alias: null,
  },
];
const AU$1 = [
  {
    name: 'Ashmore and Cartier Islands',
    alias: null,
  },
  {
    name: 'Australian Antarctic Territory',
    alias: null,
  },
  {
    short: 'ACT',
    name: 'Australian Capital Territory',
    alias: null,
  },
  {
    short: 'CX',
    name: 'Christmas Island',
    alias: null,
  },
  {
    short: 'CC',
    name: 'Cocos Islands',
    alias: [
      'Keeling Islands',
    ],
  },
  {
    name: 'Coral Sea Islands',
    alias: null,
  },
  {
    short: 'HM',
    name: 'Heard Island and McDonald Islands',
    alias: null,
  },
  {
    short: 'JBT',
    name: 'Jervis Bay Territory',
    alias: null,
  },
  {
    short: 'NSW',
    name: 'New South Wales',
    alias: null,
  },
  {
    short: 'NF',
    name: 'Norfolk Island',
    alias: null,
  },
  {
    short: 'NT',
    name: 'Northern Territory',
    alias: null,
  },
  {
    short: 'QLD',
    name: 'Queensland',
    alias: null,
  },
  {
    short: 'SA',
    name: 'South Australia',
    alias: null,
  },
  {
    short: 'TAS',
    name: 'Tasmania',
    alias: null,
  },
  {
    short: 'VIC',
    name: 'Victoria',
    alias: null,
  },
  {
    short: 'WA',
    name: 'Western Australia',
    alias: null,
  },
];
const BD$1 = [
  {
    name: 'বরগুনা',
    region: 'Barisal',
    alias: [
      'Barguna',
    ],
  },
  {
    name: 'বরিশাল',
    region: 'Barisal',
    alias: [
      'Barisal',
    ],
  },
  {
    name: 'ভোলা',
    region: 'Barisal',
    alias: [
      'Bhola',
    ],
  },
  {
    name: 'ঝালকাঠি',
    region: 'Barisal',
    alias: [
      'Jhalokati',
    ],
  },
  {
    name: 'পটুয়াখালী',
    region: 'Barisal',
    alias: [
      'Patuakhali',
    ],
  },
  {
    name: 'পিরোজপুর',
    region: 'Barisal',
    alias: [
      'Pirojpur',
    ],
  },
  {
    name: 'বান্দরবান',
    region: 'Chittagong',
    alias: [
      'Bandarban',
    ],
  },
  {
    name: 'ব্রাহ্মণবাড়ীয়া',
    region: 'Chittagong',
    alias: [
      'Brahmanbaria',
    ],
  },
  {
    name: 'চাঁদপুর',
    region: 'Chittagong',
    alias: [
      'Chandpur',
    ],
  },
  {
    name: 'চট্টগ্রাম',
    region: 'Chittagong',
    alias: [
      'Chittagong',
    ],
  },
  {
    name: 'কুমিল্লা',
    region: 'Chittagong',
    alias: [
      'Comilla',
    ],
  },
  {
    name: 'কক্সবাজার',
    region: 'Chittagong',
    alias: [
      "Cox's Bazar",
    ],
  },
  {
    name: 'ফেনী',
    region: 'Chittagong',
    alias: [
      'Feni',
    ],
  },
  {
    name: 'খাগড়াছড়ি',
    region: 'Chittagong',
    alias: [
      'Khagrachhari',
    ],
  },
  {
    name: 'লক্ষীপুর',
    region: 'Chittagong',
    alias: [
      'Lakshmipur',
    ],
  },
  {
    name: 'নোয়াখালী',
    region: 'Chittagong',
    alias: [
      'Noakhali',
    ],
  },
  {
    name: 'রাঙ্গামাটি',
    region: 'Chittagong',
    alias: [
      'Rangamati',
    ],
  },
  {
    name: 'ঢাকা',
    region: 'Dhaka',
    alias: [
      'Dhaka',
    ],
  },
  {
    name: 'ফরিদপুর',
    region: 'Dhaka',
    alias: [
      'Faridpur',
    ],
  },
  {
    name: 'গাজীপুর',
    region: 'Dhaka',
    alias: [
      'Gazipur',
    ],
  },
  {
    name: 'গোপালগঞ্জ',
    region: 'Dhaka',
    alias: [
      'Gopalganj',
    ],
  },
  {
    name: 'জামালপুর',
    region: 'Dhaka',
    alias: [
      'Jamalpur',
    ],
  },
  {
    name: 'কিশোরগঞ্জ',
    region: 'Dhaka',
    alias: [
      'Kishoreganj',
    ],
  },
  {
    name: 'মাদারীপুর',
    region: 'Dhaka',
    alias: [
      'Madaripur',
    ],
  },
  {
    name: 'মানিকগঞ্জ',
    region: 'Dhaka',
    alias: [
      'Manikganj',
    ],
  },
  {
    name: 'মুন্সীগঞ্জ',
    region: 'Dhaka',
    alias: [
      'Munshiganj',
    ],
  },
  {
    name: 'ময়মনসিংহ',
    region: 'Dhaka',
    alias: [
      'Mymensingh',
    ],
  },
  {
    name: 'নারায়ণগঞ্জ',
    region: 'Dhaka',
    alias: [
      'Narayanganj',
    ],
  },
  {
    name: 'নরসিংদী',
    region: 'Dhaka',
    alias: [
      'Narsingdi',
    ],
  },
  {
    name: 'নেত্রকোনা',
    region: 'Dhaka',
    alias: [
      'Netrakona',
    ],
  },
  {
    name: 'রাজবাড়ী',
    region: 'Dhaka',
    alias: [
      'Rajbari',
    ],
  },
  {
    name: 'শরীয়তপুর',
    region: 'Dhaka',
    alias: [
      'Shariatpur',
    ],
  },
  {
    name: 'শেরপুর',
    region: 'Dhaka',
    alias: [
      'Sherpur',
    ],
  },
  {
    name: 'টাঙ্গাইল',
    region: 'Dhaka',
    alias: [
      'Tangail',
    ],
  },
  {
    name: 'বাগেরহাট',
    region: 'Khulna',
    alias: [
      'Bagerhat',
    ],
  },
  {
    name: 'চুয়াডাঙ্গা',
    region: 'Khulna',
    alias: [
      'Chuadanga',
    ],
  },
  {
    name: 'যশোর',
    region: 'Khulna',
    alias: [
      'Jessore',
    ],
  },
  {
    name: 'ঝিনাইদহ',
    region: 'Khulna',
    alias: [
      'Jhenaidah',
    ],
  },
  {
    name: 'খুলনা',
    region: 'Khulna',
    alias: [
      'Khulna',
    ],
  },
  {
    name: 'কুষ্টিয়া',
    region: 'Khulna',
    alias: [
      'Kushtia',
    ],
  },
  {
    name: 'মাগুরা',
    region: 'Khulna',
    alias: [
      'Magura',
    ],
  },
  {
    name: 'মেহেরপুর',
    region: 'Khulna',
    alias: [
      'Meherpur',
    ],
  },
  {
    name: 'নড়াইল',
    region: 'Khulna',
    alias: [
      'Narail',
    ],
  },
  {
    name: 'সাতক্ষিরা',
    region: 'Khulna',
    alias: [
      'Satkhira',
    ],
  },
  {
    name: 'বগুড়া',
    region: 'Rajshahi',
    alias: [
      'Bogra',
    ],
  },
  {
    name: 'জয়পুরহাট',
    region: 'Rajshahi',
    alias: [
      'Joypurhat',
    ],
  },
  {
    name: 'নওগাঁ',
    region: 'Rajshahi',
    alias: [
      'Naogaon',
    ],
  },
  {
    name: 'নাটোর',
    region: 'Rajshahi',
    alias: [
      'Natore',
    ],
  },
  {
    name: 'নওয়াবগঞ্জ',
    region: 'Rajshahi',
    alias: [
      'Chapainawabganj',
    ],
  },
  {
    name: 'পাবনা',
    region: 'Rajshahi',
    alias: [
      'Pabna',
    ],
  },
  {
    name: 'রাজশাহী',
    region: 'Rajshahi',
    alias: [
      'Rajshahi',
    ],
  },
  {
    name: 'সিরাজগঞ্জ',
    region: 'Rajshahi',
    alias: [
      'Sirajganj',
    ],
  },
  {
    name: 'দিনাজপুর',
    region: 'Rangpur',
    alias: [
      'Dinajpur',
    ],
  },
  {
    name: 'গাইবান্ধা',
    region: 'Rangpur',
    alias: [
      'Gaibandha',
    ],
  },
  {
    name: 'কুড়িগ্রাম',
    region: 'Rangpur',
    alias: [
      'Kurigram',
    ],
  },
  {
    name: 'লালমনিরহাট',
    region: 'Rangpur',
    alias: [
      'Lalmonirhat',
    ],
  },
  {
    name: 'নীলফামারী',
    region: 'Rangpur',
    alias: [
      'Nilphamari',
    ],
  },
  {
    name: 'পঞ্চগড়',
    region: 'Rangpur',
    alias: [
      'Panchagarh',
    ],
  },
  {
    name: 'রংপুর',
    region: 'Rangpur',
    alias: [
      'Rangpur',
    ],
  },
  {
    name: 'ঠাকুরগাঁ',
    region: 'Rangpur',
    alias: [
      'Thakurgaon',
    ],
  },
  {
    name: 'হবিগঞ্জ',
    region: 'Sylhet',
    alias: [
      'Habiganj',
    ],
  },
  {
    name: 'মৌলভীবাজার',
    region: 'Sylhet',
    alias: [
      'Moulvibazar',
    ],
  },
  {
    name: 'সুনামগঞ্জ',
    region: 'Sylhet',
    alias: [
      'Sunamganj',
    ],
  },
  {
    name: 'সিলেট',
    region: 'Sylhet',
    alias: [
      'Sylhet',
    ],
  },
];
const BE$1 = [
  {
    short: 'ANT',
    name: 'Antwerpen',
    alias: null,
  },
  {
    short: 'HAI',
    name: 'Henegouwen',
    alias: [
      'Hainaut',
    ],
  },
  {
    short: 'LIE',
    name: 'Luik',
    alias: [
      'Liège',
      'Liege',
    ],
  },
  {
    short: 'LIM',
    name: 'Limburg',
    alias: null,
  },
  {
    short: 'LUX',
    name: 'Luxemburg',
    alias: null,
  },
  {
    short: 'NAM',
    name: 'Namen',
    alias: null,
  },
  {
    short: 'OVL',
    name: 'Oost-Vlaanderen',
    alias: [
      'Oost Vlaanderen',
    ],
  },
  {
    short: 'VBR',
    name: 'Vlaams-Brabant',
    alias: [
      'Vlaams Brabant',
    ],
  },
  {
    short: 'WBR',
    name: 'Waals-Brabant',
    alias: [
      'Waals Brabant',
    ],
  },
  {
    short: 'WVL',
    name: 'West-Vlaanderen',
    alias: [
      'West Vlaanderen',
    ],
  },
];
const BO$1 = [
  {
    name: 'Cercado',
    region: 'Beni',
    alias: null,
  },
  {
    name: 'Iténez',
    region: 'Beni',
    alias: [
      'Itenez',
    ],
  },
  {
    name: 'José Ballivián',
    region: 'Beni',
    alias: [
      'Jose Ballivian',
    ],
  },
  {
    name: 'Mamoré',
    region: 'Beni',
    alias: [
      'Mamore',
    ],
  },
  {
    name: 'Marbán',
    region: 'Beni',
    alias: [
      'Marban',
    ],
  },
  {
    name: 'Moxos',
    region: 'Beni',
    alias: null,
  },
  {
    name: 'Vaca Díez',
    region: 'Beni',
    alias: [
      'Vaca Diez',
    ],
  },
  {
    name: 'Yacuma',
    region: 'Beni',
    alias: null,
  },
  {
    name: 'Azurduy',
    region: 'Chuquisaca',
    alias: null,
  },
  {
    name: 'Belisario Boeto',
    region: 'Chuquisaca',
    alias: null,
  },
  {
    name: 'Hernando Siles',
    region: 'Chuquisaca',
    alias: null,
  },
  {
    name: 'Jaime Zudáñez',
    region: 'Chuquisaca',
    alias: [
      'Jaime Zudanez',
    ],
  },
  {
    name: 'Luis Calvo',
    region: 'Chuquisaca',
    alias: null,
  },
  {
    name: 'Nor Cinti',
    region: 'Chuquisaca',
    alias: null,
  },
  {
    name: 'Oropeza',
    region: 'Chuquisaca',
    alias: null,
  },
  {
    name: 'Sud Cinti',
    region: 'Chuquisaca',
    alias: null,
  },
  {
    name: 'Tomina',
    region: 'Chuquisaca',
    alias: null,
  },
  {
    name: 'Yamparáez',
    region: 'Chuquisaca',
    alias: [
      'Yamparaez',
    ],
  },
  {
    name: 'Arani',
    region: 'Cochabamba',
    alias: null,
  },
  {
    name: 'Arque',
    region: 'Cochabamba',
    alias: null,
  },
  {
    name: 'Ayopaya',
    region: 'Cochabamba',
    alias: null,
  },
  {
    name: 'Capinota',
    region: 'Cochabamba',
    alias: null,
  },
  {
    name: 'Carrasco',
    region: 'Cochabamba',
    alias: null,
  },
  {
    name: 'Cercado',
    region: 'Cochabamba',
    alias: null,
  },
  {
    name: 'Chapare',
    region: 'Cochabamba',
    alias: null,
  },
  {
    name: 'Esteban Arce',
    region: 'Cochabamba',
    alias: null,
  },
  {
    name: 'Germán Jordán',
    region: 'Cochabamba',
    alias: [
      'German Jordan',
    ],
  },
  {
    name: 'Mizque',
    region: 'Cochabamba',
    alias: null,
  },
  {
    name: 'Campero',
    region: 'Cochabamba',
    alias: null,
  },
  {
    name: 'Punata',
    region: 'Cochabamba',
    alias: null,
  },
  {
    name: 'Quillacollo',
    region: 'Cochabamba',
    alias: null,
  },
  {
    name: 'Bolívar',
    region: 'Cochabamba',
    alias: [
      'Bolivar',
    ],
  },
  {
    name: 'Tapacarí',
    region: 'Cochabamba',
    alias: [
      'Tapacari',
    ],
  },
  {
    name: 'Tiraque',
    region: 'Cochabamba',
    alias: null,
  },
  {
    name: 'Abel Iturralde',
    region: 'La Paz',
    alias: null,
  },
  {
    name: 'Aroma',
    region: 'La Paz',
    alias: null,
  },
  {
    name: 'Bautista Saavedra',
    region: 'La Paz',
    alias: null,
  },
  {
    name: 'Caranavi',
    region: 'La Paz',
    alias: null,
  },
  {
    name: 'Eliodoro Camacho',
    region: 'La Paz',
    alias: null,
  },
  {
    name: 'Franz Tamayo',
    region: 'La Paz',
    alias: null,
  },
  {
    name: 'Gualberto Villarroel',
    region: 'La Paz',
    alias: null,
  },
  {
    name: 'Ingavi',
    region: 'La Paz',
    alias: null,
  },
  {
    name: 'Inquisivi',
    region: 'La Paz',
    alias: null,
  },
  {
    name: 'José Manuel Pando',
    region: 'La Paz',
    alias: [
      'Jose Manuel Pando',
    ],
  },
  {
    name: 'Larecaja',
    region: 'La Paz',
    alias: null,
  },
  {
    name: 'Loayza',
    region: 'La Paz',
    alias: null,
  },
  {
    name: 'Los Andes',
    region: 'La Paz',
    alias: null,
  },
  {
    name: 'Manco Kapac',
    region: 'La Paz',
    alias: null,
  },
  {
    name: 'Muñecas',
    region: 'La Paz',
    alias: [
      'Munecas',
    ],
  },
  {
    name: 'Nor Yungas',
    region: 'La Paz',
    alias: null,
  },
  {
    name: 'Omasuyos',
    region: 'La Paz',
    alias: null,
  },
  {
    name: 'Pacajes',
    region: 'La Paz',
    alias: null,
  },
  {
    name: 'Murillo',
    region: 'La Paz',
    alias: null,
  },
  {
    name: 'Sud Yungas',
    region: 'La Paz',
    alias: null,
  },
  {
    name: 'Atahuallpa',
    region: 'Oruro',
    alias: null,
  },
  {
    name: 'Carangas',
    region: 'Oruro',
    alias: null,
  },
  {
    name: 'Cercado',
    region: 'Oruro',
    alias: null,
  },
  {
    name: 'Eduardo Avaroa',
    region: 'Oruro',
    alias: null,
  },
  {
    name: 'Ladislao Cabrera',
    region: 'Oruro',
    alias: null,
  },
  {
    name: 'Litoral',
    region: 'Oruro',
    alias: null,
  },
  {
    name: 'Nor Carangas',
    region: 'Oruro',
    alias: null,
  },
  {
    name: 'Pantaléon Dalence',
    region: 'Oruro',
    alias: [
      'Pantaleon Dalence',
    ],
  },
  {
    name: 'Poopó',
    region: 'Oruro',
    alias: [
      'Poopo',
    ],
  },
  {
    name: 'Puerto de Mejillones',
    region: 'Oruro',
    alias: null,
  },
  {
    name: 'Sajama',
    region: 'Oruro',
    alias: null,
  },
  {
    name: 'San Pedro de Totora',
    region: 'Oruro',
    alias: null,
  },
  {
    name: 'Saucarí',
    region: 'Oruro',
    alias: [
      'Saucari',
    ],
  },
  {
    name: 'Sebastián Pagador',
    region: 'Oruro',
    alias: [
      'Sebastian Pagador',
    ],
  },
  {
    name: 'Sud Carangas',
    region: 'Oruro',
    alias: null,
  },
  {
    name: 'Tomas Barrón',
    region: 'Oruro',
    alias: [
      'Tomas Barron',
    ],
  },
  {
    name: 'Abuná',
    region: 'Pando',
    alias: [
      'Abuna',
    ],
  },
  {
    name: 'Federico Román',
    region: 'Pando',
    alias: [
      'Federico Roman',
    ],
  },
  {
    name: 'Madre de Dios',
    region: 'Pando',
    alias: null,
  },
  {
    name: 'Manuripi',
    region: 'Pando',
    alias: null,
  },
  {
    name: 'Nicolás Suárez',
    region: 'Pando',
    alias: [
      'Nicolas Suarez',
    ],
  },
  {
    name: 'Alonso de Ibáñez',
    region: 'Potosí',
    alias: [
      'Alonso de Ibanez',
    ],
  },
  {
    name: 'Antonio Quijarro',
    region: 'Potosí',
    alias: null,
  },
  {
    name: 'Bernardino Bilbao',
    region: 'Potosí',
    alias: null,
  },
  {
    name: 'Charcas',
    region: 'Potosí',
    alias: null,
  },
  {
    name: 'Chayanta',
    region: 'Potosí',
    alias: null,
  },
  {
    name: 'Cornelio Saavedra',
    region: 'Potosí',
    alias: null,
  },
  {
    name: 'Daniel Campos',
    region: 'Potosí',
    alias: null,
  },
  {
    name: 'Enrique Baldivieso',
    region: 'Potosí',
    alias: null,
  },
  {
    name: 'José María Linares',
    region: 'Potosí',
    alias: [
      'José Maria Linares',
    ],
  },
  {
    name: 'Modesto Omiste',
    region: 'Potosí',
    alias: null,
  },
  {
    name: 'Nor Chichas',
    region: 'Potosí',
    alias: null,
  },
  {
    name: 'Nor Lípez',
    region: 'Potosí',
    alias: [
      'Nor Lipez',
    ],
  },
  {
    name: 'Rafael Bustillo',
    region: 'Potosí',
    alias: null,
  },
  {
    name: 'Sur Chichas',
    region: 'Potosí',
    alias: null,
  },
  {
    name: 'Sur Lípez',
    region: 'Potosí',
    alias: [
      'Sur Lipez',
    ],
  },
  {
    name: 'Tomás Frías',
    region: 'Potosí',
    alias: [
      'Tomas Frias',
    ],
  },
  {
    name: 'Andrés Ibáñez',
    region: 'Santa Cruz',
    alias: [
      'Andres Ibanez',
    ],
  },
  {
    name: 'Ángel Sandoval',
    region: 'Santa Cruz',
    alias: [
      'Angel Sandoval',
    ],
  },
  {
    name: 'Chiquitos',
    region: 'Santa Cruz',
    alias: null,
  },
  {
    name: 'Cordillera',
    region: 'Santa Cruz',
    alias: null,
  },
  {
    name: 'Florida',
    region: 'Santa Cruz',
    alias: null,
  },
  {
    name: 'Germán Busch',
    region: 'Santa Cruz',
    alias: [
      'German Busch',
    ],
  },
  {
    name: 'Guarayos',
    region: 'Santa Cruz',
    alias: null,
  },
  {
    name: 'Ichilo',
    region: 'Santa Cruz',
    alias: null,
  },
  {
    name: 'Ignacio Warnes',
    region: 'Santa Cruz',
    alias: null,
  },
  {
    name: 'José Miguel de Velasco',
    region: 'Santa Cruz',
    alias: [
      'Jose Miguel de Velasco',
    ],
  },
  {
    name: 'Manuel María Caballero',
    region: 'Santa Cruz',
    alias: [
      'Manuel Maria Caballero',
    ],
  },
  {
    name: 'Ñuflo de Chávez',
    region: 'Santa Cruz',
    alias: [
      'Nuflo de Chavez',
    ],
  },
  {
    name: 'Obispo Santistevan',
    region: 'Santa Cruz',
    alias: null,
  },
  {
    name: 'Sara',
    region: 'Santa Cruz',
    alias: null,
  },
  {
    name: 'Vallegrande',
    region: 'Santa Cruz',
    alias: null,
  },
  {
    name: 'Aniceto Arce',
    region: 'Tarija',
    alias: null,
  },
  {
    name: "Burnet O'Connor",
    region: 'Tarija',
    alias: null,
  },
  {
    name: 'Cercado',
    region: 'Tarija',
    alias: null,
  },
  {
    name: 'Eustaquio Méndez',
    region: 'Tarija',
    alias: [
      'Eustaquio Mendez',
    ],
  },
  {
    name: 'Gran Chaco',
    region: 'Tarija',
    alias: null,
  },
  {
    name: 'José María Avilés',
    region: 'Tarija',
    alias: [
      'Jose María Aviles',
    ],
  },
];
const BR$1 = [
  {
    short: 'AC',
    name: 'Acre',
    alias: null,
  },
  {
    short: 'AL',
    name: 'Alagoas',
    alias: null,
  },
  {
    short: 'AP',
    name: 'Amapá',
    alias: [
      'Amapa',
    ],
  },
  {
    short: 'AM',
    name: 'Amazonas',
    alias: null,
  },
  {
    short: 'BA',
    name: 'Bahia',
    alias: null,
  },
  {
    short: 'CE',
    name: 'Ceará',
    alias: [
      'Ceara',
    ],
  },
  {
    short: 'DF',
    name: 'Distrito Federal',
    alias: null,
  },
  {
    short: 'ES',
    name: 'Espírito Santo',
    alias: [
      'Espirito Santo',
    ],
  },
  {
    short: 'GO',
    name: 'Goiás',
    alias: [
      'Goias',
    ],
  },
  {
    short: 'MA',
    name: 'Maranhão',
    alias: [
      'Maranhao',
    ],
  },
  {
    short: 'MT',
    name: 'Mato Grosso',
    alias: null,
  },
  {
    short: 'MS',
    name: 'Mato Grosso do Sul',
    alias: null,
  },
  {
    short: 'MG',
    name: 'Minas Gerais',
    alias: null,
  },
  {
    short: 'PA',
    name: 'Pará',
    alias: [
      'Para',
    ],
  },
  {
    short: 'PB',
    name: 'Paraíba',
    alias: [
      'Paraiba',
    ],
  },
  {
    short: 'PR',
    name: 'Paraná',
    alias: [
      'Parana',
    ],
  },
  {
    short: 'PE',
    name: 'Pernambuco',
    alias: null,
  },
  {
    short: 'PI',
    name: 'Piauí',
    alias: [
      'Piaui',
    ],
  },
  {
    short: 'RJ',
    name: 'Rio de Janeiro',
    alias: null,
  },
  {
    short: 'RN',
    name: 'Rio Grande do Norte',
    alias: null,
  },
  {
    short: 'RS',
    name: 'Rio Grande do Sul',
    alias: null,
  },
  {
    short: 'RO',
    name: 'Rondônia',
    alias: [
      'Rondonia',
    ],
  },
  {
    short: 'RR',
    name: 'Roraima',
    alias: null,
  },
  {
    short: 'SC',
    name: 'Santa Catarina',
    alias: null,
  },
  {
    short: 'SP',
    name: 'São Paulo',
    alias: [
      'Sao Paulo',
    ],
  },
  {
    short: 'SE',
    name: 'Sergipe',
    alias: null,
  },
  {
    short: 'TO',
    name: 'Tocantins',
    alias: null,
  },
];
const CA$1 = [
  {
    short: 'AB',
    name: 'Alberta',
    alias: null,
  },
  {
    short: 'BC',
    name: 'British Columbia',
    alias: null,
  },
  {
    short: 'MB',
    name: 'Manitoba',
    alias: null,
  },
  {
    short: 'NB',
    name: 'New Brunswick',
    alias: null,
  },
  {
    short: 'NL',
    name: 'Newfoundland and Labrador',
    alias: [
      'Newfoundland',
      'Labrador',
    ],
  },
  {
    short: 'NS',
    name: 'Nova Scotia',
    alias: null,
  },
  {
    short: 'NU',
    name: 'Nunavut',
    alias: null,
  },
  {
    short: 'NT',
    name: 'Northwest Territories',
    alias: null,
  },
  {
    short: 'ON',
    name: 'Ontario',
    alias: null,
  },
  {
    short: 'PE',
    name: 'Prince Edward Island',
    alias: null,
  },
  {
    short: 'QC',
    name: 'Quebec',
    alias: null,
  },
  {
    short: 'SK',
    name: 'Saskatchewan',
    alias: null,
  },
  {
    short: 'YT',
    name: 'Yukon',
    alias: null,
  },
];
const CL$1 = [
  {
    name: 'Arica',
    region: 'XV Arica and Parinacota',
    alias: null,
  },
  {
    name: 'Parinacota',
    region: 'XV Arica and Parinacota',
    alias: null,
  },
  {
    name: 'Iquique',
    region: 'I Tarapacá',
    alias: null,
  },
  {
    name: 'Tamarugal',
    region: 'I Tarapacá',
    alias: null,
  },
  {
    name: 'Antofagasta',
    region: 'II Antofagasta',
    alias: null,
  },
  {
    name: 'El Loa',
    region: 'II Antofagasta',
    alias: null,
  },
  {
    name: 'Tocopilla',
    region: 'II Antofagasta',
    alias: null,
  },
  {
    name: 'Copiapó',
    region: 'III Atacama',
    alias: [
      'Copiapo',
    ],
  },
  {
    name: 'Huasco',
    region: 'III Atacama',
    alias: null,
  },
  {
    name: 'Chañaral',
    region: 'III Atacama',
    alias: [
      'Chanaral',
    ],
  },
  {
    name: 'Elqui',
    region: 'IV Coquimbo',
    alias: null,
  },
  {
    name: 'Limarí',
    region: 'IV Coquimbo',
    alias: [
      'Limari',
    ],
  },
  {
    name: 'Choapa',
    region: 'IV Coquimbo',
    alias: null,
  },
  {
    name: 'Isla de Pascua',
    region: 'V Valparaíso',
    alias: null,
  },
  {
    name: 'Los Andes',
    region: 'V Valparaíso',
    alias: null,
  },
  {
    name: 'Marga Marga',
    region: 'V Valparaíso',
    alias: null,
  },
  {
    name: 'Petorca',
    region: 'V Valparaíso',
    alias: null,
  },
  {
    name: 'Quillota',
    region: 'V Valparaíso',
    alias: null,
  },
  {
    name: 'San Antonio',
    region: 'V Valparaíso',
    alias: null,
  },
  {
    name: 'San Felipe de Aconcagua',
    region: 'V Valparaíso',
    alias: null,
  },
  {
    name: 'Valparaíso',
    region: 'V Valparaíso',
    alias: [
      'Valparaiso',
    ],
  },
  {
    name: 'Cachapoal',
    region: "VI O'Higgins",
    alias: null,
  },
  {
    name: 'Colchagua',
    region: "VI O'Higgins",
    alias: null,
  },
  {
    name: 'Cardenal Caro',
    region: "VI O'Higgins",
    alias: null,
  },
  {
    name: 'Talca',
    region: 'VII Maule',
    alias: null,
  },
  {
    name: 'Linares',
    region: 'VII Maule',
    alias: null,
  },
  {
    name: 'Curicó',
    region: 'VII Maule',
    alias: [
      'Curico',
    ],
  },
  {
    name: 'Cauquenes',
    region: 'VII Maule',
    alias: null,
  },
  {
    name: 'Concepción',
    region: 'VIII Biobío',
    alias: [
      'Concepcion',
    ],
  },
  {
    name: 'Ñuble',
    region: 'VIII Biobío',
    alias: [
      'Nuble',
    ],
  },
  {
    name: 'Biobío',
    region: 'VIII Biobío',
    alias: [
      'Biobio',
    ],
  },
  {
    name: 'Arauco',
    region: 'VIII Biobío',
    alias: null,
  },
  {
    name: 'Cautin',
    region: 'IX Araucanía',
    alias: null,
  },
  {
    name: 'Malleco',
    region: 'IX Araucanía',
    alias: null,
  },
  {
    name: 'Valdivia',
    region: 'XIV Los Ríos',
    alias: null,
  },
  {
    name: 'Ranco',
    region: 'XIV Los Ríos',
    alias: null,
  },
  {
    name: 'Llanquihue',
    region: 'X Los Lagos',
    alias: null,
  },
  {
    name: 'Osorno',
    region: 'X Los Lagos',
    alias: null,
  },
  {
    name: 'Chiloe',
    region: 'X Los Lagos',
    alias: null,
  },
  {
    name: 'Palena',
    region: 'X Los Lagos',
    alias: null,
  },
  {
    name: 'Coihaique',
    region: 'XI Aisén',
    alias: null,
  },
  {
    name: 'Aisén',
    region: 'XI Aisén',
    alias: [
      'Aisen',
    ],
  },
  {
    name: 'General Carrera',
    region: 'XI Aisén',
    alias: null,
  },
  {
    name: 'Capitan Prat',
    region: 'XI Aisén',
    alias: null,
  },
  {
    name: 'Magallanes',
    region: 'XII Magallanes',
    alias: null,
  },
  {
    name: 'Ultima Esperanza',
    region: 'XII Magallanes',
    alias: null,
  },
  {
    name: 'Tierra del Fuego',
    region: 'XII Magallanes',
    alias: null,
  },
  {
    name: 'Antártica Chilena',
    region: 'XII Magallanes',
    alias: [
      'Antartica Chilena',
    ],
  },
  {
    name: 'Santiago',
    region: 'RM Santiago Metropolitan',
    alias: null,
  },
  {
    name: 'Cordillera',
    region: 'RM Santiago Metropolitan',
    alias: null,
  },
  {
    name: 'Maipo',
    region: 'RM Santiago Metropolitan',
    alias: null,
  },
  {
    name: 'Talagante',
    region: 'RM Santiago Metropolitan',
    alias: null,
  },
  {
    name: 'Melipilla',
    region: 'RM Santiago Metropolitan',
    alias: null,
  },
  {
    name: 'Chacabuco',
    region: 'RM Santiago Metropolitan',
    alias: null,
  },
];
const CN$1 = [
  {
    name: 'Chongqing',
    short: 'CQ',
    alias: [
      '重庆',
      '渝',
      'Chongqing Shi',
    ],
  },
  {
    name: 'Heilongjiang',
    short: 'HL',
    alias: [
      '黑龙江',
      '黑',
      'Heilongjiang Sheng',
    ],
  },
  {
    name: 'Jilin',
    short: 'JL',
    alias: [
      '吉林',
      '吉',
      'Jilin Sheng',
    ],
  },
  {
    name: 'Hainan',
    short: 'HI',
    alias: [
      '海南',
      '琼',
      'Hainan Sheng',
    ],
  },
  {
    name: 'Beijing',
    short: 'BJ',
    alias: [
      '北京',
      '京',
      'Beijing Shi',
    ],
  },
  {
    name: 'Liaoning',
    short: 'LN',
    alias: [
      '辽宁',
      '辽',
      'Liaoning Sheng',
    ],
  },
  {
    name: 'Inner Mongolia',
    short: 'NM',
    alias: [
      '内蒙古',
      '蒙',
      'Nei Menggu Zizhiqu',
    ],
  },
  {
    name: 'Tibet',
    short: 'XZ',
    alias: [
      'Xizang',
      '西藏',
      '藏',
      'Xizang Zizhiqu',
    ],
  },
  {
    name: 'Qinghai',
    short: 'QH',
    alias: [
      '青海',
      '青',
      'Qinghai Sheng',
    ],
  },
  {
    name: 'Ningxia',
    short: 'NX',
    alias: [
      '宁夏',
      '宁',
      'Ningxia Huizu Zizhiqu',
    ],
  },
  {
    name: 'Xinjiang',
    short: 'XJ',
    alias: [
      '新疆',
      '新',
      'Xinjiang Weiwuer Zizhiqu',
    ],
  },
  {
    name: 'Gansu',
    short: 'GS',
    alias: [
      '甘肃',
      '甘',
      'Gansu Sheng',
    ],
  },
  {
    name: 'Hebei',
    short: 'HE',
    alias: [
      '河北',
      '冀',
      'Hebei Sheng',
    ],
  },
  {
    name: 'Henan',
    short: 'HA',
    alias: [
      '河南',
      '豫',
      'Henan Sheng',
    ],
  },
  {
    name: 'Hubei',
    short: 'HB',
    alias: [
      '湖北',
      '鄂',
      'Hubei Sheng',
    ],
  },
  {
    name: 'Hunan',
    short: 'HN',
    alias: [
      '湖南',
      '湘',
      'Hunan Sheng',
    ],
  },
  {
    name: 'Shandong',
    short: 'SD',
    alias: [
      '山东',
      '鲁',
      'Shandong Sheng',
    ],
  },
  {
    name: 'Jiangsu',
    short: 'JS',
    alias: [
      '江苏',
      '苏',
      'Jiangsu Sheng',
    ],
  },
  {
    name: 'Anhui',
    short: 'AH',
    alias: [
      '安徽',
      '皖',
      'Anhui Sheng',
    ],
  },
  {
    name: 'Shanxi',
    short: 'SX',
    alias: [
      '山西',
      '晋',
      'Shānxī Sheng',
    ],
  },
  {
    name: 'Shaanxi',
    short: 'SN',
    alias: [
      '陕西',
      '陕',
      'Shǎnxī Sheng',
    ],
  },
  {
    name: 'Sichuan',
    short: 'SC',
    alias: [
      '四川',
      '川',
      'Sichuan Sheng',
    ],
  },
  {
    name: 'Yunnan',
    short: 'YN',
    alias: [
      '云南',
      '滇',
      'Yunnan Sheng',
    ],
  },
  {
    name: 'Guizhou',
    short: 'GZ',
    alias: [
      '贵州',
      '黔',
      'Guizhou Sheng',
    ],
  },
  {
    name: 'Zhejiang',
    short: 'ZJ',
    alias: [
      '浙江',
      '浙',
      'Zhejiang Sheng',
    ],
  },
  {
    name: 'Fujian',
    short: 'FJ',
    alias: [
      '福建',
      '闽',
      'Fujian Sheng',
    ],
  },
  {
    name: 'Guangxi',
    short: 'GX',
    alias: [
      '广西',
      '桂',
      'Guangxi Zhuangzu Zizhiqu',
    ],
  },
  {
    name: 'Shanghai',
    short: 'SH',
    alias: [
      '上海',
      '沪',
      'Shanghai Shi',
    ],
  },
  {
    name: 'Tianjin',
    short: 'TJ',
    alias: [
      '天津',
      '津',
      'Tianjin Shi',
    ],
  },
  {
    name: 'Hong Kong',
    short: 'HK',
    alias: [
      'Xianggang',
      '香港',
      '港',
      'Xianggang Tebie Xingzhengqu',
    ],
  },
  {
    name: 'Macau',
    short: 'MC',
    alias: [
      'Aomen',
      '澳门',
      '澳',
      'Aomen Tebie Xingzhengqu',
    ],
  },
  {
    name: 'Taiwan',
    short: 'TW',
    alias: [
      '台湾',
      '台',
      'Taiwan Shi',
    ],
  },
  {
    name: 'Jiangxi',
    short: 'JX ',
    alias: [
      '江西',
      '赣',
      'Jiangxi Sheng',
    ],
  },
  {
    name: 'Guangdong',
    short: 'GD',
    alias: [
      '广东',
      '粤',
      'Guangdong Sheng',
    ],
  },
];
const CU$1 = [
  {
    name: 'Camagüey',
    alias: [
      'Camaguey',
    ],
  },
  {
    name: 'Ciego de Ávila',
    alias: [
      'Ciego de Avila',
    ],
  },
  {
    name: 'Cienfuegos',
    alias: null,
  },
  {
    name: 'Havana',
    alias: null,
  },
  {
    name: 'Bayamo',
    alias: null,
  },
  {
    name: 'Guantánamo',
    alias: [
      'Guantanamo',
    ],
  },
  {
    name: 'Holguín',
    alias: [
      'Holguin',
    ],
  },
  {
    name: 'Nueva Gerona',
    alias: null,
  },
  {
    name: 'Artemisa',
    alias: null,
  },
  {
    name: 'Las Tunas',
    alias: null,
  },
  {
    name: 'Matanzas',
    alias: null,
  },
  {
    name: 'San José de las Lajas',
    alias: [
      'San Jose de las Lajas',
    ],
  },
  {
    name: 'Pinar del Río',
    alias: [
      'Pinar del Rio',
    ],
  },
  {
    name: 'Sancti Spíritus',
    alias: [
      'Sancti Spiritus',
    ],
  },
  {
    name: 'Santiago de Cuba',
    alias: null,
  },
  {
    name: 'Santa Clara',
    alias: null,
  },
];
const DE$1 = [
  {
    short: 'BW',
    name: 'Baden-Württemberg',
    alias: [
      'Baden-Wurttemberg',
      'Baden Württemberg',
      'Baden Wurttemberg',
    ],
  },
  {
    short: 'BY',
    name: 'Bayern',
    alias: null,
  },
  {
    short: 'BE',
    name: 'Berlin',
    alias: null,
  },
  {
    short: 'BB',
    name: 'Brandenburg',
    alias: null,
  },
  {
    short: 'HB',
    name: 'Bremen',
    alias: null,
  },
  {
    short: 'HH',
    name: 'Hamburg',
    alias: null,
  },
  {
    short: 'HE',
    name: 'Hessen',
    alias: null,
  },
  {
    short: 'MV',
    name: 'Mecklenburg-Vorpommern',
    alias: [
      'Mecklenburg Vorpommern',
    ],
  },
  {
    short: 'NI',
    name: 'Niedersachsen',
    alias: null,
  },
  {
    short: 'NW',
    name: 'Nordrhein-Westfalen',
    alias: [
      'Nordrhein Westfalen',
    ],
  },
  {
    short: 'RP',
    name: 'Rheinland-Pfalz',
    alias: [
      'Rheinland Pfalz',
    ],
  },
  {
    short: 'SL',
    name: 'Saarland',
    alias: null,
  },
  {
    short: 'SN',
    name: 'Sachsen',
    alias: null,
  },
  {
    short: 'ST',
    name: 'Sachsen-Anhalt',
    alias: [
      'Sachsen Anhalt',
    ],
  },
  {
    short: 'SH',
    name: 'Schleswig-Holstein',
    alias: [
      'Schleswig Holstein',
    ],
  },
  {
    short: 'TH',
    name: 'Thüringen',
    alias: [
      'Thuringen',
    ],
  },
];
const DK$1 = [
  {
    name: 'Hovedstaden',
    alias: null,
  },
  {
    name: 'Midtjylland',
    alias: null,
  },
  {
    name: 'Nordjylland',
    alias: null,
  },
  {
    name: 'Sjælland',
    alias: [
      'Zealand',
    ],
  },
  {
    name: 'Syddanmark',
    alias: null,
  },
];
const ES$1 = [
  {
    name: 'La Coruña',
    short: 'C',
    alias: [
      'La Coruna',
    ],
  },
  {
    name: 'Lugo',
    short: 'LU',
    alias: null,
  },
  {
    name: 'Vizcaya',
    short: 'BI',
    alias: null,
  },
  {
    name: 'Guipúzcoa',
    short: 'SS',
    alias: [
      'Guipuzcoa',
    ],
  },
  {
    name: 'Huesca',
    short: 'HU',
    alias: null,
  },
  {
    name: 'Lérida',
    short: 'L',
    alias: [
      'Lerida',
    ],
  },
  {
    name: 'Gerona',
    short: 'GI',
    alias: null,
  },
  {
    name: 'Barcelona',
    short: 'B',
    alias: null,
  },
  {
    name: 'Tarragona',
    short: 'T',
    alias: null,
  },
  {
    name: 'Castellón',
    short: 'CS',
    alias: [
      'Castellon',
    ],
  },
  {
    name: 'Valencia',
    short: 'V',
    alias: null,
  },
  {
    name: 'Alicante',
    short: 'A',
    alias: null,
  },
  {
    name: 'Murcia',
    short: 'MU',
    alias: null,
  },
  {
    name: 'Zaragoza',
    short: 'Z',
    alias: null,
  },
  {
    name: 'Teruel',
    short: 'TE',
    alias: null,
  },
  {
    name: 'Cuenca',
    short: 'CU',
    alias: null,
  },
  {
    name: 'Albacete',
    short: 'AB',
    alias: null,
  },
  {
    name: 'Almeria',
    short: 'AL',
    alias: null,
  },
  {
    name: 'Granada',
    short: 'GR',
    alias: null,
  },
  {
    name: 'Málaga',
    short: 'MA',
    alias: [
      'Malaga',
    ],
  },
  {
    name: 'Tenerife',
    short: 'TF',
    alias: null,
  },
  {
    name: 'Cádiz',
    short: 'CA',
    alias: [
      'Cadiz',
    ],
  },
  {
    name: 'Sevilla',
    short: 'SE',
    alias: null,
  },
  {
    name: 'Huelva',
    short: 'H',
    alias: null,
  },
  {
    name: 'Las Palmas',
    short: 'GC',
    alias: null,
  },
  {
    name: 'Madrid',
    short: 'M',
    alias: null,
  },
  {
    name: 'Badajoz',
    short: 'BA',
    alias: null,
  },
  {
    name: 'Cáceres',
    short: 'CC',
    alias: [
      'Caceres',
    ],
  },
  {
    name: 'Toledo',
    short: 'TO',
    alias: null,
  },
  {
    name: 'Ciudad Real',
    short: 'CR',
    alias: null,
  },
  {
    name: 'Salamanca',
    short: 'SA',
    alias: null,
  },
  {
    name: 'Córdoba',
    short: 'CO',
    alias: [
      'Cordoba',
    ],
  },
  {
    name: 'Jaén',
    short: 'J',
    alias: [
      'Jaen',
    ],
  },
  {
    name: 'Ávila',
    short: 'AV',
    alias: [
      'Avila',
    ],
  },
  {
    name: 'Valladolid',
    short: 'VA',
    alias: null,
  },
  {
    name: 'Zamora',
    short: 'ZA',
    alias: null,
  },
  {
    name: 'Álava',
    short: 'VI',
    alias: [
      'Alava',
    ],
  },
  {
    name: 'Segovia',
    short: 'SG',
    alias: null,
  },
  {
    name: 'Burgos',
    short: 'BU',
    alias: null,
  },
  {
    name: 'Pontevedra',
    short: 'PO',
    alias: null,
  },
  {
    name: 'León',
    short: 'LE',
    alias: [
      'Leon',
    ],
  },
  {
    name: 'Orense',
    short: 'OU',
    alias: null,
  },
  {
    name: 'Palencia',
    short: 'P',
    alias: null,
  },
  {
    name: 'La Rioja',
    short: 'LO',
    alias: null,
  },
  {
    name: 'Soria',
    short: 'SO',
    alias: null,
  },
  {
    name: 'Guadalajara',
    short: 'GU',
    alias: null,
  },
];
const ET$1 = [
  {
    name: 'Addis Ababa',
    alias: null,
  },
  {
    name: 'Afar Region',
    alias: null,
  },
  {
    name: 'Amhara Region',
    alias: null,
  },
  {
    name: 'Benishangul-Gumuz',
    alias: [
      'Benishangul Gumuz',
    ],
  },
  {
    name: 'Dire Dawa',
    alias: null,
  },
  {
    name: 'Gambela',
    alias: null,
  },
  {
    name: 'Harari',
    alias: null,
  },
  {
    name: 'Oromia',
    alias: null,
  },
  {
    name: 'Somali',
    alias: null,
  },
  {
    name: "Southern Nations, Nationalities, and Peoples' Region",
    alias: 'SNNPR',
  },
  {
    name: 'Tigray Region',
    alias: null,
  },
];
const ID$1 = [
  {
    short: 'ID-AC',
    name: 'Special Region of Aceh',
    alias: null,
  },
  {
    short: 'ID-BA',
    name: 'Bali',
    alias: null,
  },
  {
    short: 'ID-BB',
    name: 'Bangka–Belitung Islands',
    alias: [
      'Bangka Belitung Islands',
    ],
  },
  {
    short: 'ID-BT',
    name: 'Banten',
    alias: null,
  },
  {
    short: 'ID-BE',
    name: 'Bengkulu',
    alias: null,
  },
  {
    short: 'ID-JT',
    name: 'Central Java',
    alias: null,
  },
  {
    short: 'ID-KT',
    name: 'Central Kalimantan',
    alias: null,
  },
  {
    short: 'ID-ST',
    name: 'Central Sulawesi',
    alias: null,
  },
  {
    short: 'ID-JI',
    name: 'East Java',
    alias: null,
  },
  {
    short: 'ID-KI',
    name: 'East Kalimantan',
    alias: null,
  },
  {
    short: 'ID-NT',
    name: 'East Nusa Tenggara',
    alias: null,
  },
  {
    short: 'ID-GO',
    name: 'Gorontalo',
    alias: null,
  },
  {
    short: 'ID-JK',
    name: 'Jakarta Special Capital Region',
    alias: null,
  },
  {
    short: 'ID-JA',
    name: 'Jambi',
    alias: null,
  },
  {
    short: 'ID-LA',
    name: 'Lampung',
    alias: null,
  },
  {
    short: 'ID-MA',
    name: 'Maluku',
    alias: null,
  },
  {
    short: 'ID-KU',
    name: 'North Kalimantan',
    alias: null,
  },
  {
    short: 'ID-MU',
    name: 'North Maluku',
    alias: null,
  },
  {
    short: 'ID-SA',
    name: 'North Sulawesi',
    alias: null,
  },
  {
    short: 'ID-SU',
    name: 'North Sumatra',
    alias: null,
  },
  {
    short: 'ID-PA',
    name: 'Special Region of Papua',
    alias: null,
  },
  {
    short: 'ID-RI',
    name: 'Riau',
    alias: null,
  },
  {
    short: 'ID-KR',
    name: 'Riau Islands',
    alias: null,
  },
  {
    short: 'ID-SG',
    name: 'Southeast Sulawesi',
    alias: null,
  },
  {
    short: 'ID-KS',
    name: 'South Kalimantan',
    alias: null,
  },
  {
    short: 'ID-SN',
    name: 'South Sulawesi',
    alias: null,
  },
  {
    short: 'ID-SS',
    name: 'South Sumatra',
    alias: null,
  },
  {
    short: 'ID-JB',
    name: 'West Java',
    alias: null,
  },
  {
    short: 'ID-KB',
    name: 'West Kalimantan',
    alias: null,
  },
  {
    short: 'ID-NB',
    name: 'West Nusa Tenggara',
    alias: null,
  },
  {
    short: 'ID-PB',
    name: 'Special Region of West Papua',
    alias: null,
  },
  {
    short: 'ID-SR',
    name: 'West Sulawesi',
    alias: null,
  },
  {
    short: 'ID-SB',
    name: 'West Sumatra',
    alias: null,
  },
  {
    short: 'ID-YO',
    name: 'Special Region of Yogyakarta',
    alias: null,
  },
];
const IN$1 = [
  {
    short: 'AP',
    name: 'Andhra Pradesh',
    alias: null,
  },
  {
    short: 'AR',
    name: 'Arunachal Pradesh',
    alias: null,
  },
  {
    short: 'AS',
    name: 'Assam',
    alias: null,
  },
  {
    short: 'BR',
    name: 'Bihar',
    alias: null,
  },
  {
    short: 'CT',
    name: 'Chhattisgarh',
    alias: null,
  },
  {
    short: 'GA',
    name: 'Goa',
    alias: null,
  },
  {
    short: 'GJ',
    name: 'Gujarat',
    alias: null,
  },
  {
    short: 'HR',
    name: 'Haryana',
    alias: null,
  },
  {
    short: 'HP',
    name: 'Himachal Pradesh',
    alias: null,
  },
  {
    short: 'JK',
    name: 'Jammu and Kashmir',
    alias: null,
  },
  {
    short: 'JH',
    name: 'Jharkhand',
    alias: null,
  },
  {
    short: 'KA',
    name: 'Karnataka',
    alias: null,
  },
  {
    short: 'KL',
    name: 'Kerala',
    alias: null,
  },
  {
    short: 'MP',
    name: 'Madhya Pradesh',
    alias: null,
  },
  {
    short: 'MH',
    name: 'Maharashtra',
    alias: null,
  },
  {
    short: 'MN',
    name: 'Manipur',
    alias: null,
  },
  {
    short: 'ML',
    name: 'Meghalaya',
    alias: null,
  },
  {
    short: 'MZ',
    name: 'Mizoram',
    alias: null,
  },
  {
    short: 'NL',
    name: 'Nagaland',
    alias: null,
  },
  {
    short: 'OR',
    name: 'Odisha',
    alias: null,
  },
  {
    short: 'PB',
    name: 'Punjab',
    alias: null,
  },
  {
    short: 'RJ',
    name: 'Rajasthan',
    alias: null,
  },
  {
    short: 'SK',
    name: 'Sikkim',
    alias: null,
  },
  {
    short: 'TN',
    name: 'Tamil Nadu',
    alias: null,
  },
  {
    short: 'TG',
    name: 'Telangana',
    alias: null,
  },
  {
    short: 'TR',
    name: 'Tripura',
    alias: null,
  },
  {
    short: 'UP',
    name: 'Uttar Pradesh',
    alias: null,
  },
  {
    short: 'UT',
    name: 'Uttarakhand',
    alias: null,
  },
  {
    short: 'WB',
    name: 'West Bengal',
    alias: null,
  },
  {
    short: 'AN',
    name: 'Andaman and Nicobar Islands',
    alias: null,
  },
  {
    short: 'CH',
    name: 'Chandigarh',
    alias: null,
  },
  {
    short: 'DN',
    name: 'Dadra and Nagar Haveli',
    alias: null,
  },
  {
    short: 'DD',
    name: 'Daman and Diu',
    alias: null,
  },
  {
    short: 'LD',
    name: 'Lakshadweep',
    alias: null,
  },
  {
    short: 'DL',
    name: 'National Capital Territory of Delhi',
    alias: null,
  },
  {
    short: 'PY',
    name: 'Puducherry',
    alias: null,
  },
];
const JO$1 = [
  {
    name: 'Irbid',
    alias: null,
  },
  {
    name: 'Ajloun',
    alias: null,
  },
  {
    name: 'Jerash',
    alias: null,
  },
  {
    name: 'Mafraq',
    alias: null,
  },
  {
    name: 'Balqa',
    alias: null,
  },
  {
    name: 'Amman',
    alias: null,
  },
  {
    name: 'Zarqa',
    alias: null,
  },
  {
    name: 'Madaba',
    alias: null,
  },
  {
    name: 'Karak',
    alias: null,
  },
  {
    name: 'Tafilah',
    alias: null,
  },
  {
    name: "Ma'an",
    alias: null,
  },
  {
    name: 'Aqaba',
    alias: null,
  },
];
const JP$1 = [
  {
    name: '愛知県',
    alias: [
      'Aichi',
    ],
  },
  {
    name: '秋田県',
    alias: [
      'Akita',
    ],
  },
  {
    name: '青森県',
    alias: [
      'Aomori',
    ],
  },
  {
    name: '千葉県',
    alias: [
      'Chiba',
    ],
  },
  {
    name: '愛媛県',
    alias: [
      'Ehime',
    ],
  },
  {
    name: '福井県',
    alias: [
      'Fukui',
    ],
  },
  {
    name: '福岡県',
    alias: [
      'Fukuoka',
    ],
  },
  {
    name: '福島県',
    alias: [
      'Fukushima',
    ],
  },
  {
    name: '岐阜県',
    alias: [
      'Gifu',
    ],
  },
  {
    name: '群馬県',
    alias: [
      'Gunma',
    ],
  },
  {
    name: '広島県',
    alias: [
      'Hiroshima',
    ],
  },
  {
    name: '北海道',
    alias: [
      'Hokkaidō',
    ],
  },
  {
    name: '兵庫県',
    alias: [
      'Hyōgo',
      'Hyogo',
    ],
  },
  {
    name: '茨城県',
    alias: [
      'Ibaraki',
    ],
  },
  {
    name: '石川県',
    alias: [
      'Ishikawa',
    ],
  },
  {
    name: '岩手県',
    alias: [
      'Iwate',
    ],
  },
  {
    name: '香川県',
    alias: [
      'Kagawa',
    ],
  },
  {
    name: '鹿児島県',
    alias: [
      'Kagoshima',
    ],
  },
  {
    name: '神奈川県',
    alias: [
      'Kanagawa',
    ],
  },
  {
    name: '高知県',
    alias: [
      'Kōchi',
      'Kochi',
    ],
  },
  {
    name: '熊本県',
    alias: [
      'Kumamoto',
    ],
  },
  {
    name: '京都府',
    alias: [
      'Kyōto',
      'Kyoto',
    ],
  },
  {
    name: '三重県',
    alias: [
      'Mie',
    ],
  },
  {
    name: '宮城県',
    alias: [
      'Miyagi',
    ],
  },
  {
    name: '宮崎県',
    alias: [
      'Miyazaki',
    ],
  },
  {
    name: '長野県',
    alias: [
      'Nagano',
    ],
  },
  {
    name: '長崎県',
    alias: [
      'Nagasaki',
    ],
  },
  {
    name: '奈良県',
    alias: [
      'Nara',
    ],
  },
  {
    name: '新潟県',
    alias: [
      'Niigata',
    ],
  },
  {
    name: '大分県',
    alias: [
      'Ōita',
      'Oita',
    ],
  },
  {
    name: '岡山県',
    alias: [
      'Okayama',
    ],
  },
  {
    name: '沖縄県',
    alias: [
      'Okinawa',
    ],
  },
  {
    name: '大阪府',
    alias: [
      'Ōsaka',
    ],
  },
  {
    name: '佐賀県',
    alias: [
      'Saga',
    ],
  },
  {
    name: '埼玉県',
    alias: [
      'Saitama',
    ],
  },
  {
    name: '滋賀県',
    alias: [
      'Shiga',
    ],
  },
  {
    name: '島根県',
    alias: [
      'Shimane',
    ],
  },
  {
    name: '静岡県',
    alias: [
      'Shizuoka',
    ],
  },
  {
    name: '栃木県',
    alias: [
      'Tochigi',
    ],
  },
  {
    name: '徳島県',
    alias: [
      'Tokushima',
    ],
  },
  {
    name: '東京都',
    alias: [
      'Tōkyō',
      'Tokyo',
    ],
  },
  {
    name: '鳥取県',
    alias: [
      'Tottori',
    ],
  },
  {
    name: '富山県',
    alias: [
      'Toyama',
    ],
  },
  {
    name: '和歌山県',
    alias: [
      'Wakayama',
    ],
  },
  {
    name: '山形県',
    alias: [
      'Yamagata',
    ],
  },
  {
    name: '山口県',
    alias: [
      'Yamaguchi',
    ],
  },
  {
    name: '山梨県',
    alias: [
      'Yamanashi',
    ],
  },
];
const KH$1 = [
  {
    name: 'ភ្នំពេញ',
    alias: [
      'Phnom Penh Municipality',
    ],
  },
  {
    name: 'បន្ទាយមានជ័យ',
    alias: [
      'Banteay Meanchey',
    ],
  },
  {
    name: 'បាត់ដំបង',
    alias: [
      'Battambang',
    ],
  },
  {
    name: 'កំពង់ចាម',
    alias: [
      'Kampong Cham',
    ],
  },
  {
    name: 'កំពង់ឆ្នាំង',
    alias: [
      'Kampong Chhnang',
    ],
  },
  {
    name: 'កំពង់ស្ពឺ',
    alias: [
      'Kampong Speu',
    ],
  },
  {
    name: 'កំពង់ធំ',
    alias: [
      'Kampong Thom',
    ],
  },
  {
    name: 'កំពត',
    alias: [
      'Kampot',
    ],
  },
  {
    name: 'កណ្តាល',
    alias: [
      'Kandal',
    ],
  },
  {
    name: 'កោះកុង',
    alias: [
      'Koh Kong',
    ],
  },
  {
    name: 'កែប',
    alias: [
      'Kep',
    ],
  },
  {
    name: 'ក្រចេះ',
    alias: [
      'Kratié',
      'Kratie',
    ],
  },
  {
    name: 'មណ្ឌលគីរី',
    alias: [
      'Mondulkiri',
    ],
  },
  {
    name: 'ឧត្តរមានជ័យ',
    alias: [
      'Oddar Meanchey',
    ],
  },
  {
    name: 'បៃលិន',
    alias: [
      'Pailin',
    ],
  },
  {
    name: 'ព្រះសីហនុ',
    alias: [
      'Preah Sihanouk',
    ],
  },
  {
    name: 'ព្រះវិហារ',
    alias: [
      'Preah Vihear',
    ],
  },
  {
    name: 'ពោធិ៍សាត់',
    alias: [
      'Pursat',
    ],
  },
  {
    name: 'ព្រៃវែង',
    alias: [
      'Prey Veng',
    ],
  },
  {
    name: 'រតនគីរី',
    alias: [
      'Ratanakiri',
    ],
  },
  {
    name: 'សៀមរាប',
    alias: [
      'Siem Reap',
    ],
  },
  {
    name: 'ស្ទឹងត្រែង',
    alias: [
      'Stung Treng',
    ],
  },
  {
    name: 'ស្វាយរៀង',
    alias: [
      'Svay Rieng',
    ],
  },
  {
    name: 'តាកែវ',
    alias: [
      'Takéo',
      'Takeo',
    ],
  },
  {
    name: 'ត្បូងឃ្មុំ',
    alias: [
      'Tbong Khmum',
    ],
  },
];
const MX$1 = [
  {
    name: 'Aguascalientes',
    short: 'AG',
    alias: [
      'AGS',
    ],
  },
  {
    name: 'Baja California',
    short: 'BC',
    alias: [
      'BCN',
    ],
  },
  {
    name: 'Baja California Sur',
    short: 'BS',
    alias: [
      'BCS',
    ],
  },
  {
    name: 'Campeche',
    short: 'CM',
    alias: [
      'Camp',
      'CAM',
    ],
  },
  {
    name: 'Chiapas',
    short: 'CS',
    alias: [
      'Chis',
      'CHP',
    ],
  },
  {
    name: 'Chihuahua',
    short: 'CH',
    alias: [
      'Chih',
      'CHH',
    ],
  },
  {
    name: 'Coahuila',
    short: 'MX',
    alias: [
      'Coah',
      'COA',
    ],
  },
  {
    name: 'Colima',
    short: 'CL',
    alias: [
      'COL',
    ],
  },
  {
    name: 'Federal District',
    short: 'DF',
    alias: [
      'DIF',
    ],
  },
  {
    name: 'Durango',
    short: 'DG',
    alias: [
      'Dgo',
      'DUR',
    ],
  },
  {
    name: 'Guanajuato',
    short: 'GT',
    alias: [
      'Gto',
      'GUA',
    ],
  },
  {
    name: 'Guerrero',
    short: 'GR',
    alias: [
      'Gro',
      'GRO',
    ],
  },
  {
    name: 'Hidalgo',
    short: 'HG',
    alias: [
      'Hgo',
      'HID',
    ],
  },
  {
    name: 'Jalisco',
    short: 'JA',
    alias: [
      'Jal',
      'JAL',
    ],
  },
  {
    name: 'Mexico',
    short: 'ME',
    alias: [
      'Edomex',
      'MEX',
    ],
  },
  {
    name: 'Michoacán',
    short: 'MI',
    alias: [
      'Mich',
      'MIC',
      'Michoacan',
    ],
  },
  {
    name: 'Morelos',
    short: 'MO',
    alias: [
      'Mor',
      'MOR',
    ],
  },
  {
    name: 'Nayarit',
    short: 'NA',
    alias: [
      'Nay',
      'NAY',
    ],
  },
  {
    name: 'Nuevo León',
    short: 'NL',
    alias: [
      'NLE',
      'Nuevo Leon',
    ],
  },
  {
    name: 'Oaxaca',
    short: 'OA',
    alias: [
      'Oax',
      'OAX',
    ],
  },
  {
    name: 'Puebla',
    short: 'PU',
    alias: [
      'Pue',
      'PUE',
    ],
  },
  {
    name: 'Querétaro',
    short: 'QE',
    alias: [
      'Qro',
      'QUE',
      'Queretaro',
    ],
  },
  {
    name: 'Quintana Roo',
    short: 'QR',
    alias: [
      'Q Roo',
      'ROO',
    ],
  },
  {
    name: 'San Luis Potosí',
    short: 'SL',
    alias: [
      'SLP',
      'San Luis Potosi',
    ],
  },
  {
    name: 'Sinaloa',
    short: 'SI',
    alias: [
      'SIN',
    ],
  },
  {
    name: 'Sonora',
    short: 'SO',
    alias: [
      'SON',
    ],
  },
  {
    name: 'Tabasco',
    short: 'TB',
    alias: [
      'TAB',
    ],
  },
  {
    name: 'Tamaulipas',
    short: 'TM',
    alias: [
      'Tamps',
      'TAM',
    ],
  },
  {
    name: 'Tlaxcala',
    short: 'TL',
    alias: [
      'Tlax',
      'TLA',
    ],
  },
  {
    name: 'Veracruz',
    short: 'VE',
    alias: [
      'VER',
    ],
  },
  {
    name: 'Yucatán',
    short: 'YU',
    alias: [
      'YUC',
      'Yucatan',
    ],
  },
  {
    name: 'Zacatecas',
    short: 'ZA',
    alias: [
      'ZAC',
    ],
  },
];
const NG$1 = [
  {
    name: 'Anambra',
    alias: null,
  },
  {
    name: 'Enugu',
    alias: null,
  },
  {
    name: 'Akwa Ibom',
    alias: null,
  },
  {
    name: 'Adamawa',
    alias: null,
  },
  {
    name: 'Abia',
    alias: null,
  },
  {
    name: 'Bauchi',
    alias: null,
  },
  {
    name: 'Bayelsa',
    alias: null,
  },
  {
    name: 'Benue',
    alias: null,
  },
  {
    name: 'Borno',
    alias: null,
  },
  {
    name: 'Cross River',
    alias: null,
  },
  {
    name: 'Delta',
    alias: null,
  },
  {
    name: 'Ebonyi',
    alias: null,
  },
];
const NL$1 = [
  {
    short: 'DR',
    name: 'Drenthe',
    alias: null,
  },
  {
    short: 'FL',
    name: 'Flevoland',
    alias: null,
  },
  {
    short: 'FR',
    name: 'Friesland',
    alias: null,
  },
  {
    short: 'GD',
    name: 'Gelderland',
    alias: null,
  },
  {
    short: 'GR',
    name: 'Groningen',
    alias: null,
  },
  {
    short: 'LB',
    name: 'Limburg',
    alias: null,
  },
  {
    short: 'NB',
    name: 'Noord-Brabant',
    alias: [
      'Noord Brabant',
    ],
  },
  {
    short: 'NH',
    name: 'Noord-Holland',
    alias: [
      'Noord Holland',
    ],
  },
  {
    short: 'OV',
    name: 'Overijssel',
    alias: null,
  },
  {
    short: 'UT',
    name: 'Utrecht',
    alias: null,
  },
  {
    short: 'ZH',
    name: 'Zuid-Holland',
    alias: [
      'Zuid Holland',
    ],
  },
  {
    short: 'ZL',
    name: 'Zeeland',
    alias: null,
  },
  {
    short: 'AW',
    name: 'Aruba',
    alias: null,
  },
  {
    short: 'BQ',
    name: 'Bonaire',
    alias: null,
  },
  {
    short: 'BQ2',
    name: 'Saba',
    alias: null,
  },
  {
    short: 'BQ3',
    name: 'Sint Eustatius',
    alias: null,
  },
  {
    short: 'CW',
    name: 'Curaçao',
    alias: null,
  },
  {
    short: 'SX',
    name: 'Sint Maarten',
    alias: null,
  },
];
const PE$1 = [
  {
    name: 'Chachapoyas',
    region: 'Amazonas',
    alias: null,
  },
  {
    name: 'Bagua',
    region: 'Amazonas',
    alias: null,
  },
  {
    name: 'Bongará',
    region: 'Amazonas',
    alias: [
      'Bongara',
    ],
  },
  {
    name: 'Condorcanqui',
    region: 'Amazonas',
    alias: null,
  },
  {
    name: 'Luya',
    region: 'Amazonas',
    alias: null,
  },
  {
    name: 'Rodríguez de Mendoza',
    region: 'Amazonas',
    alias: [
      'Rodriguez de Mendoza',
    ],
  },
  {
    name: 'Utcubamba',
    region: 'Amazonas',
    alias: null,
  },
  {
    name: 'Huaraz',
    region: 'Ancash',
    alias: null,
  },
  {
    name: 'Aija',
    region: 'Ancash',
    alias: null,
  },
  {
    name: 'Antonio Raymondi',
    region: 'Ancash',
    alias: null,
  },
  {
    name: 'Asunción',
    region: 'Ancash',
    alias: [
      'Asuncion',
    ],
  },
  {
    name: 'Bolognesi',
    region: 'Ancash',
    alias: null,
  },
  {
    name: 'Carhuaz',
    region: 'Ancash',
    alias: null,
  },
  {
    name: 'Carlos Fermín Fitzcarrald',
    region: 'Ancash',
    alias: [
      'Carlos Fermin Fitzcarrald',
    ],
  },
  {
    name: 'Casma',
    region: 'Ancash',
    alias: null,
  },
  {
    name: 'Corongo',
    region: 'Ancash',
    alias: null,
  },
  {
    name: 'Huari',
    region: 'Ancash',
    alias: null,
  },
  {
    name: 'Huarmey',
    region: 'Ancash',
    alias: null,
  },
  {
    name: 'Huaylas',
    region: 'Ancash',
    alias: null,
  },
  {
    name: 'Mariscal Luzuriaga',
    region: 'Ancash',
    alias: null,
  },
  {
    name: 'Ocros',
    region: 'Ancash',
    alias: null,
  },
  {
    name: 'Pallasca',
    region: 'Ancash',
    alias: null,
  },
  {
    name: 'Pomabamba',
    region: 'Ancash',
    alias: null,
  },
  {
    name: 'Recuay',
    region: 'Ancash',
    alias: null,
  },
  {
    name: 'Santa',
    region: 'Ancash',
    alias: null,
  },
  {
    name: 'Sihuas',
    region: 'Ancash',
    alias: null,
  },
  {
    name: 'Yungay',
    region: 'Ancash',
    alias: null,
  },
  {
    name: 'Abancay',
    region: 'Apurímac',
    alias: null,
  },
  {
    name: 'Andahuaylas',
    region: 'Apurímac',
    alias: null,
  },
  {
    name: 'Antabamba',
    region: 'Apurímac',
    alias: null,
  },
  {
    name: 'Aymaraes',
    region: 'Apurímac',
    alias: null,
  },
  {
    name: 'Cotabambas',
    region: 'Apurímac',
    alias: null,
  },
  {
    name: 'Chincheros',
    region: 'Apurímac',
    alias: null,
  },
  {
    name: 'Grau',
    region: 'Apurímac',
    alias: null,
  },
  {
    name: 'Arequipa',
    region: 'Arequipa',
    alias: null,
  },
  {
    name: 'Camaná',
    region: 'Arequipa',
    alias: [
      'Camana',
    ],
  },
  {
    name: 'Caravelí',
    region: 'Arequipa',
    alias: [
      'Caraveli',
    ],
  },
  {
    name: 'Castilla',
    region: 'Arequipa',
    alias: null,
  },
  {
    name: 'Caylloma',
    region: 'Arequipa',
    alias: null,
  },
  {
    name: 'Condesuyos',
    region: 'Arequipa',
    alias: null,
  },
  {
    name: 'Islay',
    region: 'Arequipa',
    alias: null,
  },
  {
    name: 'La Unión',
    region: 'Arequipa',
    alias: [
      'La Union',
    ],
  },
  {
    name: 'Huamanga',
    region: 'Ayacucho',
    alias: null,
  },
  {
    name: 'Cangallo',
    region: 'Ayacucho',
    alias: null,
  },
  {
    name: 'Huanca Sancos',
    region: 'Ayacucho',
    alias: null,
  },
  {
    name: 'Huanta',
    region: 'Ayacucho',
    alias: null,
  },
  {
    name: 'La Mar',
    region: 'Ayacucho',
    alias: null,
  },
  {
    name: 'Lucanas',
    region: 'Ayacucho',
    alias: null,
  },
  {
    name: 'Parinacochas',
    region: 'Ayacucho',
    alias: null,
  },
  {
    name: 'Páucar del Sara Sara',
    region: 'Ayacucho',
    alias: [
      'Paucar del Sara Sara',
    ],
  },
  {
    name: 'Sucre',
    region: 'Ayacucho',
    alias: null,
  },
  {
    name: 'Víctor Fajardo',
    region: 'Ayacucho',
    alias: [
      'Victor Fajardo',
    ],
  },
  {
    name: 'Vilcas Huamán',
    region: 'Ayacucho',
    alias: [
      'Vilcas Huaman',
    ],
  },
  {
    name: 'Cajamarca',
    region: 'Cajamarca',
    alias: null,
  },
  {
    name: 'Cajabamba',
    region: 'Cajamarca',
    alias: null,
  },
  {
    name: 'Celendín',
    region: 'Cajamarca',
    alias: [
      'Celendin',
    ],
  },
  {
    name: 'Chota',
    region: 'Cajamarca',
    alias: null,
  },
  {
    name: 'Contumazá',
    region: 'Cajamarca',
    alias: [
      'Contumaza',
    ],
  },
  {
    name: 'Cutervo',
    region: 'Cajamarca',
    alias: null,
  },
  {
    name: 'Hualgayoc',
    region: 'Cajamarca',
    alias: null,
  },
  {
    name: 'Jaén',
    region: 'Cajamarca',
    alias: [
      'Jaen',
    ],
  },
  {
    name: 'San Ignacio',
    region: 'Cajamarca',
    alias: null,
  },
  {
    name: 'San Marcos',
    region: 'Cajamarca',
    alias: null,
  },
  {
    name: 'San Miguel',
    region: 'Cajamarca',
    alias: null,
  },
  {
    name: 'San Pablo',
    region: 'Cajamarca',
    alias: null,
  },
  {
    name: 'Santa Cruz',
    region: 'Cajamarca',
    alias: null,
  },
  {
    name: 'Callao',
    region: 'Callao',
    alias: null,
  },
  {
    name: 'Cusco',
    region: 'Cusco',
    alias: null,
  },
  {
    name: 'Acomayo',
    region: 'Cusco',
    alias: null,
  },
  {
    name: 'Anta',
    region: 'Cusco',
    alias: null,
  },
  {
    name: 'Calca',
    region: 'Cusco',
    alias: null,
  },
  {
    name: 'Canas',
    region: 'Cusco',
    alias: null,
  },
  {
    name: 'Canchis',
    region: 'Cusco',
    alias: null,
  },
  {
    name: 'Chumbivilcas',
    region: 'Cusco',
    alias: null,
  },
  {
    name: 'Espinar',
    region: 'Cusco',
    alias: null,
  },
  {
    name: 'La Convención',
    region: 'Cusco',
    alias: [
      'La Convencion',
    ],
  },
  {
    name: 'Paruro',
    region: 'Cusco',
    alias: null,
  },
  {
    name: 'Paucartambo',
    region: 'Cusco',
    alias: null,
  },
  {
    name: 'Quispicanchi',
    region: 'Cusco',
    alias: null,
  },
  {
    name: 'Urubamba',
    region: 'Cusco',
    alias: null,
  },
  {
    name: 'Huancavelica',
    region: 'Huancavelica',
    alias: null,
  },
  {
    name: 'Acobamba',
    region: 'Huancavelica',
    alias: null,
  },
  {
    name: 'Angaraes',
    region: 'Huancavelica',
    alias: null,
  },
  {
    name: 'Castrovirreyna',
    region: 'Huancavelica',
    alias: null,
  },
  {
    name: 'Churcampa',
    region: 'Huancavelica',
    alias: null,
  },
  {
    name: 'Huaytará',
    region: 'Huancavelica',
    alias: [
      'Huaytara',
    ],
  },
  {
    name: 'Tayacaja',
    region: 'Huancavelica',
    alias: null,
  },
  {
    name: 'Huánuco',
    region: 'Huánuco',
    alias: [
      'Huanuco',
    ],
  },
  {
    name: 'Ambo',
    region: 'Huánuco',
    alias: null,
  },
  {
    name: 'Dos de Mayo',
    region: 'Huánuco',
    alias: null,
  },
  {
    name: 'Huacaybamba',
    region: 'Huánuco',
    alias: null,
  },
  {
    name: 'Huamalíes',
    region: 'Huánuco',
    alias: [
      'Huamalies',
    ],
  },
  {
    name: 'Leoncio Prado',
    region: 'Huánuco',
    alias: null,
  },
  {
    name: 'Marañón',
    region: 'Huánuco',
    alias: [
      'Maranon',
    ],
  },
  {
    name: 'Pachitea',
    region: 'Huánuco',
    alias: null,
  },
  {
    name: 'Puerto Inca',
    region: 'Huánuco',
    alias: null,
  },
  {
    name: 'Lauricocha',
    region: 'Huánuco',
    alias: null,
  },
  {
    name: 'Yarowilca',
    region: 'Huánuco',
    alias: null,
  },
  {
    name: 'Ica',
    region: 'Ica',
    alias: null,
  },
  {
    name: 'Chincha',
    region: 'Ica',
    alias: null,
  },
  {
    name: 'Nazca',
    region: 'Ica',
    alias: null,
  },
  {
    name: 'Palpa',
    region: 'Ica',
    alias: null,
  },
  {
    name: 'Pisco',
    region: 'Ica',
    alias: null,
  },
  {
    name: 'Huancayo',
    region: 'Junín',
    alias: null,
  },
  {
    name: 'Concepción',
    region: 'Junín',
    alias: [
      'Concepcion',
    ],
  },
  {
    name: 'Chanchamayo',
    region: 'Junín',
    alias: null,
  },
  {
    name: 'Jauja',
    region: 'Junín',
    alias: null,
  },
  {
    name: 'Junín',
    region: 'Junín',
    alias: [
      'Junin',
    ],
  },
  {
    name: 'Satipo',
    region: 'Junín',
    alias: null,
  },
  {
    name: 'Tarma',
    region: 'Junín',
    alias: null,
  },
  {
    name: 'Yauli',
    region: 'Junín',
    alias: null,
  },
  {
    name: 'Chupaca',
    region: 'Junín',
    alias: null,
  },
  {
    name: 'Trujillo',
    region: 'La Libertad',
    alias: null,
  },
  {
    name: 'Ascope',
    region: 'La Libertad',
    alias: null,
  },
  {
    name: 'Bolívar',
    region: 'La Libertad',
    alias: [
      'Bolivar',
    ],
  },
  {
    name: 'Chepén',
    region: 'La Libertad',
    alias: [
      'Chepen',
    ],
  },
  {
    name: 'Julcán',
    region: 'La Libertad',
    alias: [
      'Julcan',
    ],
  },
  {
    name: 'Otuzco',
    region: 'La Libertad',
    alias: null,
  },
  {
    name: 'Pacasmayo',
    region: 'La Libertad',
    alias: null,
  },
  {
    name: 'Pataz',
    region: 'La Libertad',
    alias: null,
  },
  {
    name: 'Sánchez Carrión',
    region: 'La Libertad',
    alias: [
      'Sanchez Carrion',
    ],
  },
  {
    name: 'Santiago de Chuco',
    region: 'La Libertad',
    alias: null,
  },
  {
    name: 'Gran Chimú',
    region: 'La Libertad',
    alias: [
      'Gran Chimu',
    ],
  },
  {
    name: 'Virú',
    region: 'La Libertad',
    alias: [
      'Viru',
    ],
  },
  {
    name: 'Chiclayo',
    region: 'Lambayeque',
    alias: null,
  },
  {
    name: 'Ferreñafe',
    region: 'Lambayeque',
    alias: [
      'Ferrenafe',
    ],
  },
  {
    name: 'Lambayeque',
    region: 'Lambayeque',
    alias: null,
  },
  {
    name: 'Lima',
    region: 'autonomous',
    alias: null,
  },
  {
    name: 'Huaura',
    region: 'Lima',
    alias: null,
  },
  {
    name: 'Barranca',
    region: 'Lima',
    alias: null,
  },
  {
    name: 'Cajatambo',
    region: 'Lima',
    alias: null,
  },
  {
    name: 'Canta',
    region: 'Lima',
    alias: null,
  },
  {
    name: 'Cañete',
    region: 'Lima',
    alias: [
      'Canete',
    ],
  },
  {
    name: 'Huaral',
    region: 'Lima',
    alias: null,
  },
  {
    name: 'Huarochirí',
    region: 'Lima',
    alias: null,
  },
  {
    name: 'Oyón',
    region: 'Lima',
    alias: [
      'Oyon',
    ],
  },
  {
    name: 'Yauyos',
    region: 'Lima',
    alias: null,
  },
  {
    name: 'Maynas',
    region: 'Loreto',
    alias: null,
  },
  {
    name: 'Aliaso Amazonas',
    region: 'Loreto',
    alias: null,
  },
  {
    name: 'Loreto',
    region: 'Loreto',
    alias: null,
  },
  {
    name: 'Mariscal Ramón Castilla',
    region: 'Loreto',
    alias: [
      'Mariscal Ramon Castilla',
    ],
  },
  {
    name: 'Putumayo',
    region: 'Loreto',
    alias: null,
  },
  {
    name: 'Requena',
    region: 'Loreto',
    alias: null,
  },
  {
    name: 'Ucayali',
    region: 'Loreto',
    alias: null,
  },
  {
    name: 'Datem del Marañón',
    region: 'Loreto',
    alias: [
      'Datem del Maranon',
    ],
  },
  {
    name: 'Tambopata',
    region: 'Madre de Dios',
    alias: null,
  },
  {
    name: 'Manú',
    region: 'Madre de Dios',
    alias: [
      'Manu',
    ],
  },
  {
    name: 'Tahuamanu',
    region: 'Madre de Dios',
    alias: null,
  },
  {
    name: 'Mariscal Nieto',
    region: 'Moquegua',
    alias: null,
  },
  {
    name: 'General Sánchez Cerro',
    region: 'Moquegua',
    alias: [
      'General Sanchez Cerro',
    ],
  },
  {
    name: 'Ilo',
    region: 'Moquegua',
    alias: null,
  },
  {
    name: 'Pasco',
    region: 'Pasco',
    alias: null,
  },
  {
    name: 'Daniel Alcídes Carrión',
    region: 'Pasco',
    alias: [
      'Daniel Alcides Carrion',
    ],
  },
  {
    name: 'Oxapampa',
    region: 'Pasco',
    alias: null,
  },
  {
    name: 'Piura',
    region: 'Piura',
    alias: null,
  },
  {
    name: 'Ayabaca',
    region: 'Piura',
    alias: null,
  },
  {
    name: 'Huancabamba',
    region: 'Piura',
    alias: null,
  },
  {
    name: 'Morropón',
    region: 'Piura',
    alias: [
      'Morropon',
    ],
  },
  {
    name: 'Paita',
    region: 'Piura',
    alias: null,
  },
  {
    name: 'Sullana',
    region: 'Piura',
    alias: null,
  },
  {
    name: 'Talara',
    region: 'Piura',
    alias: null,
  },
  {
    name: 'Sechura',
    region: 'Piura',
    alias: null,
  },
  {
    name: 'Puno',
    region: 'Puno',
    alias: null,
  },
  {
    name: 'Azángaro',
    region: 'Puno',
    alias: [
      'Azangaro',
    ],
  },
  {
    name: 'Carabaya',
    region: 'Puno',
    alias: null,
  },
  {
    name: 'Chucuito',
    region: 'Puno',
    alias: null,
  },
  {
    name: 'El Collao',
    region: 'Puno',
    alias: null,
  },
  {
    name: 'Huancané',
    region: 'Puno',
    alias: [
      'Huancane',
    ],
  },
  {
    name: 'Lampa',
    region: 'Puno',
    alias: null,
  },
  {
    name: 'Melgar',
    region: 'Puno',
    alias: null,
  },
  {
    name: 'Moho',
    region: 'Puno',
    alias: null,
  },
  {
    name: 'San Antonio de Putina',
    region: 'Puno',
    alias: null,
  },
  {
    name: 'San Román',
    region: 'Puno',
    alias: [
      'San Roman',
    ],
  },
  {
    name: 'Sandia',
    region: 'Puno',
    alias: null,
  },
  {
    name: 'Yunguyo',
    region: 'Puno',
    alias: null,
  },
  {
    name: 'Moyobamba',
    region: 'San Martín',
    alias: null,
  },
  {
    name: 'Bellavista',
    region: 'San Martín',
    alias: null,
  },
  {
    name: 'El Dorado',
    region: 'San Martín',
    alias: null,
  },
  {
    name: 'Huallaga',
    region: 'San Martín',
    alias: null,
  },
  {
    name: 'Lamas',
    region: 'San Martín',
    alias: null,
  },
  {
    name: 'Mariscal Cáceres',
    region: 'San Martín',
    alias: [
      'Mariscal Caceres',
    ],
  },
  {
    name: 'Picota',
    region: 'San Martín',
    alias: null,
  },
  {
    name: 'Rioja',
    region: 'San Martín',
    alias: null,
  },
  {
    name: 'San Martín',
    region: 'San Martín',
    alias: [
      'San Martin',
    ],
  },
  {
    name: 'Tocache',
    region: 'San Martín',
    alias: null,
  },
  {
    name: 'Tacna',
    region: 'Tacna',
    alias: null,
  },
  {
    name: 'Candarave',
    region: 'Tacna',
    alias: null,
  },
  {
    name: 'Jorge Basadre',
    region: 'Tacna',
    alias: null,
  },
  {
    name: 'Tarata',
    region: 'Tacna',
    alias: null,
  },
  {
    name: 'Tumbes',
    region: 'Tumbes',
    alias: null,
  },
  {
    name: 'Contralmirante Villar',
    region: 'Tumbes',
    alias: null,
  },
  {
    name: 'Zarumilla',
    region: 'Tumbes',
    alias: null,
  },
  {
    name: 'Coronel Portillo',
    region: 'Ucayali',
    alias: null,
  },
  {
    name: 'Atalaya',
    region: 'Ucayali',
    alias: null,
  },
  {
    name: 'Padre Abad',
    region: 'Ucayali',
    alias: null,
  },
  {
    name: 'Purús',
    region: 'Ucayali',
    alias: [
      'Purus',
    ],
  },
];
const PH$1 = [
  {
    name: 'Abra',
    alias: null,
  },
  {
    name: 'Agusan del Norte',
    alias: null,
  },
  {
    name: 'Agusan del Sur',
    alias: null,
  },
  {
    name: 'Aklan',
    alias: null,
  },
  {
    name: 'Albay',
    alias: null,
  },
  {
    name: 'Antique',
    alias: null,
  },
  {
    name: 'Apayao',
    alias: null,
  },
  {
    name: 'Aurora',
    alias: null,
  },
  {
    name: 'Basilan',
    alias: null,
  },
  {
    name: 'Bataan',
    alias: null,
  },
  {
    name: 'Batanes',
    alias: null,
  },
  {
    name: 'Batangas',
    alias: null,
  },
  {
    name: 'Benguet',
    alias: null,
  },
  {
    name: 'Biliran',
    alias: null,
  },
  {
    name: 'Bohol',
    alias: null,
  },
  {
    name: 'Bukidnon',
    alias: null,
  },
  {
    name: 'Bulacan',
    alias: null,
  },
  {
    name: 'Cagayan',
    alias: null,
  },
  {
    name: 'Camarines Norte',
    alias: null,
  },
  {
    name: 'Camarines Sur',
    alias: null,
  },
  {
    name: 'Camiguin',
    alias: null,
  },
  {
    name: 'Capiz',
    alias: null,
  },
  {
    name: 'Catanduanes',
    alias: null,
  },
  {
    name: 'Cavite',
    alias: null,
  },
  {
    name: 'Cebu',
    alias: null,
  },
  {
    name: 'Compostela Valley',
    alias: null,
  },
  {
    name: 'Cotabato',
    alias: null,
  },
  {
    name: 'Davao del Norte',
    alias: null,
  },
  {
    name: 'Davao del Sur',
    alias: null,
  },
  {
    name: 'Davao Occidental',
    alias: null,
  },
  {
    name: 'Davao Oriental',
    alias: null,
  },
  {
    name: 'Dinagat Islands',
    alias: null,
  },
  {
    name: 'Eastern Samar',
    alias: null,
  },
  {
    name: 'Guimaras',
    alias: null,
  },
  {
    name: 'Ifugao',
    alias: null,
  },
  {
    name: 'Ilocos Norte',
    alias: null,
  },
  {
    name: 'Ilocos Sur',
    alias: null,
  },
  {
    name: 'Iloilo',
    alias: null,
  },
  {
    name: 'Isabela',
    alias: null,
  },
  {
    name: 'Kalinga',
    alias: null,
  },
  {
    name: 'La Union',
    alias: null,
  },
  {
    name: 'Laguna',
    alias: null,
  },
  {
    name: 'Lanao del Norte',
    alias: null,
  },
  {
    name: 'Lanao del Sur',
    alias: null,
  },
  {
    name: 'Leyte',
    alias: null,
  },
  {
    name: 'Maguindanao',
    alias: null,
  },
  {
    name: 'Marinduque',
    alias: null,
  },
  {
    name: 'Masbate',
    alias: null,
  },
  {
    name: 'Misamis Occidental',
    alias: null,
  },
  {
    name: 'Misamis Oriental',
    alias: null,
  },
  {
    name: 'Mountain Province',
    alias: null,
  },
  {
    name: 'Negros Occidental',
    alias: null,
  },
  {
    name: 'Negros Oriental',
    alias: null,
  },
  {
    name: 'Northern Samar',
    alias: null,
  },
  {
    name: 'Nueva Ecija',
    alias: null,
  },
  {
    name: 'Nueva Vizcaya',
    alias: null,
  },
  {
    name: 'Occidental Mindoro',
    alias: null,
  },
  {
    name: 'Oriental Mindoro',
    alias: null,
  },
  {
    name: 'Palawan',
    alias: null,
  },
  {
    name: 'Pampanga',
    alias: null,
  },
  {
    name: 'Pangasinan',
    alias: null,
  },
  {
    name: 'Quezon',
    alias: null,
  },
  {
    name: 'Quirino',
    alias: null,
  },
  {
    name: 'Rizal',
    alias: null,
  },
  {
    name: 'Romblon',
    alias: null,
  },
  {
    name: 'Samar',
    alias: null,
  },
  {
    name: 'Sarangani',
    alias: null,
  },
  {
    name: 'Siquijor',
    alias: null,
  },
  {
    name: 'Sorsogon',
    alias: null,
  },
  {
    name: 'South Cotabato',
    alias: null,
  },
  {
    name: 'Southern Leyte',
    alias: null,
  },
  {
    name: 'Sultan Kudarat',
    alias: null,
  },
  {
    name: 'Sulu',
    alias: null,
  },
  {
    name: 'Surigao del Norte',
    alias: null,
  },
  {
    name: 'Surigao del Sur',
    alias: null,
  },
  {
    name: 'Tarlac',
    alias: null,
  },
  {
    name: 'Tawi-Tawi',
    alias: [
      'Tawi Tawi',
    ],
  },
  {
    name: 'Zambales',
    alias: null,
  },
  {
    name: 'Zamboanga del Norte',
    alias: null,
  },
  {
    name: 'Zamboanga del Sur',
    alias: null,
  },
  {
    name: 'Zamboanga Sibugay',
    alias: null,
  },
  {
    name: 'Metro Manila',
    alias: null,
  },
];
const PK$1 = [
  {
    name: 'Azad Kashmir',
    alias: null,
  },
  {
    name: 'Bahawalpur',
    alias: null,
  },
  {
    name: 'Bannu',
    alias: null,
  },
  {
    name: 'Dera Ghazi Khan',
    alias: null,
  },
  {
    name: 'Dera Ismail Khan',
    alias: null,
  },
  {
    name: 'Faisalabad',
    alias: null,
  },
  {
    name: 'Federally Administered Tribal Areas',
    alias: [
      'FATA',
      'F.A.T.A.',
    ],
  },
  {
    name: 'Gujranwala',
    alias: null,
  },
  {
    name: 'Hazara',
    alias: null,
  },
  {
    name: 'Hyderabad',
    alias: null,
  },
  {
    name: 'Islamabad',
    alias: null,
  },
  {
    name: 'Kalat',
    alias: null,
  },
  {
    name: 'Karachi',
    alias: null,
  },
  {
    name: 'Kohat',
    alias: null,
  },
  {
    name: 'Lahore',
    alias: null,
  },
  {
    name: 'Larkana',
    alias: null,
  },
  {
    name: 'Makran',
    alias: null,
  },
  {
    name: 'Malakand',
    alias: null,
  },
  {
    name: 'Mardan',
    alias: null,
  },
  {
    name: 'Mirpur Khas',
    alias: null,
  },
  {
    name: 'Multan',
    alias: null,
  },
  {
    name: 'Nasirabad',
    alias: null,
  },
  {
    name: 'Northern Areas',
    alias: null,
  },
  {
    name: 'Peshawar',
    alias: null,
  },
  {
    name: 'Quetta',
    alias: null,
  },
  {
    name: 'Rawalpindi',
    alias: null,
  },
  {
    name: 'Sargodha',
    alias: null,
  },
  {
    name: 'Sahiwal',
    alias: null,
  },
  {
    name: 'Sibi',
    alias: null,
  },
  {
    name: 'Sukkur',
    alias: null,
  },
  {
    name: 'Zhob',
    alias: null,
  },
];
const TR$1 = [
  {
    name: 'Adana',
    alias: null,
  },
  {
    name: 'Adıyaman',
    alias: [
      'Adiyaman',
    ],
  },
  {
    name: 'Afyonkarahisar',
    alias: null,
  },
  {
    name: 'Ağrı',
    alias: [
      'Agri',
    ],
  },
  {
    name: 'Amasya',
    alias: null,
  },
  {
    name: 'Ankara',
    alias: null,
  },
  {
    name: 'Antalya',
    alias: null,
  },
  {
    name: 'Artvin',
    alias: null,
  },
  {
    name: 'Aydın',
    alias: [
      'Aydin',
    ],
  },
  {
    name: 'Balıkesir',
    alias: [
      'Balikesir',
    ],
  },
  {
    name: 'Bilecik',
    alias: null,
  },
  {
    name: 'Bingöl',
    alias: [
      'Bingol',
    ],
  },
  {
    name: 'Bitlis',
    alias: null,
  },
  {
    name: 'Bolu',
    alias: null,
  },
  {
    name: 'Burdur',
    alias: null,
  },
  {
    name: 'Bursa',
    alias: null,
  },
  {
    name: 'Çanakkale',
    alias: [
      'Canakkale',
    ],
  },
  {
    name: 'Çankırı',
    alias: [
      'Cankiri',
    ],
  },
  {
    name: 'Çorum',
    alias: [
      'Corum',
    ],
  },
  {
    name: 'Denizli',
    alias: null,
  },
  {
    name: 'Diyarbakır',
    alias: [
      'Diyarbakir',
    ],
  },
  {
    name: 'Edirne',
    alias: null,
  },
  {
    name: 'Elazığ',
    alias: [
      'Elazig',
    ],
  },
  {
    name: 'Erzincan',
    alias: null,
  },
  {
    name: 'Erzurum',
    alias: null,
  },
  {
    name: 'Eskişehir',
    alias: [
      'Eskisehir',
    ],
  },
  {
    name: 'Gaziantep',
    alias: null,
  },
  {
    name: 'Giresun',
    alias: null,
  },
  {
    name: 'Gümüşhane',
    alias: [
      'Gumushane',
    ],
  },
  {
    name: 'Hakkâri',
    alias: [
      'Hakkari',
    ],
  },
  {
    name: 'Hatay',
    alias: null,
  },
  {
    name: 'Isparta',
    alias: null,
  },
  {
    name: 'Mersin',
    alias: null,
  },
  {
    name: 'Istanbul',
    alias: null,
  },
  {
    name: 'İzmir',
    alias: [
      'Izmir',
    ],
  },
  {
    name: 'Kars',
    alias: null,
  },
  {
    name: 'Kastamonu',
    alias: null,
  },
  {
    name: 'Kayseri',
    alias: null,
  },
  {
    name: 'Kırklareli',
    alias: null,
  },
  {
    name: 'Kırşehir',
    alias: [
      'Kırsehir',
    ],
  },
  {
    name: 'Kocaeli',
    alias: null,
  },
  {
    name: 'Konya',
    alias: null,
  },
  {
    name: 'Kütahya',
    alias: [
      'Kutahya',
    ],
  },
  {
    name: 'Malatya',
    alias: null,
  },
  {
    name: 'Manisa',
    alias: null,
  },
  {
    name: 'Kahramanmaraş',
    alias: [
      'Kahramanmaras',
    ],
  },
  {
    name: 'Mardin',
    alias: null,
  },
  {
    name: 'Muğla',
    alias: 'Mugla',
  },
  {
    name: 'Muş',
    alias: [
      'Mus',
    ],
  },
  {
    name: 'Nevşehir',
    alias: [
      'Nevsehir',
    ],
  },
  {
    name: 'Niğde',
    alias: [
      'Nigde',
    ],
  },
  {
    name: 'Ordu',
    alias: null,
  },
  {
    name: 'Rize',
    alias: null,
  },
  {
    name: 'Sakarya',
    alias: null,
  },
  {
    name: 'Samsun',
    alias: null,
  },
  {
    name: 'Siirt',
    alias: null,
  },
  {
    name: 'Sinop',
    alias: null,
  },
  {
    name: 'Sivas',
    alias: null,
  },
  {
    name: 'Tekirdağ',
    alias: [
      'Tekirdag',
    ],
  },
  {
    name: 'Tokat',
    alias: null,
  },
  {
    name: 'Trabzon',
    alias: null,
  },
  {
    name: 'Tunceli',
    alias: null,
  },
  {
    name: 'Şanlıurfa',
    alias: [
      'Sanliurfa',
    ],
  },
  {
    name: 'Uşak',
    alias: [
      'Usak',
    ],
  },
  {
    name: 'Van',
    alias: null,
  },
  {
    name: 'Yozgat',
    alias: null,
  },
  {
    name: 'Zonguldak',
    alias: null,
  },
  {
    name: 'Aksaray',
    alias: null,
  },
  {
    name: 'Bayburt',
    alias: null,
  },
  {
    name: 'Karaman',
    alias: null,
  },
  {
    name: 'Kırıkkale',
    alias: [
      'Kirikkale',
    ],
  },
  {
    name: 'Batman',
    alias: null,
  },
  {
    name: 'Şırnak',
    alias: [
      'Sirnak',
    ],
  },
  {
    name: 'Bartın',
    alias: [
      'Bartin',
    ],
  },
  {
    name: 'Ardahan',
    alias: null,
  },
  {
    name: 'Iğdır',
    alias: [
      'Igdir',
    ],
  },
  {
    name: 'Yalova',
    alias: null,
  },
  {
    name: 'Karabük',
    alias: [
      'Karabuk',
    ],
  },
  {
    name: 'Kilis',
    alias: null,
  },
  {
    name: 'Osmaniye',
    alias: null,
  },
  {
    name: 'Düzce',
    alias: [
      'Duzce',
    ],
  },
];
const GB$1 = [
  {
    name: 'Avon',
    region: 'England',
    alias: null,
  },
  {
    name: 'Bedfordshire',
    region: 'England',
    alias: null,
  },
  {
    name: 'Berkshire',
    region: 'England',
    alias: null,
  },
  {
    name: 'Borders',
    region: 'England',
    alias: null,
  },
  {
    name: 'Bristol',
    region: 'England',
    alias: null,
  },
  {
    name: 'Buckinghamshire',
    region: 'England',
    alias: null,
  },
  {
    name: 'Cambridgeshire',
    region: 'England',
    alias: null,
  },
  {
    name: 'Channel Islands',
    region: 'England',
    alias: null,
  },
  {
    name: 'Cheshire',
    region: 'England',
    alias: null,
  },
  {
    name: 'Cleveland',
    region: 'England',
    alias: null,
  },
  {
    name: 'Cornwall',
    region: 'England',
    alias: null,
  },
  {
    name: 'Cumbria',
    region: 'England',
    alias: null,
  },
  {
    name: 'Derbyshire',
    region: 'England',
    alias: null,
  },
  {
    name: 'Devon',
    region: 'England',
    alias: null,
  },
  {
    name: 'Dorset',
    region: 'England',
    alias: null,
  },
  {
    name: 'Durham',
    region: 'England',
    alias: null,
  },
  {
    name: 'East Riding of Yorkshire',
    region: 'England',
    alias: [
      'East Yorkshire',
    ],
  },
  {
    name: 'East Sussex',
    region: 'England',
    alias: null,
  },
  {
    name: 'Essex',
    region: 'England',
    alias: null,
  },
  {
    name: 'Gloucestershire',
    region: 'England',
    alias: null,
  },
  {
    name: 'Greater Manchester',
    region: 'England',
    alias: null,
  },
  {
    name: 'Hampshire',
    region: 'England',
    alias: null,
  },
  {
    name: 'Herefordshire',
    region: 'England',
    alias: null,
  },
  {
    name: 'Hertfordshire',
    region: 'England',
    alias: null,
  },
  {
    name: 'Humberside',
    region: 'England',
    alias: null,
  },
  {
    name: 'Isle of Man',
    region: 'England',
    alias: null,
  },
  {
    name: 'Isle of Wight',
    region: 'England',
    alias: null,
  },
  {
    name: 'Isles of Scilly',
    region: 'England',
    alias: null,
  },
  {
    name: 'Kent',
    region: 'England',
    alias: null,
  },
  {
    name: 'Lancashire',
    region: 'England',
    alias: null,
  },
  {
    name: 'Leicestershire',
    region: 'England',
    alias: null,
  },
  {
    name: 'Lincolnshire',
    region: 'England',
    alias: null,
  },
  {
    name: 'London',
    region: 'England',
    alias: null,
  },
  {
    name: 'Merseyside',
    region: 'England',
    alias: null,
  },
  {
    name: 'Middlesex',
    region: 'England',
    alias: null,
  },
  {
    name: 'Norfolk',
    region: 'England',
    alias: null,
  },
  {
    name: 'North Yorkshire',
    region: 'England',
    alias: null,
  },
  {
    name: 'Northamptonshire',
    region: 'England',
    alias: null,
  },
  {
    name: 'Northumberland',
    region: 'England',
    alias: null,
  },
  {
    name: 'Nottinghamshire',
    region: 'England',
    alias: null,
  },
  {
    name: 'Oxfordshire',
    region: 'England',
    alias: null,
  },
  {
    name: 'Rutland',
    region: 'England',
    alias: null,
  },
  {
    name: 'Shropshire',
    region: 'England',
    alias: null,
  },
  {
    name: 'Somerset',
    region: 'England',
    alias: null,
  },
  {
    name: 'South Yorkshire',
    region: 'England',
    alias: null,
  },
  {
    name: 'Staffordshire',
    region: 'England',
    alias: null,
  },
  {
    name: 'Suffolk',
    region: 'England',
    alias: null,
  },
  {
    name: 'Surrey',
    region: 'England',
    alias: null,
  },
  {
    name: 'Tyne and Wear',
    region: 'England',
    alias: null,
  },
  {
    name: 'Warwickshire',
    region: 'England',
    alias: null,
  },
  {
    name: 'West Midlands',
    region: 'England',
    alias: null,
  },
  {
    name: 'West Sussex',
    region: 'England',
    alias: null,
  },
  {
    name: 'West Yorkshire',
    region: 'England',
    alias: null,
  },
  {
    name: 'Wiltshire',
    region: 'England',
    alias: null,
  },
  {
    name: 'Worcestershire',
    region: 'England',
    alias: null,
  },
  {
    name: 'Antrim',
    region: 'Northern Ireland',
    alias: null,
  },
  {
    name: 'Down',
    region: 'Northern Ireland',
    alias: null,
  },
  {
    name: 'Fermanagh',
    region: 'Northern Ireland',
    alias: null,
  },
  {
    name: 'Londonderry',
    region: 'Northern Ireland',
    alias: null,
  },
  {
    name: 'Tyrone',
    region: 'Northern Ireland',
    alias: null,
  },
  {
    name: 'Aberdeen City',
    region: 'Scotland',
    alias: null,
  },
  {
    name: 'Aberdeenshire',
    region: 'Scotland',
    alias: null,
  },
  {
    name: 'Angus',
    region: 'Scotland',
    alias: null,
  },
  {
    name: 'Argyll and Bute',
    region: 'Scotland',
    alias: null,
  },
  {
    name: 'Armagh',
    region: 'Scotland',
    alias: null,
  },
  {
    name: 'Carmarthenshire',
    region: 'Scotland',
    alias: null,
  },
  {
    name: 'Clackmannan',
    region: 'Scotland',
    alias: null,
  },
  {
    name: 'Dumfries and Galloway',
    region: 'Scotland',
    alias: null,
  },
  {
    name: 'East Ayrshire',
    region: 'Scotland',
    alias: null,
  },
  {
    name: 'East Dunbartonshire',
    region: 'Scotland',
    alias: null,
  },
  {
    name: 'East Lothian',
    region: 'Scotland',
    alias: null,
  },
  {
    name: 'East Renfrewshire',
    region: 'Scotland',
    alias: null,
  },
  {
    name: 'Edinburgh City',
    region: 'Scotland',
    alias: null,
  },
  {
    name: 'Falkirk',
    region: 'Scotland',
    alias: null,
  },
  {
    name: 'Fife',
    region: 'Scotland',
    alias: null,
  },
  {
    name: 'Glasgow',
    region: 'Scotland',
    alias: null,
  },
  {
    name: 'Highland',
    region: 'Scotland',
    alias: null,
  },
  {
    name: 'Inverclyde',
    region: 'Scotland',
    alias: null,
  },
  {
    name: 'Midlothian',
    region: 'Scotland',
    alias: null,
  },
  {
    name: 'Moray',
    region: 'Scotland',
    alias: null,
  },
  {
    name: 'North Ayrshire',
    region: 'Scotland',
    alias: null,
  },
  {
    name: 'North Lanarkshire',
    region: 'Scotland',
    alias: null,
  },
  {
    name: 'Orkney',
    region: 'Scotland',
    alias: null,
  },
  {
    name: 'Perthshire and Kinross',
    region: 'Scotland',
    alias: null,
  },
  {
    name: 'Renfrewshire',
    region: 'Scotland',
    alias: null,
  },
  {
    name: 'Roxburghshire',
    region: 'Scotland',
    alias: null,
  },
  {
    name: 'Shetland',
    region: 'Scotland',
    alias: null,
  },
  {
    name: 'South Ayrshire',
    region: 'Scotland',
    alias: null,
  },
  {
    name: 'South Lanarkshire',
    region: 'Scotland',
    alias: null,
  },
  {
    name: 'Stirling',
    region: 'Scotland',
    alias: null,
  },
  {
    name: 'West Dunbartonshire',
    region: 'Scotland',
    alias: null,
  },
  {
    name: 'West Lothian',
    region: 'Scotland',
    alias: null,
  },
  {
    name: 'Western Isles',
    region: 'Scotland',
    alias: null,
  },
  {
    name: 'Blaenau Gwent',
    region: 'Wales',
    alias: null,
  },
  {
    name: 'Bridgend',
    region: 'Wales',
    alias: null,
  },
  {
    name: 'Caerphilly',
    region: 'Wales',
    alias: null,
  },
  {
    name: 'Cardiff',
    region: 'Wales',
    alias: null,
  },
  {
    name: 'Ceredigion',
    region: 'Wales',
    alias: null,
  },
  {
    name: 'Conwy',
    region: 'Wales',
    alias: null,
  },
  {
    name: 'Denbighshire',
    region: 'Wales',
    alias: null,
  },
  {
    name: 'Flintshire',
    region: 'Wales',
    alias: null,
  },
  {
    name: 'Gwynedd',
    region: 'Wales',
    alias: null,
  },
  {
    name: 'Isle of Anglesey',
    region: 'Wales',
    alias: null,
  },
  {
    name: 'Merthyr Tydfil',
    region: 'Wales',
    alias: null,
  },
  {
    name: 'Monmouthshire',
    region: 'Wales',
    alias: null,
  },
  {
    name: 'Neath Port Talbot',
    region: 'Wales',
    alias: null,
  },
  {
    name: 'Newport',
    region: 'Wales',
    alias: null,
  },
  {
    name: 'Pembrokeshire',
    region: 'Wales',
    alias: null,
  },
  {
    name: 'Powys',
    region: 'Wales',
    alias: null,
  },
  {
    name: 'Rhondda Cynon Taff',
    region: 'Wales',
    alias: null,
  },
  {
    name: 'Swansea',
    region: 'Wales',
    alias: null,
  },
  {
    name: 'The Vale of Glamorgan',
    region: 'Wales',
    alias: [
      'The Vale',
    ],
  },
  {
    name: 'Torfaen',
    region: 'Wales',
    alias: null,
  },
  {
    name: 'Wrexham',
    region: 'Wales',
    alias: null,
  },
];
const US$1 = [
  {
    short: 'AL',
    name: 'Alabama',
    alias: null,
  },
  {
    short: 'AK',
    name: 'Alaska',
    alias: null,
  },
  {
    short: 'AZ',
    name: 'Arizona',
    alias: null,
  },
  {
    short: 'AR',
    name: 'Arkansas',
    alias: null,
  },
  {
    short: 'CA',
    name: 'California',
    alias: null,
  },
  {
    short: 'CO',
    name: 'Colorado',
    alias: null,
  },
  {
    short: 'CT',
    name: 'Connecticut',
    alias: null,
  },
  {
    short: 'DC',
    name: 'District of Columbia',
    alias: null,
  },
  {
    short: 'DE',
    name: 'Delaware',
    alias: null,
  },
  {
    short: 'FL',
    name: 'Florida',
    alias: null,
  },
  {
    short: 'FM',
    name: 'Micronesia',
    alias: null,
  },
  {
    short: 'GA',
    name: 'Georgia',
    alias: null,
  },
  {
    short: 'HI',
    name: 'Hawaii',
    alias: null,
  },
  {
    short: 'ID',
    name: 'Idaho',
    alias: null,
  },
  {
    short: 'IL',
    name: 'Illinois',
    alias: null,
  },
  {
    short: 'IN',
    name: 'Indiana',
    alias: null,
  },
  {
    short: 'IA',
    name: 'Iowa',
    alias: null,
  },
  {
    short: 'KS',
    name: 'Kansas',
    alias: null,
  },
  {
    short: 'KY',
    name: 'Kentucky',
    alias: null,
  },
  {
    short: 'LA',
    name: 'Louisiana',
    alias: null,
  },
  {
    short: 'ME',
    name: 'Maine',
    alias: null,
  },
  {
    short: 'MD',
    name: 'Maryland',
    alias: null,
  },
  {
    short: 'MA',
    name: 'Massachusetts',
    alias: null,
  },
  {
    short: 'MI',
    name: 'Michigan',
    alias: null,
  },
  {
    short: 'MN',
    name: 'Minnesota',
    alias: null,
  },
  {
    short: 'MH',
    name: 'Marshall Islands',
    alias: null,
  },
  {
    short: 'MS',
    name: 'Mississippi',
    alias: null,
  },
  {
    short: 'MO',
    name: 'Missouri',
    alias: null,
  },
  {
    short: 'MT',
    name: 'Montana',
    alias: null,
  },
  {
    short: 'NE',
    name: 'Nebraska',
    alias: null,
  },
  {
    short: 'NV',
    name: 'Nevada',
    alias: null,
  },
  {
    short: 'NH',
    name: 'New Hampshire',
    alias: null,
  },
  {
    short: 'NJ',
    name: 'New Jersey',
    alias: null,
  },
  {
    short: 'NM',
    name: 'New Mexico',
    alias: null,
  },
  {
    short: 'NY',
    name: 'New York',
    alias: null,
  },
  {
    short: 'NC',
    name: 'North Carolina',
    alias: null,
  },
  {
    short: 'ND',
    name: 'North Dakota',
    alias: null,
  },
  {
    short: 'OH',
    name: 'Ohio',
    alias: null,
  },
  {
    short: 'OK',
    name: 'Oklahoma',
    alias: null,
  },
  {
    short: 'OR',
    name: 'Oregon',
    alias: null,
  },
  {
    short: 'PA',
    name: 'Pennsylvania',
    alias: null,
  },
  {
    short: 'PW',
    name: 'Palau',
    alias: null,
  },
  {
    short: 'RI',
    name: 'Rhode Island',
    alias: null,
  },
  {
    short: 'SC',
    name: 'South Carolina',
    alias: null,
  },
  {
    short: 'SD',
    name: 'South Dakota',
    alias: null,
  },
  {
    short: 'TN',
    name: 'Tennessee',
    alias: null,
  },
  {
    short: 'TX',
    name: 'Texas',
    alias: null,
  },
  {
    short: 'UT',
    name: 'Utah',
    alias: null,
  },
  {
    short: 'VT',
    name: 'Vermont',
    alias: null,
  },
  {
    short: 'VA',
    name: 'Virginia',
    alias: null,
  },
  {
    short: 'WA',
    name: 'Washington',
    alias: null,
  },
  {
    short: 'WV',
    name: 'West Virginia',
    alias: null,
  },
  {
    short: 'WI',
    name: 'Wisconsin',
    alias: null,
  },
  {
    short: 'WY',
    name: 'Wyoming',
    alias: null,
  },
  {
    short: 'AS',
    name: 'American Samoa',
    alias: null,
  },
  {
    short: 'GU',
    name: 'Guam',
    alias: null,
  },
  {
    short: 'MP',
    name: 'Northern Mariana Islands',
    alias: null,
  },
  {
    short: 'PR',
    name: 'Puerto Rico',
    alias: null,
  },
  {
    short: 'UM',
    name: 'United States Minor Outlying Islands',
    alias: null,
  },
  {
    short: 'VI',
    name: 'Virgin Islands',
    alias: null,
  },
];
const VN$1 = [
  {
    name: 'Hà Nội',
    alias: [
      'Ha Noi',
    ],
  },
  {
    name: 'Hà Giang',
    alias: [
      'Ha Giang',
    ],
  },
  {
    name: 'Cao Bằng',
    alias: [
      'Cao Bang',
    ],
  },
  {
    name: 'Bắc Kạn',
    alias: [
      'Bac Kan',
    ],
  },
  {
    name: 'Tuyên Quang',
    alias: [
      'Tuyen Quang',
    ],
  },
  {
    name: 'Lào Cai',
    alias: [
      'Lao Cai',
    ],
  },
  {
    name: 'Điện Biên',
    alias: [
      'Dien Bien',
    ],
  },
  {
    name: 'Lai Châu',
    alias: [
      'Lai Chau',
    ],
  },
  {
    name: 'Sơn La',
    alias: [
      'Son La',
    ],
  },
  {
    name: 'Yên Bái',
    alias: [
      'Yen Bai',
    ],
  },
  {
    name: 'Hòa Bình',
    alias: [
      'Hoa Binh',
    ],
  },
  {
    name: 'Thái Nguyên',
    alias: [
      'Thai Nguyen',
    ],
  },
  {
    name: 'Lạng Sơn',
    alias: [
      'Lang Son',
    ],
  },
  {
    name: 'Quảng Ninh',
    alias: [
      'Quang Ninh',
    ],
  },
  {
    name: 'Bắc Giang',
    alias: [
      'Bac Giang',
    ],
  },
  {
    name: 'Phú Thọ',
    alias: [
      'Phu Tho',
    ],
  },
  {
    name: 'Vĩnh Phúc',
    alias: [
      'Vinh Phuc',
    ],
  },
  {
    name: 'Bắc Ninh',
    alias: [
      'Bac Ninh',
    ],
  },
  {
    name: 'Hải Dương',
    alias: [
      'Hai Duong',
    ],
  },
  {
    name: 'Hải Phòng',
    alias: [
      'Hai Phong',
    ],
  },
  {
    name: 'Hưng Yên',
    alias: [
      'Hung Yen',
    ],
  },
  {
    name: 'Thái Bình',
    alias: [
      'Thai Binh',
    ],
  },
  {
    name: 'Hà Nam',
    alias: [
      'Ha Nam',
    ],
  },
  {
    name: 'Nam Định',
    alias: [
      'Nam Dinh',
    ],
  },
  {
    name: 'Ninh Bình',
    alias: [
      'Ninh Binh',
    ],
  },
  {
    name: 'Thanh Hóa',
    alias: [
      'Thanh Hoa',
    ],
  },
  {
    name: 'Nghệ An',
    alias: [
      'Nghe An',
    ],
  },
  {
    name: 'Hà Tĩnh',
    alias: [
      'Ha Tinh',
    ],
  },
  {
    name: 'Quảng Bình',
    alias: [
      'Quang Binh',
    ],
  },
  {
    name: 'Quảng Trị',
    alias: [
      'Quang Tri',
    ],
  },
  {
    name: 'Thừa Thiên–Huế',
    alias: [
      'Thua Thien–Hue',
      'Thua Thien Hue',
    ],
  },
  {
    name: 'Đà Nẵng',
    alias: [
      'Da Nang',
    ],
  },
  {
    name: 'Quảng Nam',
    alias: [
      'Quang Nam',
    ],
  },
  {
    name: 'Quảng Ngãi',
    alias: [
      'Quang Ngai',
    ],
  },
  {
    name: 'Bình Định',
    alias: [
      'Binh Dinh',
    ],
  },
  {
    name: 'Phú Yên',
    alias: [
      'Phu Yen',
    ],
  },
  {
    name: 'Khánh Hòa',
    alias: [
      'Khanh Hoa',
    ],
  },
  {
    name: 'Ninh Thuận',
    alias: [
      'Ninh Thuan',
    ],
  },
  {
    name: 'Bình Thuận',
    alias: [
      'Binh Thuan',
    ],
  },
  {
    name: 'Kon Tum',
    alias: null,
  },
  {
    name: 'Gia Lai',
    alias: null,
  },
  {
    name: 'Đắk Lắk',
    alias: [
      'Dak Lak',
    ],
  },
  {
    name: 'Đắk Nông',
    alias: [
      'Dak Nong',
    ],
  },
  {
    name: 'Lâm Đồng',
    alias: [
      'Lam Dong',
    ],
  },
  {
    name: 'Bình Phước',
    alias: 'Binh Phuoc',
  },
  {
    name: 'Tây Ninh',
    alias: [
      'Tay Ninh',
    ],
  },
  {
    name: 'Bình Dương',
    alias: [
      'Binh Duong',
    ],
  },
  {
    name: 'Đồng Nai',
    alias: [
      'Dong Nai',
    ],
  },
  {
    name: 'Bà Rịa–Vũng Tàu',
    alias: [
      'Ba Ria–Vung Tau',
      'Ba Ria Vung Tau',
    ],
  },
  {
    name: 'Thành phố Hồ Chí Minh',
    alias: [
      'Thanh pho Ho Chi Minh',
    ],
  },
  {
    name: 'Long An',
    alias: null,
  },
  {
    name: 'Tiền Giang',
    alias: [
      'Tien Giang',
    ],
  },
  {
    name: 'Bến Tre',
    alias: [
      'Ben Tre',
    ],
  },
  {
    name: 'Trà Vinh',
    alias: [
      'Tra Vinh',
    ],
  },
  {
    name: 'Vĩnh Long',
    alias: [
      'Vinh Long',
    ],
  },
  {
    name: 'Đồng Tháp',
    alias: [
      'Dong Thap',
    ],
  },
  {
    name: 'An Giang',
    alias: null,
  },
  {
    name: 'Kiên Giang',
    alias: [
      'Kien Giang',
    ],
  },
  {
    name: 'Cần Thơ',
    alias: [
      'Can Thơ',
    ],
  },
  {
    name: 'Hậu Giang',
    alias: [
      'Hau Giang',
    ],
  },
  {
    name: 'Sóc Trăng',
    alias: [
      'Soc Trang',
    ],
  },
  {
    name: 'Bạc Liêu',
    alias: [
      'Bac Lieu',
    ],
  },
  {
    name: 'Cà Mau',
    alias: [
      'Ca Mau',
    ],
  },
];
const IT$1 = [
  {
    short: 'AG',
    name: 'Agrigento',
    alias: null,
  },
  {
    short: 'AL',
    name: 'Alessandria',
    alias: null,
  },
  {
    short: 'AN',
    name: 'Ancona',
    alias: null,
  },
  {
    short: 'AO',
    name: 'Aosta',
    alias: null,
  },
  {
    short: 'AR',
    name: 'Arezzo',
    alias: null,
  },
  {
    short: 'AP',
    name: 'Ascoli Piceno',
    alias: null,
  },
  {
    short: 'AT',
    name: 'Asti',
    alias: null,
  },
  {
    short: 'AV',
    name: 'Avellino',
    alias: null,
  },
  {
    short: 'BA',
    name: 'Bari',
    alias: null,
  },
  {
    short: 'BT',
    name: 'Barletta-Andria-Trani',
    alias: null,
  },
  {
    short: 'BL',
    name: 'Belluno',
    alias: null,
  },
  {
    short: 'BN',
    name: 'Benevento',
    alias: null,
  },
  {
    short: 'BG',
    name: 'Bergamo',
    alias: null,
  },
  {
    short: 'BI',
    name: 'Biella',
    alias: null,
  },
  {
    short: 'BO',
    name: 'Bologna',
    alias: null,
  },
  {
    short: 'BZ',
    name: 'Bolzano',
    alias: null,
  },
  {
    short: 'BS',
    name: 'Brescia',
    alias: null,
  },
  {
    short: 'BR',
    name: 'Brindisi',
    alias: null,
  },
  {
    short: 'CA',
    name: 'Cagliari',
    alias: null,
  },
  {
    short: 'CL',
    name: 'Caltanissetta',
    alias: null,
  },
  {
    short: 'CB',
    name: 'Campobasso',
    alias: null,
  },
  {
    short: 'CE',
    name: 'Caserta',
    alias: null,
  },
  {
    short: 'CT',
    name: 'Catania',
    alias: null,
  },
  {
    short: 'CZ',
    name: 'Catanzaro',
    alias: null,
  },
  {
    short: 'CH',
    name: 'Chieti',
    alias: null,
  },
  {
    short: 'CO',
    name: 'Como',
    alias: null,
  },
  {
    short: 'CS',
    name: 'Cosenza',
    alias: null,
  },
  {
    short: 'CR',
    name: 'Cremona',
    alias: null,
  },
  {
    short: 'KR',
    name: 'Crotone',
    alias: null,
  },
  {
    short: 'CN',
    name: 'Cuneo',
    alias: null,
  },
  {
    short: 'EN',
    name: 'Enna',
    alias: null,
  },
  {
    short: 'FM',
    name: 'Fermo',
    alias: null,
  },
  {
    short: 'FE',
    name: 'Ferrara',
    alias: null,
  },
  {
    short: 'FI',
    name: 'Firenze',
    alias: null,
  },
  {
    short: 'FG',
    name: 'Foggia',
    alias: null,
  },
  {
    short: 'FC',
    name: 'Forlì-Cesena',
    alias: null,
  },
  {
    short: 'FR',
    name: 'Frosinone',
    alias: null,
  },
  {
    short: 'GE',
    name: 'Genova',
    alias: null,
  },
  {
    short: 'GO',
    name: 'Gorizia',
    alias: null,
  },
  {
    short: 'GR',
    name: 'Grosseto',
    alias: null,
  },
  {
    short: 'IM',
    name: 'Imperia',
    alias: null,
  },
  {
    short: 'IS',
    name: 'Isernia',
    alias: null,
  },
  {
    short: 'AQ',
    name: "L'Aquila",
    alias: null,
  },
  {
    short: 'SP',
    name: 'La Spezia',
    alias: null,
  },
  {
    short: 'LT',
    name: 'Latina',
    alias: null,
  },
  {
    short: 'LE',
    name: 'Lecce',
    alias: null,
  },
  {
    short: 'LC',
    name: 'Lecco',
    alias: null,
  },
  {
    short: 'LI',
    name: 'Livorno',
    alias: null,
  },
  {
    short: 'LO',
    name: 'Lodi',
    alias: null,
  },
  {
    short: 'LU',
    name: 'Lucca',
    alias: null,
  },
  {
    short: 'MC',
    name: 'Macerata',
    alias: null,
  },
  {
    short: 'MN',
    name: 'Mantova',
    alias: null,
  },
  {
    short: 'MS',
    name: 'Massa-Carrara',
    alias: null,
  },
  {
    short: 'MT',
    name: 'Matera',
    alias: null,
  },
  {
    short: 'ME',
    name: 'Messina',
    alias: null,
  },
  {
    short: 'MI',
    name: 'Milano',
    alias: null,
  },
  {
    short: 'MO',
    name: 'Modena',
    alias: null,
  },
  {
    short: 'MB',
    name: 'Monza e della Brianza',
    alias: null,
  },
  {
    short: 'NA',
    name: 'Napoli',
    alias: null,
  },
  {
    short: 'NO',
    name: 'Novara',
    alias: null,
  },
  {
    short: 'NU',
    name: 'Nuoro',
    alias: null,
  },
  {
    short: 'OR',
    name: 'Oristano',
    alias: null,
  },
  {
    short: 'PD',
    name: 'Padova',
    alias: null,
  },
  {
    short: 'PA',
    name: 'Palermo',
    alias: null,
  },
  {
    short: 'PR',
    name: 'Parma',
    alias: null,
  },
  {
    short: 'PV',
    name: 'Pavia',
    alias: null,
  },
  {
    short: 'PG',
    name: 'Perugia',
    alias: null,
  },
  {
    short: 'PU',
    name: 'Pesaro e Urbino',
    alias: null,
  },
  {
    short: 'PE',
    name: 'Pescara',
    alias: null,
  },
  {
    short: 'PC',
    name: 'Piacenza',
    alias: null,
  },
  {
    short: 'PI',
    name: 'Pisa',
    alias: null,
  },
  {
    short: 'PT',
    name: 'Pistoia',
    alias: null,
  },
  {
    short: 'PN',
    name: 'Pordenone',
    alias: null,
  },
  {
    short: 'PZ',
    name: 'Potenza',
    alias: null,
  },
  {
    short: 'PO',
    name: 'Prato',
    alias: null,
  },
  {
    short: 'RG',
    name: 'Ragusa',
    alias: null,
  },
  {
    short: 'RA',
    name: 'Ravenna',
    alias: null,
  },
  {
    short: 'RC',
    name: 'Reggio Calabria',
    alias: null,
  },
  {
    short: 'RE',
    name: 'Reggio Emilia',
    alias: null,
  },
  {
    short: 'RI',
    name: 'Rieti',
    alias: null,
  },
  {
    short: 'RN',
    name: 'Rimini',
    alias: null,
  },
  {
    short: 'RM',
    name: 'Roma',
    alias: null,
  },
  {
    short: 'RO',
    name: 'Rovigo',
    alias: null,
  },
  {
    short: 'SA',
    name: 'Salerno',
    alias: null,
  },
  {
    short: 'SS',
    name: 'Sassari',
    alias: null,
  },
  {
    short: 'SV',
    name: 'Savona',
    alias: null,
  },
  {
    short: 'SI',
    name: 'Siena',
    alias: null,
  },
  {
    short: 'SR',
    name: 'Siracusa',
    alias: null,
  },
  {
    short: 'SO',
    name: 'Sondrio',
    alias: null,
  },
  {
    short: 'TA',
    name: 'Taranto',
    alias: null,
  },
  {
    short: 'TE',
    name: 'Teramo',
    alias: null,
  },
  {
    short: 'TR',
    name: 'Terni',
    alias: null,
  },
  {
    short: 'TO',
    name: 'Torino',
    alias: null,
  },
  {
    short: 'TP',
    name: 'Trapani',
    alias: null,
  },
  {
    short: 'TN',
    name: 'Trento',
    alias: null,
  },
  {
    short: 'TV',
    name: 'Treviso',
    alias: null,
  },
  {
    short: 'TS',
    name: 'Trieste',
    alias: null,
  },
  {
    short: 'UD',
    name: 'Udine',
    alias: null,
  },
  {
    short: 'VA',
    name: 'Varese',
    alias: null,
  },
  {
    short: 'VE',
    name: 'Venezia',
    alias: null,
  },
  {
    short: 'VB',
    name: 'Verbano-Cusio-Ossola',
    alias: null,
  },
  {
    short: 'VC',
    name: 'Vercelli',
    alias: null,
  },
  {
    short: 'VR',
    name: 'Verona',
    alias: null,
  },
  {
    short: 'VV',
    name: 'Vibo Valentia',
    alias: null,
  },
  {
    short: 'VI',
    name: 'Vicenza',
    alias: null,
  },
  {
    short: 'VT',
    name: 'Viterbo',
    alias: null,
  },
];
const require$$9$1 = {
  AR: AR$1,
  AT: AT$1,
  AU: AU$1,
  BD: BD$1,
  BE: BE$1,
  BO: BO$1,
  BR: BR$1,
  CA: CA$1,
  CL: CL$1,
  CN: CN$1,
  CU: CU$1,
  DE: DE$1,
  DK: DK$1,
  ES: ES$1,
  ET: ET$1,
  ID: ID$1,
  IN: IN$1,
  JO: JO$1,
  JP: JP$1,
  KH: KH$1,
  MX: MX$1,
  NG: NG$1,
  NL: NL$1,
  PE: PE$1,
  PH: PH$1,
  PK: PK$1,
  TR: TR$1,
  GB: GB$1,
  US: US$1,
  VN: VN$1,
  IT: IT$1,
};
var self$1 = countryListJs.exports = {
  all: {},
  cache: {},
  findByIso2: (code2) => x(self$1.all[code2]),
  findByIso3: (code2) => find('iso3', code2),
  findByName: (name) => find('name', name),
  findByCapital: (name) => find('capital', name),
  findByCurrency: (code2) => find('currency', code2),
  findByProvince(name) {
    if (!self$1.cache.province)
      self$1.cache.province = {};
    if (self$1.cache.province[name])
      return self$1.cache.province[name].map((o) => x(o));
    return self$1.cache.province[name] = Object.keys(self$1.all).map((k) => self$1.all[k]).filter((o) => o.provinces).filter(
      (o) => o.provinces.filter(
        (o2) => o2.name == name || (o2.alias || []).indexOf(name) > -1,
      ).length > 0,
    ).map((o) => x(o)).unpack(void 0);
  },
  findByPhoneNbr(nbr) {
    nbr = nbr.replace(/\D/g, '');
    return phones.filter((o) => o.nbr && nbr.startsWith(o.nbr)).map((o) => x(self$1.all[o.code])).unpack(void 0);
  },
  ls(field) {
    return Object.keys(this.all).map((k) => this.all[k][field]);
  },
  continents() {
    return this.ls('continent').unique();
  },
  names() {
    return this.ls('name');
  },
  capitals() {
    return this.ls('capital');
  },
};
function x(o) {
  if (!o)
    return;
  if (Array.isArray(o))
    return o.map(x(o));
  var ret = Object.assign({}, o);
  ret.currency = {
    code: ret.currency,
    symbol: ret.currency_symbol,
    decimal: ret.currency_decimal,
  };
  ret.code = { iso2: ret.iso2, iso3: ret.iso3 };
  for (var k of 'iso2|iso3|currency_symbol|currency_decimal'.split('|'))
    delete ret[k];
  return ret;
}
function find(prop, val) {
  if (!(prop in self$1.cache))
    self$1.cache[prop] = {};
  if (self$1.cache[prop][val])
    return self$1.cache[prop][val];
  return self$1.cache[prop][val] = Object.keys(self$1.all).filter((k) => self$1.all[k][prop] == val).map((k) => x(self$1.all[k])).unpack(void 0);
}
var continents = require$$0$2;
var continent = require$$1$2;
var iso_alpha_3 = require$$2$1;
var capital = require$$3$1;
var currency = require$$4$1;
var currency_info = require$$5$1;
var names = require$$6$1;
var phone = require$$7$1;
var regions = require$$8$1;
var provinces = require$$9$1;
Object.keys(iso_alpha_3).forEach(function (k) {
  self$1.all[k] = {
    iso2: k,
    iso3: iso_alpha_3[k],
    name: names[k],
    continent: continents[continent[k]],
    region: regions[k],
    capital: capital[k],
    currency: currency[k],
    currency_symbol: currency_info[currency[k]].symbol,
    currency_decimal: currency_info[currency[k]].decimal,
    dialing_code: phone[k],
    provinces: provinces[k],
  };
});
continents = continent = iso_alpha_3 = capital = currency = currency_info = names = regions = provinces = null;
var phones = Object.keys(phone).map(function (k) {
  return { code: k, nbr: phone[k].replace(/\D/g, '') };
});
phones.sort((a, b) => a.nbr.length < b.nbr.length ? 1 : -1);
phone = null;
Array.prototype.unpack = function () {
  var l = this.length;
  return l == 1 ? this[0] : l == 0 && arguments.length > 0 ? void 0 : this;
};
Array.prototype.unique = function () {
  return this.filter((e, pos) => this.indexOf(e) == pos);
};
var countryListJsExports = countryListJs.exports;
const countrys = /* @__PURE__ */ getDefaultExportFromCjs(countryListJsExports);
const containerForDate = createElement$1({
  tag: 'label',
  classNames: ['reg-form__date-container'],
});
const errorDateReg = createErrorElement();
errorDateReg.classList.add('error-date');
const dayDate = createElement$1({
  tag: 'input',
  classNames: ['date__day', 'reg-input', 'date-input'],
  attributes: {
    type: 'text',
    maxLength: '2',
    'data-validation-type': 'day',
    hide: '',
  },
});
const monthDate = createElement$1({
  tag: 'input',
  classNames: ['date__month', 'reg-input', 'date-input'],
  attributes: {
    type: 'text',
    maxLength: '2',
    'data-validation-type': 'month',
    hide: '',
  },
});
const yearDate = createElement$1({
  tag: 'input',
  classNames: ['date__year', 'reg-input', 'date-input'],
  attributes: {
    type: 'text',
    maxLength: '4',
    'data-validation-type': 'year',
  },
});
function addDate() {
  const regFormLabelDateParams = {
    tag: 'label',
    classNames: ['reg-form__date-label', 'reg__label'],
    textContent: 'Date of birth',
  };
  const regFormLabelDate = createElement$1(regFormLabelDateParams);
  regFormLabelDate.append(errorDateReg);
  regFormLabelDate.append(containerForDate);
  containerForDate.append(dayDate);
  containerForDate.append(monthDate);
  containerForDate.append(yearDate);
  dayDate.addEventListener('input', validateInput);
  dayDate.addEventListener('input', checkNumber);
  monthDate.addEventListener('input', validateInput);
  monthDate.addEventListener('input', checkNumber);
  yearDate.addEventListener('input', validateInput);
  yearDate.addEventListener('input', checkNumber);
  return regFormLabelDate;
}
function searchCountry() {
  const countyItems = document.querySelectorAll('.address__countries-item');
  const value = this.value.toLowerCase();
  countyItems.forEach((user) => {
    var _a;
    const userText = ((_a = user.textContent) == null ? void 0 : _a.toLowerCase()) || '';
    let match = true;
    for (let i = 0; i < value.length; i++) {
      if (userText[i] !== value[i]) {
        match = false;
        break;
      }
    }
    if (!match) {
      user.style.display = 'none';
    } else {
      user.style.display = 'flex';
    }
  });
}
function addCountriesList() {
  var _a, _b;
  const countries = countrys.names().sort();
  const wrapperText = this.textContent;
  const input = this.previousSibling;
  const post = (_b = (_a = this.parentElement) == null ? void 0 : _a.nextElementSibling) == null ? void 0 : _b.firstElementChild;
  this.textContent = '';
  this.classList.add('--expanded');
  input.classList.add('countries-input--expanded');
  input.addEventListener('input', searchCountry);
  const clickHandler = (e) => {
    outClick(e, this, post, input, clickHandler, wrapperText);
  };
  if (this.classList.contains('--expanded')) {
    document.addEventListener('click', clickHandler, true);
  }
  countries.forEach((e) => {
    const countriesItem = createElement$1({
      tag: 'div',
      classNames: ['address__countries-item'],
    });
    countriesItem.textContent = e;
    this.append(countriesItem);
    countriesItem.addEventListener('click', (element) => {
      document.removeEventListener('click', clickHandler);
      this.removeEventListener('click', addCountriesList);
      disableLocation(this);
      post.removeAttribute('disabled');
      input.classList.remove('countries-input--expanded');
      this.classList.remove('--expanded');
      this.textContent = countriesItem.textContent;
      element.stopPropagation();
    });
  });
}
function outClick(e, wrapper, post, input, clickHandler, text) {
  if (e.target !== wrapper) {
    if (e.target == input) {
      return;
    } else if (wrapper.classList.contains('--expanded')) {
      wrapper.removeEventListener('click', addCountriesList);
      document.removeEventListener('click', clickHandler);
      wrapper.textContent = text;
      post.removeAttribute('disabled');
      input.classList.remove('countries-input--expanded');
      wrapper.classList.remove('--expanded');
    } else {
      wrapper.removeEventListener('click', addCountriesList);
      document.removeEventListener('click', clickHandler);
    }
  }
}
function createAddressComponents(type) {
  const container = createElement$1({
    tag: 'div',
    classNames: [`${type}__container`],
  });
  const labelStreet = createElement$1({
    tag: 'label',
    classNames: [`${type}__street-label`, 'reg__label', 'label-street'],
    textContent: 'Address',
  });
  const inputStreet = createElement$1({
    tag: 'input',
    classNames: [`${type}__street-input`, 'reg-input', 'input-street'],
    attributes: {
      type: 'text',
      'data-validation-type': 'street',
      'validation-element': `${type}`,
      disabled: '',
    },
  });
  const errorStreet = createErrorElement();
  labelStreet.append(inputStreet);
  labelStreet.append(errorStreet);
  const labelCity = createElement$1({
    tag: 'label',
    classNames: [`${type}__city-label`, 'reg__label', 'label-city'],
    textContent: 'City',
  });
  const inputCity = createElement$1({
    tag: 'input',
    classNames: [`${type}__city-input`, 'reg-input', 'input-city'],
    attributes: {
      type: 'text',
      'data-validation-type': 'city',
      'validation-element': `${type}`,
      disabled: '',
    },
  });
  const errorCity = createErrorElement();
  labelCity.appendChild(inputCity);
  labelCity.appendChild(errorCity);
  const labelPost = createElement$1({
    tag: 'label',
    classNames: [`${type}__post-label`, 'reg__label', 'label-post'],
    textContent: 'Post',
  });
  const inputPost = createElement$1({
    tag: 'input',
    classNames: [`${type}__post-input`, 'reg-input', 'input-post'],
    attributes: {
      type: 'text',
      'data-validation-type': 'post',
      'validation-element': `${type}`,
      disabled: '',
    },
  });
  inputPost.addEventListener('input', function (event2) {
    validateInput(event2);
  });
  const errorPost = createErrorElement();
  labelPost.append(inputPost);
  labelPost.append(errorPost);
  const labelCountry = createElement$1({
    tag: 'label',
    classNames: [`${type}__country-label`, 'reg__label'],
    textContent: `${type === 'billing' ? 'Billing' : 'Shipping'} address`,
  });
  const listCountry = createElement$1({
    tag: 'div',
    classNames: [`${type}__countries-list`, 'countries-list'],
    textContent: 'Choose your country',
  });
  const inputCountry = createElement$1({
    tag: 'input',
    classNames: [`${type}__countries-input`, 'reg-input'],
    attributes: { type: 'text', placeholder: 'Enter your country', hide: '' },
  });
  const countryWrapper = createElement$1({
    tag: 'div',
    classNames: [`${type}__country-wrapper`, 'country-wrapper'],
  });
  countryWrapper.append(inputCountry, listCountry);
  labelCountry.append(countryWrapper);
  inputStreet.addEventListener('input', validateInput);
  inputCity.addEventListener('input', validateInput);
  inputPost.addEventListener('input', validateInput);
  listCountry.addEventListener('click', addCountriesList, true);
  container.append(
    labelCountry,
    countryWrapper,
    labelPost,
    labelCity,
    labelStreet,
  );
  return {
    container,
    labelStreet,
    inputStreet,
    errorStreet,
    labelCity,
    inputCity,
    errorCity,
    labelPost,
    inputPost,
    errorPost,
    labelCountry,
    listCountry,
    inputCountry,
    countryWrapper,
  };
}
const billingComponents = createAddressComponents('billing');
const shippingComponents = createAddressComponents('shipping');
const addressesContainer = createElement$1({
  tag: 'div',
  classNames: ['addresses-container'],
});
addressesContainer.append(
  shippingComponents.container,
  billingComponents.container,
);
const validStatusAddress = {
  shippingIsDefault: false,
  billingIsDefault: false,
  joinAddress: false,
};
function setValidStatusAddress(field, value) {
  validStatusAddress[field] = value;
}
function joinChecked() {
  if (shippingComponents.inputCountry.form) {
    setValidStatusAddress('joinAddress', true);
    shippingComponents.container.classList.add('shipping__container--join');
    billingComponents.container.remove();
    fillObjectWithUniqueKeys(
      shippingComponents.inputCountry.form,
      false,
      validStatus,
    );
    checkAllInputs();
  }
}
function joinUnchecked() {
  if (shippingComponents.inputCountry.form) {
    shippingComponents.container.classList.remove('shipping__container--join');
    addressesContainer.append(billingComponents.container);
    fillObjectWithUniqueKeys(
      shippingComponents.inputCountry.form,
      false,
      validStatus,
    );
    setValidStatusAddress('joinAddress', false);
    checkAllInputs();
  }
}
function addDefaultChecks() {
  const checkContainerParams = {
    tag: 'div',
    classNames: ['reg-form__container-checkbox'],
  };
  const defaultBillingLabelParams = {
    tag: 'label',
    classNames: ['reg-form__billing-checkbox', 'default__label'],
    textContent: 'Use as default billing address',
  };
  const defaultBillingCheckParams = {
    tag: 'input',
    classNames: ['reg-form__billing-checkbox'],
    attributes: { type: 'checkbox' },
  };
  const checkContainer = createElement$1(checkContainerParams);
  const defaultBillingLabel = createElement$1(defaultBillingLabelParams);
  const defaultBillingCheck = createElement$1(
    defaultBillingCheckParams,
  );
  defaultBillingCheck.addEventListener('click', () => {
    if (defaultBillingCheck.checked) {
      setValidStatusAddress('billingIsDefault', true);
    } else {
      setValidStatusAddress('billingIsDefault', false);
    }
  });
  const defaultShippingLabelParams = {
    tag: 'label',
    classNames: ['reg-form__shipping-checkbox', 'default__label'],
    textContent: 'Use as default shipping address',
  };
  const defaultShippingCheckParams = {
    tag: 'input',
    classNames: ['reg-form__shipping-checkbox'],
    attributes: { type: 'checkbox' },
  };
  const defaultShippingLabel = createElement$1(defaultShippingLabelParams);
  const defaultShippingCheck = createElement$1(
    defaultShippingCheckParams,
  );
  defaultShippingCheck.addEventListener('click', () => {
    if (defaultShippingCheck.checked) {
      setValidStatusAddress('shippingIsDefault', true);
    } else {
      setValidStatusAddress('shippingIsDefault', false);
    }
  });
  addInnerComponent(checkContainer, defaultBillingLabel);
  addInnerComponent(checkContainer, defaultShippingLabel);
  addInnerComponent(defaultBillingLabel, defaultBillingCheck);
  addInnerComponent(defaultShippingLabel, defaultShippingCheck);
  return checkContainer;
}
function createDefaultCheck() {
  const defaultLabelParams = {
    tag: 'label',
    classNames: ['reg-form__default-label', 'reg__label'],
  };
  const defaultLabel = createElement$1(defaultLabelParams);
  const defaultJoinAddressLabelParams = {
    tag: 'label',
    classNames: ['reg-form__join-label', 'default__label'],
    textContent: 'Billing address is the same as the shipping address',
  };
  const defaultJoinAddressCheckParams = {
    tag: 'input',
    classNames: ['reg-form__join-check'],
    attributes: { type: 'checkbox' },
  };
  const defaultJoinAddressLabel = createElement$1(defaultJoinAddressLabelParams);
  const defaultJoinAddressCheck = createElement$1(
    defaultJoinAddressCheckParams,
  );
  defaultJoinAddressCheck.addEventListener('click', () => {
    if (defaultJoinAddressCheck.checked) {
      joinChecked();
    } else {
      joinUnchecked();
    }
  });
  addInnerComponent(defaultLabel, defaultJoinAddressLabel);
  addInnerComponent(defaultJoinAddressLabel, defaultJoinAddressCheck);
  return [defaultLabel, defaultJoinAddressCheck];
}
function createCommonFormContainer() {
  const containerParams = {
    tag: 'div',
    classNames: ['reg-form__common-inf-container'],
  };
  const container = createElement$1(containerParams);
  const namesContainerParams = {
    tag: 'div',
    classNames: ['common-inputs-container__names-container'],
  };
  const labelNameParams = {
    tag: 'label',
    classNames: ['names-сontainer__name-label', 'reg__label'],
    textContent: 'Name',
  };
  const inputNameParams = {
    tag: 'input',
    classNames: ['names-сontainer-input', 'reg-input', 'common--input'],
    attributes: { type: 'text', 'data-validation-type': 'name' },
  };
  const labelLastNameParams = {
    tag: 'label',
    classNames: ['names-сontainer-name-label', 'reg__label'],
    textContent: 'Last Name',
  };
  const inputLastNameParams = {
    tag: 'input',
    classNames: [
      'names-сontainer__last-name-input',
      'reg-input',
      'common--input',
    ],
    attributes: {
      type: 'text',
      'data-validation-type': 'lastName',
    },
  };
  const namesContainer = createElement$1(namesContainerParams);
  const nameLabel = createElement$1(labelNameParams);
  const inputName = createElement$1(inputNameParams);
  const errorName = createErrorElement();
  const lastNameLabel = createElement$1(labelLastNameParams);
  const inputLastName = createElement$1(inputLastNameParams);
  const errorLastName = createErrorElement();
  addInnerComponent(container, namesContainer);
  addInnerComponent(namesContainer, nameLabel);
  addInnerComponent(nameLabel, inputName);
  addInnerComponent(nameLabel, errorName);
  addInnerComponent(namesContainer, lastNameLabel);
  addInnerComponent(lastNameLabel, inputLastName);
  addInnerComponent(lastNameLabel, errorLastName);
  inputName.addEventListener('input', validateInput);
  inputLastName.addEventListener('input', validateInput);
  const mailPassContainerParams = {
    tag: 'div',
    classNames: ['common-inputs-container__mail-pass-container'],
  };
  const mailPassContainer = createElement$1(mailPassContainerParams);
  const labelMailParams = {
    tag: 'label',
    classNames: ['mail-pass-container__mail-label', 'reg__label'],
    textContent: 'Email',
  };
  const inputMailParams = {
    tag: 'input',
    classNames: [
      'mail-pass-container__mail-input',
      'reg-input',
      'common--input',
    ],
    attributes: {
      type: 'email',
      'data-validation-type': 'email',
    },
  };
  const labelMail = createElement$1(labelMailParams);
  const inputMail = createElement$1(inputMailParams);
  const errorEmail = createErrorElement();
  addInnerComponent(container, mailPassContainer);
  addInnerComponent(mailPassContainer, labelMail);
  addInnerComponent(labelMail, inputMail);
  addInnerComponent(labelMail, errorEmail);
  const LabelPasswordParams = {
    tag: 'label',
    classNames: ['mail-pass-container__password-label', 'reg__label'],
    textContent: 'Password',
  };
  const InputPasswordParams = {
    tag: 'input',
    classNames: [
      'mail-pass-container__password-input',
      'reg-input',
      'common--input',
    ],
    attributes: {
      type: 'password',
      'data-validation-type': 'password',
    },
  };
  const passwordIconParams = {
    tag: 'img',
    attributes: {
      src: '/assets/authpage/hide.png',
      alt: 'make your password visible/hide',
      title: 'Click to make your password visible',
    },
    classNames: ['password_icon'],
  };
  const labelPassword = createElement$1(LabelPasswordParams);
  const inputPassword = createElement$1(InputPasswordParams);
  const passwordIcon = createElement$1(passwordIconParams);
  inputMail.addEventListener('input', validateInput);
  inputPassword.addEventListener('input', validateInput);
  const errorPassword = createErrorElement();
  addInnerComponent(mailPassContainer, labelPassword);
  addInnerComponent(labelPassword, inputPassword);
  addInnerComponent(labelPassword, passwordIcon);
  addInnerComponent(labelPassword, errorPassword);
  inputPassword.addEventListener('keydown', function (event2) {
    if (event2.key === ' ') {
      event2.preventDefault();
    }
  });
  passwordIcon.addEventListener('click', (event2) => {
    event2.preventDefault();
    if (inputPassword.getAttribute('type') === 'password') {
      inputPassword.setAttribute('type', 'text');
      passwordIcon.setAttribute('src', '/assets/authpage/show.png');
      passwordIcon.setAttribute('title', 'Click to hide your password');
    } else {
      inputPassword.setAttribute('type', 'password');
      passwordIcon.setAttribute('src', '/assets/authpage/hide.png');
      passwordIcon.setAttribute('title', 'Click to make your password visible');
    }
  });
  return {
    container,
    inputName,
    inputLastName,
    inputMail,
    inputPassword,
    passwordIcon,
  };
}
const commonFormCompontens = createCommonFormContainer();
async function submitRegData() {
  const name = commonFormCompontens.inputName;
  const lastName = commonFormCompontens.inputLastName;
  const password = commonFormCompontens.inputPassword;
  const mail = commonFormCompontens.inputMail;
  const postShipping = shippingComponents.inputPost;
  const postBilling = billingComponents.inputPost;
  const cityBilling = billingComponents.inputCity;
  const cityShipping = shippingComponents.inputCity;
  const streetShipping = shippingComponents.inputStreet;
  const streetBilling = billingComponents.inputStreet;
  const countryShipping = shippingComponents.listCountry;
  const countryBilling = billingComponents.listCountry;
  const birthDay = dayDate;
  const birthMonth = monthDate;
  const birthYear = yearDate;
  const paddedDay = birthDay.value.padStart(2, '0');
  const paddedMonth = birthMonth.value.padStart(2, '0');
  const paddedYear = birthYear.value.padStart(4, '0');
  const DOB = `${paddedYear}-${paddedMonth}-${paddedDay}`;
  const countryNames = countrys.names();
  const countryBillingIndex = countryNames.indexOf(countryBilling.textContent);
  const countryShippingIndex = countryNames.indexOf(
    countryShipping.textContent,
  );
  let billingPostCode = Object.keys(countrys.all)[countryBillingIndex];
  const shippingPostCode = Object.keys(countrys.all)[countryShippingIndex];
  if (validStatusAddress.joinAddress) {
    billingPostCode = shippingPostCode;
    streetBilling.value = streetShipping.value;
    cityBilling.value = cityShipping.value;
    postBilling.value = postShipping.value;
  }
  const regData = {
    name: name.value,
    lastName: lastName.value,
    password: password.value,
    mailValue: mail.value,
    DOB,
    shippingAddress: {
      isDefault: validStatusAddress.shippingIsDefault,
      country: shippingPostCode,
      postaCode: postShipping.value,
      city: cityShipping.value,
      streetName: streetShipping.value,
    },
    billingAddress: {
      isDefault: validStatusAddress.billingIsDefault,
      country: billingPostCode,
      postaCode: postBilling.value,
      city: cityBilling.value,
      streetName: streetBilling.value,
    },
  };
  await regUser(regData);
}
createErrorElement();
createErrorElement();
const authSideForm = createElement$1({
  tag: 'form',
  classNames: ['auth-side__reg-form'],
});
const regDateAndCheckContainerParams = {
  tag: 'div',
  classNames: ['reg-form__container__date-checks'],
};
const regDateAndCheckContainer = createElement$1(regDateAndCheckContainerParams);
const address = createElement$1({
  tag: 'div',
  classNames: ['reg-form__address'],
});
const authFormButton = createElement$1({
  tag: 'button',
  classNames: ['reg-form__button', 'reg-button'],
  attributes: { type: 'button', disabled: '' },
  textContent: 'Create Account',
});
function createForm() {
  addInnerComponent(authSideForm, commonFormCompontens.container);
  addInnerComponent(authSideForm, regDateAndCheckContainer);
  addInnerComponent(regDateAndCheckContainer, addDate());
  addInnerComponent(authSideForm, createDefaultCheck()[0]);
  addInnerComponent(authSideForm, addressesContainer);
  addInnerComponent(authSideForm, address);
  addInnerComponent(authSideForm, addDefaultChecks());
  addInnerComponent(authSideForm, authFormButton);
  fillObjectWithUniqueKeys(authSideForm, false, validStatus);
  authFormButton.addEventListener('click', submitRegData);
}
let validStatus = {};
function setValidStatus(field, value) {
  validStatus[field] = value;
}
function checkAllInputs(form = null) {
  if (window.location.href.includes('register')) {
    if (Object.values(validStatus).every((value) => value)) {
      authFormButton.removeAttribute('disabled');
    } else {
      authFormButton.setAttribute('disabled', '');
    }
  } else if (window.location.href.includes('login')) {
    const submitButton = document.querySelector('.submit_button');
    if (Object.values(validStatus).every((value) => value)) {
      submitButton == null ? void 0 : submitButton.removeAttribute('disabled');
    } else {
      submitButton == null ? void 0 : submitButton.setAttribute('disabled', '');
    }
  } else if (window.location.href.includes('profile')) {
    const edit = document.querySelector('.profile-header__btn-edit');
    const save = document.querySelector('.password-form__save');
    const addAddress2 = document.querySelector(
      '.profile-header__btn-add-address',
    );
    if (!(form == null ? void 0 : form.classList.contains('modal__password-form'))) {
      if (Object.values(validStatus).every((value) => value)) {
        edit == null ? void 0 : edit.removeAttribute('disabled');
        addAddress2 == null ? void 0 : addAddress2.removeAttribute('disabled');
      } else {
        edit == null ? void 0 : edit.setAttribute('disabled', '');
        addAddress2 == null ? void 0 : addAddress2.setAttribute('disabled', '');
      }
    } else {
      if (Object.values(validStatus).every((value) => value)) {
        save == null ? void 0 : save.removeAttribute('disabled');
      } else {
        save == null ? void 0 : save.setAttribute('disabled', '');
      }
    }
  }
}
function fillObjectWithUniqueKeys(form, value, existingData, clearPrevious = false) {
  if (clearPrevious) {
    existingData = {};
  }
  const formArray = filterArray(form);
  const obj = { ...existingData };
  let counter2 = 1;
  formArray.forEach((e, index) => {
    let key = index.toString();
    while (Object.prototype.hasOwnProperty.call(obj, key)) {
      counter2++;
      key = index.toString() + counter2;
    }
    if (key.includes('Chose Your Country')) {
      obj[key] = false;
    }
    if (key.includes('')) {
      obj[key] = false;
      console.log(e);
    }
    if (!obj[key]) {
      obj[key] = value;
    }
    counter2 = 1;
    if (e.value === 'Chose Your Country') {
      obj[key] = false;
    }
  });
  if (Object.keys(obj).length !== formArray.length) {
    while (Object.keys(obj).length > formArray.length) {
      delete obj[Object.keys(obj).pop()];
    }
    while (Object.keys(obj).length < formArray.length) {
      obj[Object.keys(obj).length.toString()] = true;
    }
  }
  validStatus = obj;
}
const AF = {
  countryName: 'Afghanistan',
  postalCodeFormat: '4Digits.json',
  alpha2: 'AF',
  alpha3: 'AFG',
  numeric3: '4',
};
const AX = {
  countryName: 'Aland Islands',
  postalCodeFormat: 'AX.json',
  alpha2: 'AX',
  alpha3: 'ALA',
  numeric3: '248',
};
const AL = {
  countryName: 'Albania',
  postalCodeFormat: '4Digits.json',
  alpha2: 'AL',
  alpha3: 'ALB',
  numeric3: '8',
};
const DZ = {
  countryName: 'Algeria',
  postalCodeFormat: '5Digits.json',
  alpha2: 'DZ',
  alpha3: 'DZA',
  numeric3: '12',
};
const AS = {
  countryName: 'American Samoa',
  postalCodeFormat: '5Digits.json',
  alpha2: 'AS',
  alpha3: 'ASM',
  numeric3: '16',
};
const AD = {
  countryName: 'Andorra',
  postalCodeFormat: 'AD.json',
  alpha2: 'AD',
  alpha3: 'AND',
  numeric3: '20',
};
const AO = {
  countryName: 'Angola',
  alpha2: 'AO',
  alpha3: 'AGO',
  numeric3: '24',
};
const AI = {
  countryName: 'Anguilla',
  postalCodeFormat: 'AI.json',
  alpha2: 'AI',
  alpha3: 'AIA',
  numeric3: '660',
};
const AQ = {
  countryName: 'Antarctica',
  postalCodeFormat: 'AQ.json',
  alpha2: 'AQ',
  alpha3: 'ATA',
  numeric3: '10',
};
const AG = {
  countryName: 'Antigua and Barbuda',
  alpha2: 'AG',
  alpha3: 'ATG',
  numeric3: '28',
};
const AR = {
  countryName: 'Argentina',
  postalCodeFormat: '4Digits.json',
  alpha2: 'AR',
  alpha3: 'ARG',
  numeric3: '32',
};
const AM = {
  countryName: 'Armenia',
  postalCodeFormat: '4Digits.json',
  alpha2: 'AM',
  alpha3: 'ARM',
  numeric3: '51',
};
const AW = {
  countryName: 'Aruba',
  alpha2: 'AW',
  alpha3: 'ABW',
  numeric3: '533',
};
const AU = {
  countryName: 'Australia',
  postalCodeFormat: '4Digits.json',
  alpha2: 'AU',
  alpha3: 'AUS',
  numeric3: '36',
};
const AT = {
  countryName: 'Austria',
  postalCodeFormat: '4Digits.json',
  alpha2: 'AT',
  alpha3: 'AUT',
  numeric3: '40',
};
const AZ = {
  countryName: 'Azerbaijan',
  postalCodeFormat: 'AZ.json',
  alpha2: 'AZ',
  alpha3: 'AZE',
  numeric3: '31',
};
const BS = {
  countryName: 'Bahamas',
  alpha2: 'BS',
  alpha3: 'BHS',
  numeric3: '44',
};
const BH = {
  countryName: 'Bahrain',
  postalCodeFormat: 'BH.json',
  alpha2: 'BH',
  alpha3: 'BHR',
  numeric3: '48',
};
const BD = {
  countryName: 'Bangladesh',
  postalCodeFormat: '4Digits.json',
  alpha2: 'BD',
  alpha3: 'BGD',
  numeric3: '50',
};
const BB = {
  countryName: 'Barbados',
  postalCodeFormat: 'BB.json',
  alpha2: 'BB',
  alpha3: 'BRB',
  numeric3: '52',
};
const BY = {
  countryName: 'Belarus',
  postalCodeFormat: '6Digits.json',
  alpha2: 'BY',
  alpha3: 'BLR',
  numeric3: '112',
};
const BE = {
  countryName: 'Belgium',
  postalCodeFormat: '4Digits.json',
  alpha2: 'BE',
  alpha3: 'BEL',
  numeric3: '56',
};
const BZ = {
  countryName: 'Belize',
  alpha2: 'BZ',
  alpha3: 'BLZ',
  numeric3: '84',
};
const BJ = {
  countryName: 'Benin',
  alpha2: 'BJ',
  alpha3: 'BEN',
  numeric3: '204',
};
const BM = {
  countryName: 'Bermuda',
  alpha2: 'BM',
  alpha3: 'BMU',
  numeric3: '60',
};
const BT = {
  countryName: 'Bhutan',
  postalCodeFormat: '5Digits.json',
  alpha2: 'BT',
  alpha3: 'BTN',
  numeric3: '64',
};
const BO = {
  countryName: 'Bolivia',
  postalCodeFormat: '4Digits.json',
  alpha2: 'BO',
  alpha3: 'BOL',
  numeric3: '68',
};
const BA = {
  countryName: 'Bosnia and Herzegovina',
  postalCodeFormat: '5Digits.json',
  alpha2: 'BA',
  alpha3: 'BIH',
  numeric3: '70',
};
const BW = {
  countryName: 'Botswana',
  alpha2: 'BW',
  alpha3: 'BWA',
  numeric3: '72',
};
const BV = {
  countryName: 'Bouvet Island',
  alpha2: 'BV',
  alpha3: 'BVT',
  numeric3: '74',
};
const BR = {
  countryName: 'Brazil',
  postalCodeFormat: '8Digits.json',
  alpha2: 'BR',
  alpha3: 'BRA',
  numeric3: '76',
};
const VG = {
  countryName: 'British Virgin Islands',
  postalCodeFormat: 'VG.json',
  alpha2: 'VG',
  alpha3: 'VGB',
  numeric3: '92',
};
const IO = {
  countryName: 'British Indian Ocean Territory',
  postalCodeFormat: 'IO.json',
  alpha2: 'IO',
  alpha3: 'IOT',
  numeric3: '86',
};
const BN = {
  countryName: 'Brunei Darussalam',
  postalCodeFormat: 'BN.json',
  alpha2: 'BN',
  alpha3: 'BRN',
  numeric3: '96',
};
const BG = {
  countryName: 'Bulgaria',
  postalCodeFormat: '4Digits.json',
  alpha2: 'BG',
  alpha3: 'BGR',
  numeric3: '100',
};
const BF = {
  countryName: 'Burkina Faso',
  alpha2: 'BF',
  alpha3: 'BFA',
  numeric3: '854',
};
const BI = {
  countryName: 'Burundi',
  alpha2: 'BI',
  alpha3: 'BDI',
  numeric3: '108',
};
const KH = {
  countryName: 'Cambodia',
  postalCodeFormat: '5Digits.json',
  alpha2: 'KH',
  alpha3: 'KHM',
  numeric3: '116',
};
const CM = {
  countryName: 'Cameroon',
  alpha2: 'CM',
  alpha3: 'CMR',
  numeric3: '120',
};
const CA = {
  countryName: 'Canada',
  postalCodeFormat: 'CA.json',
  alpha2: 'CA',
  alpha3: 'CAN',
  numeric3: '124',
};
const CV = {
  countryName: 'Cape Verde',
  postalCodeFormat: '4Digits.json',
  alpha2: 'CV',
  alpha3: 'CPV',
  numeric3: '132',
};
const KY = {
  countryName: 'Cayman Islands',
  postalCodeFormat: 'KY.json',
  alpha2: 'KY',
  alpha3: 'CYM',
  numeric3: '136',
};
const CF = {
  countryName: 'Central African Republic',
  alpha2: 'CF',
  alpha3: 'CAF',
  numeric3: '140',
};
const TD = {
  countryName: 'Chad',
  postalCodeFormat: '5Digits.json',
  alpha2: 'TD',
  alpha3: 'TCD',
  numeric3: '148',
};
const CL = {
  countryName: 'Chile',
  postalCodeFormat: '7Digits.json',
  alpha2: 'CL',
  alpha3: 'CHL',
  numeric3: '152',
};
const CN = {
  countryName: 'China',
  postalCodeFormat: '6Digits.json',
  alpha2: 'CN',
  alpha3: 'CHN',
  numeric3: '156',
};
const HK = {
  countryName: 'Hong Kong, Special Administrative Region of China',
  alpha2: 'HK',
  alpha3: 'HKG',
  numeric3: '344',
};
const MO = {
  countryName: 'Macao, Special Administrative Region of China',
  alpha2: 'MO',
  alpha3: 'MAC',
  numeric3: '446',
};
const CX = {
  countryName: 'Christmas Island',
  postalCodeFormat: '4Digits.json',
  alpha2: 'CX',
  alpha3: 'CXR',
  numeric3: '162',
};
const CC = {
  countryName: 'Cocos (Keeling) Islands',
  postalCodeFormat: '4Digits.json',
  alpha2: 'CC',
  alpha3: 'CCK',
  numeric3: '166',
};
const CO = {
  countryName: 'Colombia',
  postalCodeFormat: '6Digits.json',
  alpha2: 'CO',
  alpha3: 'COL',
  numeric3: '170',
};
const KM = {
  countryName: 'Comoros',
  alpha2: 'KM',
  alpha3: 'COM',
  numeric3: '174',
};
const CG = {
  countryName: 'Congo (Brazzaville)',
  alpha2: 'CG',
  alpha3: 'COG',
  numeric3: '178',
};
const CD = {
  countryName: 'Congo, Democratic Republic of the',
  alpha2: 'CD',
  alpha3: 'COD',
  numeric3: '180',
};
const CK = {
  countryName: 'Cook Islands',
  alpha2: 'CK',
  alpha3: 'COK',
  numeric3: '184',
};
const CR = {
  countryName: 'Costa Rica',
  postalCodeFormat: '5Digits.json',
  alpha2: 'CR',
  alpha3: 'CRI',
  numeric3: '188',
};
const CI = {
  countryName: "Côte d'Ivoire",
  alpha2: 'CI',
  alpha3: 'CIV',
  numeric3: '384',
};
const HR = {
  countryName: 'Croatia',
  postalCodeFormat: '5Digits.json',
  alpha2: 'HR',
  alpha3: 'HRV',
  numeric3: '191',
};
const CU = {
  countryName: 'Cuba',
  postalCodeFormat: '5Digits.json',
  alpha2: 'CU',
  alpha3: 'CUB',
  numeric3: '192',
};
const CY = {
  countryName: 'Cyprus',
  postalCodeFormat: '4Digits.json',
  alpha2: 'CY',
  alpha3: 'CYP',
  numeric3: '196',
};
const CZ = {
  countryName: 'Czech Republic',
  postalCodeFormat: '5Digits.json',
  alpha2: 'CZ',
  alpha3: 'CZE',
  numeric3: '203',
};
const DK = {
  countryName: 'Denmark',
  postalCodeFormat: 'DK.json',
  alpha2: 'DK',
  alpha3: 'DNK',
  numeric3: '208',
};
const DJ = {
  countryName: 'Djibouti',
  alpha2: 'DJ',
  alpha3: 'DJI',
  numeric3: '262',
};
const DM = {
  countryName: 'Dominica',
  alpha2: 'DM',
  alpha3: 'DMA',
  numeric3: '212',
};
const DO = {
  countryName: 'Dominican Republic',
  postalCodeFormat: '5Digits.json',
  alpha2: 'DO',
  alpha3: 'DOM',
  numeric3: '214',
};
const EC = {
  countryName: 'Ecuador',
  postalCodeFormat: '6Digits.json',
  alpha2: 'EC',
  alpha3: 'ECU',
  numeric3: '218',
};
const EG = {
  countryName: 'Egypt',
  postalCodeFormat: '5Digits.json',
  alpha2: 'EG',
  alpha3: 'EGY',
  numeric3: '818',
};
const SV = {
  countryName: 'El Salvador',
  postalCodeFormat: '4Digits.json',
  alpha2: 'SV',
  alpha3: 'SLV',
  numeric3: '222',
};
const GQ = {
  countryName: 'Equatorial Guinea',
  alpha2: 'GQ',
  alpha3: 'GNQ',
  numeric3: '226',
};
const ER = {
  countryName: 'Eritrea',
  alpha2: 'ER',
  alpha3: 'ERI',
  numeric3: '232',
};
const EE = {
  countryName: 'Estonia',
  postalCodeFormat: '5Digits.json',
  alpha2: 'EE',
  alpha3: 'EST',
  numeric3: '233',
};
const ET = {
  countryName: 'Ethiopia',
  postalCodeFormat: '4Digits.json',
  alpha2: 'ET',
  alpha3: 'ETH',
  numeric3: '231',
};
const FK = {
  countryName: 'Falkland Islands (Malvinas)',
  postalCodeFormat: 'FK.json',
  alpha2: 'FK',
  alpha3: 'FLK',
  numeric3: '238',
};
const FO = {
  countryName: 'Faroe Islands',
  postalCodeFormat: '3Digits.json',
  alpha2: 'FO',
  alpha3: 'FRO',
  numeric3: '234',
};
const FJ = {
  countryName: 'Fiji',
  alpha2: 'FJ',
  alpha3: 'FJI',
  numeric3: '242',
};
const FI = {
  countryName: 'Finland',
  postalCodeFormat: '5Digits.json',
  alpha2: 'FI',
  alpha3: 'FIN',
  numeric3: '246',
};
const FR = {
  countryName: 'France',
  postalCodeFormat: '5Digits.json',
  alpha2: 'FR',
  alpha3: 'FRA',
  numeric3: '250',
};
const GF = {
  countryName: 'French Guiana',
  postalCodeFormat: 'GF.json',
  alpha2: 'GF',
  alpha3: 'GUF',
  numeric3: '254',
};
const PF = {
  countryName: 'French Polynesia',
  postalCodeFormat: 'PF.json',
  alpha2: 'PF',
  alpha3: 'PYF',
  numeric3: '258',
};
const TF = {
  countryName: 'French Southern Territories',
  alpha2: 'TF',
  alpha3: 'ATF',
  numeric3: '260',
};
const GA = {
  countryName: 'Gabon',
  alpha2: 'GA',
  alpha3: 'GAB',
  numeric3: '266',
};
const GM = {
  countryName: 'Gambia',
  alpha2: 'GM',
  alpha3: 'GMB',
  numeric3: '270',
};
const GE = {
  countryName: 'Georgia',
  postalCodeFormat: '4Digits.json',
  alpha2: 'GE',
  alpha3: 'GEO',
  numeric3: '268',
};
const DE = {
  countryName: 'Germany',
  postalCodeFormat: '5Digits.json',
  alpha2: 'DE',
  alpha3: 'DEU',
  numeric3: '276',
};
const GH = {
  countryName: 'Ghana',
  alpha2: 'GH',
  alpha3: 'GHA',
  numeric3: '288',
};
const GI = {
  countryName: 'Gibraltar',
  postalCodeFormat: 'GI.json',
  alpha2: 'GI',
  alpha3: 'GIB',
  numeric3: '292',
};
const GR = {
  countryName: 'Greece',
  postalCodeFormat: '5Digits.json',
  alpha2: 'GR',
  alpha3: 'GRC',
  numeric3: '300',
};
const GL = {
  countryName: 'Greenland',
  postalCodeFormat: '4Digits.json',
  alpha2: 'GL',
  alpha3: 'GRL',
  numeric3: '304',
};
const GD = {
  countryName: 'Grenada',
  alpha2: 'GD',
  alpha3: 'GRD',
  numeric3: '308',
};
const GP = {
  countryName: 'Guadeloupe',
  postalCodeFormat: 'GP.json',
  alpha2: 'GP',
  alpha3: 'GLP',
  numeric3: '312',
};
const GU = {
  countryName: 'Guam',
  postalCodeFormat: 'US.json',
  alpha2: 'GU',
  alpha3: 'GUM',
  numeric3: '316',
};
const GT = {
  countryName: 'Guatemala',
  postalCodeFormat: '5Digits.json',
  alpha2: 'GT',
  alpha3: 'GTM',
  numeric3: '320',
};
const GG = {
  countryName: 'Guernsey',
  postalCodeFormat: 'GG.json',
  alpha2: 'GG',
  alpha3: 'GGY',
  numeric3: '831',
};
const GN = {
  countryName: 'Guinea',
  postalCodeFormat: '3Digits.json',
  alpha2: 'GN',
  alpha3: 'GIN',
  numeric3: '324',
};
const GW = {
  countryName: 'Guinea-Bissau',
  postalCodeFormat: '4Digits.json',
  alpha2: 'GW',
  alpha3: 'GNB',
  numeric3: '624',
};
const GY = {
  countryName: 'Guyana',
  alpha2: 'GY',
  alpha3: 'GUY',
  numeric3: '328',
};
const HT = {
  countryName: 'Haiti',
  postalCodeFormat: '4Digits.json',
  alpha2: 'HT',
  alpha3: 'HTI',
  numeric3: '332',
};
const HM = {
  countryName: 'Heard Island and Mcdonald Islands',
  postalCodeFormat: '4Digits.json',
  alpha2: 'HM',
  alpha3: 'HMD',
  numeric3: '334',
};
const VA = {
  countryName: 'Holy See (Vatican City State)',
  postalCodeFormat: 'VA.json',
  alpha2: 'VA',
  alpha3: 'VAT',
  numeric3: '336',
};
const HN = {
  countryName: 'Honduras',
  postalCodeFormat: 'HN.json',
  alpha2: 'HN',
  alpha3: 'HND',
  numeric3: '340',
};
const HU = {
  countryName: 'Hungary',
  postalCodeFormat: '4Digits.json',
  alpha2: 'HU',
  alpha3: 'HUN',
  numeric3: '348',
};
const IS = {
  countryName: 'Iceland',
  postalCodeFormat: '3Digits.json',
  alpha2: 'IS',
  alpha3: 'ISL',
  numeric3: '352',
};
const IN = {
  countryName: 'India',
  postalCodeFormat: '6Digits.json',
  alpha2: 'IN',
  alpha3: 'IND',
  numeric3: '356',
};
const IC = {
  countryName: 'Canary Islands',
  postalCodeFormat: '5Digits.json',
  alpha2: 'IC',
  alpha3: '',
  numeric3: '',
};
const ID = {
  countryName: 'Indonesia',
  postalCodeFormat: '5Digits.json',
  alpha2: 'ID',
  alpha3: 'IDN',
  numeric3: '360',
};
const IR = {
  countryName: 'Iran, Islamic Republic of',
  postalCodeFormat: '10Digits.json',
  alpha2: 'IR',
  alpha3: 'IRN',
  numeric3: '364',
};
const IQ = {
  countryName: 'Iraq',
  postalCodeFormat: '5Digits.json',
  alpha2: 'IQ',
  alpha3: 'IRQ',
  numeric3: '368',
};
const IE = {
  countryName: 'Ireland',
  postalCodeFormat: 'IE.json',
  alpha2: 'IE',
  alpha3: 'IRL',
  numeric3: '372',
};
const IM = {
  countryName: 'Isle of Man',
  postalCodeFormat: 'IM.json',
  alpha2: 'IM',
  alpha3: 'IMN',
  numeric3: '833',
};
const IL = {
  countryName: 'Israel',
  postalCodeFormat: '7Digits.json',
  alpha2: 'IL',
  alpha3: 'ISR',
  numeric3: '376',
};
const IT = {
  countryName: 'Italy',
  postalCodeFormat: '5Digits.json',
  alpha2: 'IT',
  alpha3: 'ITA',
  numeric3: '380',
};
const JM = {
  countryName: 'Jamaica',
  postalCodeFormat: '2Digits.json',
  alpha2: 'JM',
  alpha3: 'JAM',
  numeric3: '388',
};
const JP = {
  countryName: 'Japan',
  postalCodeFormat: '7Digits.json',
  alpha2: 'JP',
  alpha3: 'JPN',
  numeric3: '392',
};
const JE = {
  countryName: 'Jersey',
  postalCodeFormat: 'JE.json',
  alpha2: 'JE',
  alpha3: 'JEY',
  numeric3: '832',
};
const JO = {
  countryName: 'Jordan',
  postalCodeFormat: '5Digits.json',
  alpha2: 'JO',
  alpha3: 'JOR',
  numeric3: '400',
};
const KZ = {
  countryName: 'Kazakhstan',
  postalCodeFormat: '6Digits.json',
  alpha2: 'KZ',
  alpha3: 'KAZ',
  numeric3: '398',
};
const KE = {
  countryName: 'Kenya',
  postalCodeFormat: '5Digits.json',
  alpha2: 'KE',
  alpha3: 'KEN',
  numeric3: '404',
};
const KI = {
  countryName: 'Kiribati',
  alpha2: 'KI',
  alpha3: 'KIR',
  numeric3: '296',
};
const KP = {
  countryName: "Korea, Democratic People's Republic of",
  alpha2: 'KP',
  alpha3: 'PRK',
  numeric3: '408',
};
const KR = {
  countryName: 'Korea, Republic of',
  postalCodeFormat: '5Digits.json',
  alpha2: 'KR',
  alpha3: 'KOR',
  numeric3: '410',
};
const KW = {
  countryName: 'Kuwait',
  postalCodeFormat: '5Digits.json',
  alpha2: 'KW',
  alpha3: 'KWT',
  numeric3: '414',
};
const KG = {
  countryName: 'Kyrgyzstan',
  postalCodeFormat: '6Digits.json',
  alpha2: 'KG',
  alpha3: 'KGZ',
  numeric3: '417',
};
const LA = {
  countryName: 'Lao PDR',
  postalCodeFormat: '5Digits.json',
  alpha2: 'LA',
  alpha3: 'LAO',
  numeric3: '418',
};
const LV = {
  countryName: 'Latvia',
  postalCodeFormat: 'LV.json',
  alpha2: 'LV',
  alpha3: 'LVA',
  numeric3: '428',
};
const LB = {
  countryName: 'Lebanon',
  postalCodeFormat: 'LB.json',
  alpha2: 'LB',
  alpha3: 'LBN',
  numeric3: '422',
};
const LS = {
  countryName: 'Lesotho',
  postalCodeFormat: '3Digits.json',
  alpha2: 'LS',
  alpha3: 'LSO',
  numeric3: '426',
};
const LR = {
  countryName: 'Liberia',
  postalCodeFormat: '4Digits.json',
  alpha2: 'LR',
  alpha3: 'LBR',
  numeric3: '430',
};
const LY = {
  countryName: 'Libya',
  postalCodeFormat: '5Digits.json',
  alpha2: 'LY',
  alpha3: 'LBY',
  numeric3: '434',
};
const LI = {
  countryName: 'Liechtenstein',
  postalCodeFormat: '4Digits.json',
  alpha2: 'LI',
  alpha3: 'LIE',
  numeric3: '438',
};
const LT = {
  countryName: 'Lithuania',
  postalCodeFormat: 'LT.json',
  alpha2: 'LT',
  alpha3: 'LTU',
  numeric3: '440',
};
const LU = {
  countryName: 'Luxembourg',
  postalCodeFormat: 'LU.json',
  alpha2: 'LU',
  alpha3: 'LUX',
  numeric3: '442',
};
const MK = {
  countryName: 'Macedonia, Republic of',
  postalCodeFormat: '4Digits.json',
  alpha2: 'MK',
  alpha3: 'MKD',
  numeric3: '807',
};
const MG = {
  countryName: 'Madagascar',
  postalCodeFormat: '3Digits.json',
  alpha2: 'MG',
  alpha3: 'MDG',
  numeric3: '450',
};
const MW = {
  countryName: 'Malawi',
  alpha2: 'MW',
  alpha3: 'MWI',
  numeric3: '454',
};
const MY = {
  countryName: 'Malaysia',
  postalCodeFormat: '5Digits.json',
  alpha2: 'MY',
  alpha3: 'MYS',
  numeric3: '458',
};
const MV = {
  countryName: 'Maldives',
  postalCodeFormat: '5Digits.json',
  alpha2: 'MV',
  alpha3: 'MDV',
  numeric3: '462',
};
const ML = {
  countryName: 'Mali',
  alpha2: 'ML',
  alpha3: 'MLI',
  numeric3: '466',
};
const MT = {
  countryName: 'Malta',
  postalCodeFormat: 'MT.json',
  alpha2: 'MT',
  alpha3: 'MLT',
  numeric3: '470',
};
const MH = {
  countryName: 'Marshall Islands',
  postalCodeFormat: 'US.json',
  alpha2: 'MH',
  alpha3: 'MHL',
  numeric3: '584',
};
const MQ = {
  countryName: 'Martinique',
  postalCodeFormat: '5Digits.json',
  alpha2: 'MQ',
  alpha3: 'MTQ',
  numeric3: '474',
};
const MR = {
  countryName: 'Mauritania',
  alpha2: 'MR',
  alpha3: 'MRT',
  numeric3: '478',
};
const MU = {
  countryName: 'Mauritius',
  postalCodeFormat: '5Digits.json',
  alpha2: 'MU',
  alpha3: 'MUS',
  numeric3: '480',
};
const YT = {
  countryName: 'Mayotte',
  postalCodeFormat: '5Digits.json',
  alpha2: 'YT',
  alpha3: 'MYT',
  numeric3: '175',
};
const MX = {
  countryName: 'Mexico',
  postalCodeFormat: '5Digits.json',
  alpha2: 'MX',
  alpha3: 'MEX',
  numeric3: '484',
};
const FM = {
  countryName: 'Micronesia, Federated States of',
  postalCodeFormat: 'US.json',
  alpha2: 'FM',
  alpha3: 'FSM',
  numeric3: '583',
};
const MD = {
  countryName: 'Moldova',
  postalCodeFormat: 'MD.json',
  alpha2: 'MD',
  alpha3: 'MDA',
  numeric3: '498',
};
const MC = {
  countryName: 'Monaco',
  postalCodeFormat: 'MC.json',
  alpha2: 'MC',
  alpha3: 'MCO',
  numeric3: '492',
};
const MN = {
  countryName: 'Mongolia',
  postalCodeFormat: '5Digits.json',
  alpha2: 'MN',
  alpha3: 'MNG',
  numeric3: '496',
};
const ME = {
  countryName: 'Montenegro',
  postalCodeFormat: '5Digits.json',
  alpha2: 'ME',
  alpha3: 'MNE',
  numeric3: '499',
};
const MS = {
  countryName: 'Montserrat',
  postalCodeFormat: 'MS.json',
  alpha2: 'MS',
  alpha3: 'MSR',
  numeric3: '500',
};
const MA = {
  countryName: 'Morocco',
  postalCodeFormat: '5Digits.json',
  alpha2: 'MA',
  alpha3: 'MAR',
  numeric3: '504',
};
const MZ = {
  countryName: 'Mozambique',
  postalCodeFormat: '4Digits.json',
  alpha2: 'MZ',
  alpha3: 'MOZ',
  numeric3: '508',
};
const MM = {
  countryName: 'Myanmar',
  postalCodeFormat: '5Digits.json',
  alpha2: 'MM',
  alpha3: 'MMR',
  numeric3: '104',
};
const NA = {
  countryName: 'Namibia',
  postalCodeFormat: '5Digits.json',
  alpha2: 'NA',
  alpha3: 'NAM',
  numeric3: '516',
};
const NR = {
  countryName: 'Nauru',
  alpha2: 'NR',
  alpha3: 'NRU',
  numeric3: '520',
};
const NP = {
  countryName: 'Nepal',
  postalCodeFormat: '5Digits.json',
  alpha2: 'NP',
  alpha3: 'NPL',
  numeric3: '524',
};
const NL = {
  countryName: 'Netherlands',
  postalCodeFormat: 'NL.json',
  alpha2: 'NL',
  alpha3: 'NLD',
  numeric3: '528',
};
const AN = {
  countryName: 'Netherlands Antilles',
  alpha2: 'AN',
  alpha3: 'ANT',
  numeric3: '530',
};
const NC = {
  countryName: 'New Caledonia',
  postalCodeFormat: 'NC.json',
  alpha2: 'NC',
  alpha3: 'NCL',
  numeric3: '540',
};
const NZ = {
  countryName: 'New Zealand',
  postalCodeFormat: '4Digits.json',
  alpha2: 'NZ',
  alpha3: 'NZL',
  numeric3: '554',
};
const NI = {
  countryName: 'Nicaragua',
  postalCodeFormat: '5Digits.json',
  alpha2: 'NI',
  alpha3: 'NIC',
  numeric3: '558',
};
const NE = {
  countryName: 'Niger',
  postalCodeFormat: '4Digits.json',
  alpha2: 'NE',
  alpha3: 'NER',
  numeric3: '562',
};
const NG = {
  countryName: 'Nigeria',
  postalCodeFormat: '6Digits.json',
  alpha2: 'NG',
  alpha3: 'NGA',
  numeric3: '566',
};
const NU = {
  countryName: 'Niue',
  alpha2: 'NU',
  alpha3: 'NIU',
  numeric3: '570',
};
const NF = {
  countryName: 'Norfolk Island',
  postalCodeFormat: '4Digits.json',
  alpha2: 'NF',
  alpha3: 'NFK',
  numeric3: '574',
};
const MP = {
  countryName: 'Northern Mariana Islands',
  postalCodeFormat: 'US.json',
  alpha2: 'MP',
  alpha3: 'MNP',
  numeric3: '580',
};
const NO = {
  countryName: 'Norway',
  postalCodeFormat: '4Digits.json',
  alpha2: 'NO',
  alpha3: 'NOR',
  numeric3: '578',
};
const OM = {
  countryName: 'Oman',
  postalCodeFormat: '3Digits.json',
  alpha2: 'OM',
  alpha3: 'OMN',
  numeric3: '512',
};
const PK = {
  countryName: 'Pakistan',
  postalCodeFormat: '5Digits.json',
  alpha2: 'PK',
  alpha3: 'PAK',
  numeric3: '586',
};
const PW = {
  countryName: 'Palau',
  postalCodeFormat: 'US.json',
  alpha2: 'PW',
  alpha3: 'PLW',
  numeric3: '585',
};
const PS = {
  countryName: 'Palestinian Territory, Occupied',
  postalCodeFormat: '3Digits.json',
  alpha2: 'PS',
  alpha3: 'PSE',
  numeric3: '275',
};
const PA = {
  countryName: 'Panama',
  postalCodeFormat: '4Digits.json',
  alpha2: 'PA',
  alpha3: 'PAN',
  numeric3: '591',
};
const PG = {
  countryName: 'Papua New Guinea',
  postalCodeFormat: '3Digits.json',
  alpha2: 'PG',
  alpha3: 'PNG',
  numeric3: '598',
};
const PY = {
  countryName: 'Paraguay',
  postalCodeFormat: '4Digits.json',
  alpha2: 'PY',
  alpha3: 'PRY',
  numeric3: '600',
};
const PE = {
  countryName: 'Peru',
  postalCodeFormat: '5Digits.json',
  alpha2: 'PE',
  alpha3: 'PER',
  numeric3: '604',
};
const PH = {
  countryName: 'Philippines',
  postalCodeFormat: '4Digits.json',
  alpha2: 'PH',
  alpha3: 'PHL',
  numeric3: '608',
};
const PN = {
  countryName: 'Pitcairn',
  postalCodeFormat: 'PN.json',
  alpha2: 'PN',
  alpha3: 'PCN',
  numeric3: '612',
};
const PL = {
  countryName: 'Poland',
  postalCodeFormat: 'PL.json',
  alpha2: 'PL',
  alpha3: 'POL',
  numeric3: '616',
};
const PT = {
  countryName: 'Portugal',
  postalCodeFormat: 'PT.json',
  alpha2: 'PT',
  alpha3: 'PRT',
  numeric3: '620',
};
const PR = {
  countryName: 'Puerto Rico',
  postalCodeFormat: 'US.json',
  alpha2: 'PR',
  alpha3: 'PRI',
  numeric3: '630',
};
const QA = {
  countryName: 'Qatar',
  alpha2: 'QA',
  alpha3: 'QAT',
  numeric3: '634',
};
const RE = {
  countryName: 'Réunion',
  postalCodeFormat: 'RE.json',
  alpha2: 'RE',
  alpha3: 'REU',
  numeric3: '638',
};
const RO = {
  countryName: 'Romania',
  postalCodeFormat: '6Digits.json',
  alpha2: 'RO',
  alpha3: 'ROU',
  numeric3: '642',
};
const RU = {
  countryName: 'Russian Federation',
  postalCodeFormat: 'RU.json',
  alpha2: 'RU',
  alpha3: 'RUS',
  numeric3: '643',
};
const RW = {
  countryName: 'Rwanda',
  alpha2: 'RW',
  alpha3: 'RWA',
  numeric3: '646',
};
const BL = {
  countryName: 'Saint-Barthélemy',
  postalCodeFormat: 'BL.json',
  alpha2: 'BL',
  alpha3: 'BLM',
  numeric3: '652',
};
const SH = {
  countryName: 'Saint Helena',
  postalCodeFormat: 'SH.json',
  alpha2: 'SH',
  alpha3: 'SHN',
  numeric3: '654',
};
const KN = {
  countryName: 'Saint Kitts and Nevis',
  alpha2: 'KN',
  alpha3: 'KNA',
  numeric3: '659',
};
const LC = {
  countryName: 'Saint Lucia',
  postalCodeFormat: 'LC.json',
  alpha2: 'LC',
  alpha3: 'LCA',
  numeric3: '662',
};
const MF = {
  countryName: 'Saint-Martin (French part)',
  postalCodeFormat: 'MF.json',
  alpha2: 'MF',
  alpha3: 'MAF',
  numeric3: '663',
};
const PM = {
  countryName: 'Saint Pierre and Miquelon',
  postalCodeFormat: 'PM.json',
  alpha2: 'PM',
  alpha3: 'SPM',
  numeric3: '666',
};
const VC = {
  countryName: 'Saint Vincent and Grenadines',
  postalCodeFormat: 'VC.json',
  alpha2: 'VC',
  alpha3: 'VCT',
  numeric3: '670',
};
const WS = {
  countryName: 'Samoa',
  postalCodeFormat: 'WS.json',
  alpha2: 'WS',
  alpha3: 'WSM',
  numeric3: '882',
};
const SM = {
  countryName: 'San Marino',
  postalCodeFormat: 'SM.json',
  alpha2: 'SM',
  alpha3: 'SMR',
  numeric3: '674',
};
const ST = {
  countryName: 'Sao Tome and Principe',
  alpha2: 'ST',
  alpha3: 'STP',
  numeric3: '678',
};
const SA = {
  countryName: 'Saudi Arabia',
  postalCodeFormat: 'US.json',
  alpha2: 'SA',
  alpha3: 'SAU',
  numeric3: '682',
};
const SN = {
  countryName: 'Senegal',
  postalCodeFormat: '5Digits.json',
  alpha2: 'SN',
  alpha3: 'SEN',
  numeric3: '686',
};
const RS = {
  countryName: 'Serbia',
  postalCodeFormat: '5Digits.json',
  alpha2: 'RS',
  alpha3: 'SRB',
  numeric3: '688',
};
const SC = {
  countryName: 'Seychelles',
  alpha2: 'SC',
  alpha3: 'SYC',
  numeric3: '690',
};
const SL = {
  countryName: 'Sierra Leone',
  alpha2: 'SL',
  alpha3: 'SLE',
  numeric3: '694',
};
const SG = {
  countryName: 'Singapore',
  postalCodeFormat: '6Digits.json',
  alpha2: 'SG',
  alpha3: 'SGP',
  numeric3: '702',
};
const SK = {
  countryName: 'Slovakia',
  postalCodeFormat: '5Digits.json',
  alpha2: 'SK',
  alpha3: 'SVK',
  numeric3: '703',
};
const SI = {
  countryName: 'Slovenia',
  postalCodeFormat: '4Digits.json',
  alpha2: 'SI',
  alpha3: 'SVN',
  numeric3: '705',
};
const SB = {
  countryName: 'Solomon Islands',
  alpha2: 'SB',
  alpha3: 'SLB',
  numeric3: '90',
};
const SO = {
  countryName: 'Somalia',
  postalCodeFormat: 'SO.json',
  alpha2: 'SO',
  alpha3: 'SOM',
  numeric3: '706',
};
const ZA = {
  countryName: 'South Africa',
  postalCodeFormat: '4Digits.json',
  alpha2: 'ZA',
  alpha3: 'ZAF',
  numeric3: '710',
};
const GS = {
  countryName: 'South Georgia and the South Sandwich Islands',
  postalCodeFormat: 'GS.json',
  alpha2: 'GS',
  alpha3: 'SGS',
  numeric3: '239',
};
const SS = {
  countryName: 'South Sudan',
  alpha2: 'SS',
  alpha3: 'SSD',
  numeric3: '728',
};
const ES = {
  countryName: 'Spain',
  postalCodeFormat: '5Digits.json',
  alpha2: 'ES',
  alpha3: 'ESP',
  numeric3: '724',
};
const LK = {
  countryName: 'Sri Lanka',
  postalCodeFormat: '5Digits.json',
  alpha2: 'LK',
  alpha3: 'LKA',
  numeric3: '144',
};
const SD = {
  countryName: 'Sudan',
  postalCodeFormat: '5Digits.json',
  alpha2: 'SD',
  alpha3: 'SDN',
  numeric3: '736',
};
const SR = {
  countryName: 'Suriname *',
  alpha2: 'SR',
  alpha3: 'SUR',
  numeric3: '740',
};
const SJ = {
  countryName: 'Svalbard and Jan Mayen Islands',
  postalCodeFormat: '4Digits.json',
  alpha2: 'SJ',
  alpha3: 'SJM',
  numeric3: '744',
};
const SZ = {
  countryName: 'Swaziland',
  postalCodeFormat: 'SZ.json',
  alpha2: 'SZ',
  alpha3: 'SWZ',
  numeric3: '748',
};
const SE = {
  countryName: 'Sweden',
  postalCodeFormat: '5Digits.json',
  alpha2: 'SE',
  alpha3: 'SWE',
  numeric3: '752',
};
const CH = {
  countryName: 'Switzerland',
  postalCodeFormat: '4Digits.json',
  alpha2: 'CH',
  alpha3: 'CHE',
  numeric3: '756',
};
const SY = {
  countryName: 'Syrian Arab Republic (Syria)',
  alpha2: 'SY',
  alpha3: 'SYR',
  numeric3: '760',
};
const TW = {
  countryName: 'Taiwan, Republic of China',
  postalCodeFormat: 'TW.json',
  alpha2: 'TW',
  alpha3: 'TWN',
  numeric3: '158',
};
const TJ = {
  countryName: 'Tajikistan',
  postalCodeFormat: '6Digits.json',
  alpha2: 'TJ',
  alpha3: 'TJK',
  numeric3: '762',
};
const TZ = {
  countryName: 'Tanzania *, United Republic of',
  postalCodeFormat: '5Digits.json',
  alpha2: 'TZ',
  alpha3: 'TZA',
  numeric3: '834',
};
const TH = {
  countryName: 'Thailand',
  postalCodeFormat: '5Digits.json',
  alpha2: 'TH',
  alpha3: 'THA',
  numeric3: '764',
};
const TL = {
  countryName: 'Timor-Leste',
  alpha2: 'TL',
  alpha3: 'TLS',
  numeric3: '626',
};
const TG = {
  countryName: 'Togo',
  alpha2: 'TG',
  alpha3: 'TGO',
  numeric3: '768',
};
const TK = {
  countryName: 'Tokelau',
  alpha2: 'TK',
  alpha3: 'TKL',
  numeric3: '772',
};
const TO = {
  countryName: 'Tonga',
  alpha2: 'TO',
  alpha3: 'TON',
  numeric3: '776',
};
const TT = {
  countryName: 'Trinidad and Tobago',
  postalCodeFormat: '6Digits.json',
  alpha2: 'TT',
  alpha3: 'TTO',
  numeric3: '780',
};
const TN = {
  countryName: 'Tunisia',
  postalCodeFormat: '4Digits.json',
  alpha2: 'TN',
  alpha3: 'TUN',
  numeric3: '788',
};
const TR = {
  countryName: 'Turkey',
  postalCodeFormat: '5Digits.json',
  alpha2: 'TR',
  alpha3: 'TUR',
  numeric3: '792',
};
const TM = {
  countryName: 'Turkmenistan',
  postalCodeFormat: '6Digits.json',
  alpha2: 'TM',
  alpha3: 'TKM',
  numeric3: '795',
};
const TC = {
  countryName: 'Turks and Caicos Islands',
  postalCodeFormat: 'TC.json',
  alpha2: 'TC',
  alpha3: 'TCA',
  numeric3: '796',
};
const TV = {
  countryName: 'Tuvalu',
  alpha2: 'TV',
  alpha3: 'TUV',
  numeric3: '798',
};
const UG = {
  countryName: 'Uganda',
  alpha2: 'UG',
  alpha3: 'UGA',
  numeric3: '800',
};
const UA = {
  countryName: 'Ukraine',
  postalCodeFormat: '5Digits.json',
  alpha2: 'UA',
  alpha3: 'UKR',
  numeric3: '804',
};
const AE = {
  countryName: 'United Arab Emirates',
  alpha2: 'AE',
  alpha3: 'ARE',
  numeric3: '784',
};
const GB = {
  countryName: 'United Kingdom',
  postalCodeFormat: 'GB.json',
  alpha2: 'GB',
  alpha3: 'GBR',
  numeric3: '826',
};
const US = {
  countryName: 'United States of America',
  postalCodeFormat: 'US.json',
  alpha2: 'US',
  alpha3: 'USA',
  numeric3: '840',
};
const UM = {
  countryName: 'United States Minor Outlying Islands',
  alpha2: 'UM',
  alpha3: 'UMI',
  numeric3: '581',
};
const UY = {
  countryName: 'Uruguay',
  postalCodeFormat: '5Digits.json',
  alpha2: 'UY',
  alpha3: 'URY',
  numeric3: '858',
};
const UZ = {
  countryName: 'Uzbekistan',
  postalCodeFormat: '6Digits.json',
  alpha2: 'UZ',
  alpha3: 'UZB',
  numeric3: '860',
};
const VU = {
  countryName: 'Vanuatu',
  alpha2: 'VU',
  alpha3: 'VUT',
  numeric3: '548',
};
const VE = {
  countryName: 'Venezuela (Bolivarian Republic of)',
  postalCodeFormat: 'VE.json',
  alpha2: 'VE',
  alpha3: 'VEN',
  numeric3: '862',
};
const VN = {
  countryName: 'Viet Nam',
  postalCodeFormat: '6Digits.json',
  alpha2: 'VN',
  alpha3: 'VNM',
  numeric3: '704',
};
const VI = {
  countryName: 'Virgin Islands, US',
  postalCodeFormat: 'US.json',
  alpha2: 'VI',
  alpha3: 'VIR',
  numeric3: '850',
};
const WF = {
  countryName: 'Wallis and Futuna Islands',
  postalCodeFormat: 'WF.json',
  alpha2: 'WF',
  alpha3: 'WLF',
  numeric3: '876',
};
const EH = {
  countryName: 'Western Sahara',
  alpha2: 'EH',
  alpha3: 'ESH',
  numeric3: '732',
};
const YE = {
  countryName: 'Yemen',
  alpha2: 'YE',
  alpha3: 'YEM',
  numeric3: '887',
};
const ZM = {
  countryName: 'Zambia',
  postalCodeFormat: '5Digits.json',
  alpha2: 'ZM',
  alpha3: 'ZMB',
  numeric3: '894',
};
const ZW = {
  countryName: 'Zimbabwe',
  alpha2: 'ZW',
  alpha3: 'ZWE',
  numeric3: '716',
};
const require$$0$1 = {
  AF,
  AX,
  AL,
  DZ,
  AS,
  AD,
  AO,
  AI,
  AQ,
  AG,
  AR,
  AM,
  AW,
  AU,
  AT,
  AZ,
  BS,
  BH,
  BD,
  BB,
  BY,
  BE,
  BZ,
  BJ,
  BM,
  BT,
  BO,
  BA,
  BW,
  BV,
  BR,
  VG,
  IO,
  BN,
  BG,
  BF,
  BI,
  KH,
  CM,
  CA,
  CV,
  KY,
  CF,
  TD,
  CL,
  CN,
  HK,
  MO,
  CX,
  CC,
  CO,
  KM,
  CG,
  CD,
  CK,
  CR,
  CI,
  HR,
  CU,
  CY,
  CZ,
  DK,
  DJ,
  DM,
  DO,
  EC,
  EG,
  SV,
  GQ,
  ER,
  EE,
  ET,
  FK,
  FO,
  FJ,
  FI,
  FR,
  GF,
  PF,
  TF,
  GA,
  GM,
  GE,
  DE,
  GH,
  GI,
  GR,
  GL,
  GD,
  GP,
  GU,
  GT,
  GG,
  GN,
  GW,
  GY,
  HT,
  HM,
  VA,
  HN,
  HU,
  IS,
  IN,
  IC,
  ID,
  IR,
  IQ,
  IE,
  IM,
  IL,
  IT,
  JM,
  JP,
  JE,
  JO,
  KZ,
  KE,
  KI,
  KP,
  KR,
  KW,
  KG,
  LA,
  LV,
  LB,
  LS,
  LR,
  LY,
  LI,
  LT,
  LU,
  MK,
  MG,
  MW,
  MY,
  MV,
  ML,
  MT,
  MH,
  MQ,
  MR,
  MU,
  YT,
  MX,
  FM,
  MD,
  MC,
  MN,
  ME,
  MS,
  MA,
  MZ,
  MM,
  NA,
  NR,
  NP,
  NL,
  AN,
  NC,
  NZ,
  NI,
  NE,
  NG,
  NU,
  NF,
  MP,
  NO,
  OM,
  PK,
  PW,
  PS,
  PA,
  PG,
  PY,
  PE,
  PH,
  PN,
  PL,
  PT,
  PR,
  QA,
  RE,
  RO,
  RU,
  RW,
  BL,
  SH,
  KN,
  LC,
  MF,
  PM,
  VC,
  WS,
  SM,
  ST,
  SA,
  SN,
  RS,
  SC,
  SL,
  SG,
  SK,
  SI,
  SB,
  SO,
  ZA,
  GS,
  SS,
  ES,
  LK,
  SD,
  SR,
  SJ,
  SZ,
  SE,
  CH,
  SY,
  TW,
  TJ,
  TZ,
  TH,
  TL,
  TG,
  TK,
  TO,
  TT,
  TN,
  TR,
  TM,
  TC,
  TV,
  UG,
  UA,
  AE,
  GB,
  US,
  UM,
  UY,
  UZ,
  VU,
  VE,
  VN,
  VI,
  WF,
  EH,
  YE,
  ZM,
  ZW,
};
const AFG = {
  countryName: 'Afghanistan',
  postalCodeFormat: '4Digits.json',
  alpha2: 'AF',
  alpha3: 'AFG',
  numeric3: '4',
};
const ALA = {
  countryName: 'Aland Islands',
  postalCodeFormat: 'AX.json',
  alpha2: 'AX',
  alpha3: 'ALA',
  numeric3: '248',
};
const ALB = {
  countryName: 'Albania',
  postalCodeFormat: '4Digits.json',
  alpha2: 'AL',
  alpha3: 'ALB',
  numeric3: '8',
};
const DZA = {
  countryName: 'Algeria',
  postalCodeFormat: '5Digits.json',
  alpha2: 'DZ',
  alpha3: 'DZA',
  numeric3: '12',
};
const ASM = {
  countryName: 'American Samoa',
  postalCodeFormat: '5Digits.json',
  alpha2: 'AS',
  alpha3: 'ASM',
  numeric3: '16',
};
const AND = {
  countryName: 'Andorra',
  postalCodeFormat: 'AD.json',
  alpha2: 'AD',
  alpha3: 'AND',
  numeric3: '20',
};
const AGO = {
  countryName: 'Angola',
  alpha2: 'AO',
  alpha3: 'AGO',
  numeric3: '24',
};
const AIA = {
  countryName: 'Anguilla',
  postalCodeFormat: 'AI.json',
  alpha2: 'AI',
  alpha3: 'AIA',
  numeric3: '660',
};
const ATA = {
  countryName: 'Antarctica',
  postalCodeFormat: 'AQ.json',
  alpha2: 'AQ',
  alpha3: 'ATA',
  numeric3: '10',
};
const ATG = {
  countryName: 'Antigua and Barbuda',
  alpha2: 'AG',
  alpha3: 'ATG',
  numeric3: '28',
};
const ARG = {
  countryName: 'Argentina',
  postalCodeFormat: '4Digits.json',
  alpha2: 'AR',
  alpha3: 'ARG',
  numeric3: '32',
};
const ARM = {
  countryName: 'Armenia',
  postalCodeFormat: '4Digits.json',
  alpha2: 'AM',
  alpha3: 'ARM',
  numeric3: '51',
};
const ABW = {
  countryName: 'Aruba',
  alpha2: 'AW',
  alpha3: 'ABW',
  numeric3: '533',
};
const AUS = {
  countryName: 'Australia',
  postalCodeFormat: '4Digits.json',
  alpha2: 'AU',
  alpha3: 'AUS',
  numeric3: '36',
};
const AUT = {
  countryName: 'Austria',
  postalCodeFormat: '4Digits.json',
  alpha2: 'AT',
  alpha3: 'AUT',
  numeric3: '40',
};
const AZE = {
  countryName: 'Azerbaijan',
  postalCodeFormat: 'AZ.json',
  alpha2: 'AZ',
  alpha3: 'AZE',
  numeric3: '31',
};
const BHS = {
  countryName: 'Bahamas',
  alpha2: 'BS',
  alpha3: 'BHS',
  numeric3: '44',
};
const BHR = {
  countryName: 'Bahrain',
  postalCodeFormat: 'BH.json',
  alpha2: 'BH',
  alpha3: 'BHR',
  numeric3: '48',
};
const BGD = {
  countryName: 'Bangladesh',
  postalCodeFormat: '4Digits.json',
  alpha2: 'BD',
  alpha3: 'BGD',
  numeric3: '50',
};
const BRB = {
  countryName: 'Barbados',
  postalCodeFormat: 'BB.json',
  alpha2: 'BB',
  alpha3: 'BRB',
  numeric3: '52',
};
const BLR = {
  countryName: 'Belarus',
  postalCodeFormat: '6Digits.json',
  alpha2: 'BY',
  alpha3: 'BLR',
  numeric3: '112',
};
const BEL = {
  countryName: 'Belgium',
  postalCodeFormat: '4Digits.json',
  alpha2: 'BE',
  alpha3: 'BEL',
  numeric3: '56',
};
const BLZ = {
  countryName: 'Belize',
  alpha2: 'BZ',
  alpha3: 'BLZ',
  numeric3: '84',
};
const BEN = {
  countryName: 'Benin',
  alpha2: 'BJ',
  alpha3: 'BEN',
  numeric3: '204',
};
const BMU = {
  countryName: 'Bermuda',
  alpha2: 'BM',
  alpha3: 'BMU',
  numeric3: '60',
};
const BTN = {
  countryName: 'Bhutan',
  postalCodeFormat: '5Digits.json',
  alpha2: 'BT',
  alpha3: 'BTN',
  numeric3: '64',
};
const BOL = {
  countryName: 'Bolivia',
  postalCodeFormat: '4Digits.json',
  alpha2: 'BO',
  alpha3: 'BOL',
  numeric3: '68',
};
const BIH = {
  countryName: 'Bosnia and Herzegovina',
  postalCodeFormat: '5Digits.json',
  alpha2: 'BA',
  alpha3: 'BIH',
  numeric3: '70',
};
const BWA = {
  countryName: 'Botswana',
  alpha2: 'BW',
  alpha3: 'BWA',
  numeric3: '72',
};
const BVT = {
  countryName: 'Bouvet Island',
  alpha2: 'BV',
  alpha3: 'BVT',
  numeric3: '74',
};
const BRA = {
  countryName: 'Brazil',
  postalCodeFormat: '8Digits.json',
  alpha2: 'BR',
  alpha3: 'BRA',
  numeric3: '76',
};
const VGB = {
  countryName: 'British Virgin Islands',
  postalCodeFormat: 'VG.json',
  alpha2: 'VG',
  alpha3: 'VGB',
  numeric3: '92',
};
const IOT = {
  countryName: 'British Indian Ocean Territory',
  postalCodeFormat: 'IO.json',
  alpha2: 'IO',
  alpha3: 'IOT',
  numeric3: '86',
};
const BRN = {
  countryName: 'Brunei Darussalam',
  postalCodeFormat: 'BN.json',
  alpha2: 'BN',
  alpha3: 'BRN',
  numeric3: '96',
};
const BGR = {
  countryName: 'Bulgaria',
  postalCodeFormat: '4Digits.json',
  alpha2: 'BG',
  alpha3: 'BGR',
  numeric3: '100',
};
const BFA = {
  countryName: 'Burkina Faso',
  alpha2: 'BF',
  alpha3: 'BFA',
  numeric3: '854',
};
const BDI = {
  countryName: 'Burundi',
  alpha2: 'BI',
  alpha3: 'BDI',
  numeric3: '108',
};
const KHM = {
  countryName: 'Cambodia',
  postalCodeFormat: '5Digits.json',
  alpha2: 'KH',
  alpha3: 'KHM',
  numeric3: '116',
};
const CMR = {
  countryName: 'Cameroon',
  alpha2: 'CM',
  alpha3: 'CMR',
  numeric3: '120',
};
const CAN = {
  countryName: 'Canada',
  postalCodeFormat: 'CA.json',
  alpha2: 'CA',
  alpha3: 'CAN',
  numeric3: '124',
};
const CPV = {
  countryName: 'Cape Verde',
  postalCodeFormat: '4Digits.json',
  alpha2: 'CV',
  alpha3: 'CPV',
  numeric3: '132',
};
const CYM = {
  countryName: 'Cayman Islands',
  postalCodeFormat: 'KY.json',
  alpha2: 'KY',
  alpha3: 'CYM',
  numeric3: '136',
};
const CAF = {
  countryName: 'Central African Republic',
  alpha2: 'CF',
  alpha3: 'CAF',
  numeric3: '140',
};
const TCD = {
  countryName: 'Chad',
  postalCodeFormat: '5Digits.json',
  alpha2: 'TD',
  alpha3: 'TCD',
  numeric3: '148',
};
const CHL = {
  countryName: 'Chile',
  postalCodeFormat: '7Digits.json',
  alpha2: 'CL',
  alpha3: 'CHL',
  numeric3: '152',
};
const CHN = {
  countryName: 'China',
  postalCodeFormat: '6Digits.json',
  alpha2: 'CN',
  alpha3: 'CHN',
  numeric3: '156',
};
const HKG = {
  countryName: 'Hong Kong, Special Administrative Region of China',
  alpha2: 'HK',
  alpha3: 'HKG',
  numeric3: '344',
};
const MAC = {
  countryName: 'Macao, Special Administrative Region of China',
  alpha2: 'MO',
  alpha3: 'MAC',
  numeric3: '446',
};
const CXR = {
  countryName: 'Christmas Island',
  postalCodeFormat: '4Digits.json',
  alpha2: 'CX',
  alpha3: 'CXR',
  numeric3: '162',
};
const CCK = {
  countryName: 'Cocos (Keeling) Islands',
  postalCodeFormat: '4Digits.json',
  alpha2: 'CC',
  alpha3: 'CCK',
  numeric3: '166',
};
const COL = {
  countryName: 'Colombia',
  postalCodeFormat: '6Digits.json',
  alpha2: 'CO',
  alpha3: 'COL',
  numeric3: '170',
};
const COM = {
  countryName: 'Comoros',
  alpha2: 'KM',
  alpha3: 'COM',
  numeric3: '174',
};
const COG = {
  countryName: 'Congo (Brazzaville)',
  alpha2: 'CG',
  alpha3: 'COG',
  numeric3: '178',
};
const COD = {
  countryName: 'Congo, Democratic Republic of the',
  alpha2: 'CD',
  alpha3: 'COD',
  numeric3: '180',
};
const COK = {
  countryName: 'Cook Islands',
  alpha2: 'CK',
  alpha3: 'COK',
  numeric3: '184',
};
const CRI = {
  countryName: 'Costa Rica',
  postalCodeFormat: '5Digits.json',
  alpha2: 'CR',
  alpha3: 'CRI',
  numeric3: '188',
};
const CIV = {
  countryName: "Côte d'Ivoire",
  alpha2: 'CI',
  alpha3: 'CIV',
  numeric3: '384',
};
const HRV = {
  countryName: 'Croatia',
  postalCodeFormat: '5Digits.json',
  alpha2: 'HR',
  alpha3: 'HRV',
  numeric3: '191',
};
const CUB = {
  countryName: 'Cuba',
  postalCodeFormat: '5Digits.json',
  alpha2: 'CU',
  alpha3: 'CUB',
  numeric3: '192',
};
const CYP = {
  countryName: 'Cyprus',
  postalCodeFormat: '4Digits.json',
  alpha2: 'CY',
  alpha3: 'CYP',
  numeric3: '196',
};
const CZE = {
  countryName: 'Czech Republic',
  postalCodeFormat: '5Digits.json',
  alpha2: 'CZ',
  alpha3: 'CZE',
  numeric3: '203',
};
const DNK = {
  countryName: 'Denmark',
  postalCodeFormat: 'DK.json',
  alpha2: 'DK',
  alpha3: 'DNK',
  numeric3: '208',
};
const DJI = {
  countryName: 'Djibouti',
  alpha2: 'DJ',
  alpha3: 'DJI',
  numeric3: '262',
};
const DMA = {
  countryName: 'Dominica',
  alpha2: 'DM',
  alpha3: 'DMA',
  numeric3: '212',
};
const DOM = {
  countryName: 'Dominican Republic',
  postalCodeFormat: '5Digits.json',
  alpha2: 'DO',
  alpha3: 'DOM',
  numeric3: '214',
};
const ECU = {
  countryName: 'Ecuador',
  postalCodeFormat: '6Digits.json',
  alpha2: 'EC',
  alpha3: 'ECU',
  numeric3: '218',
};
const EGY = {
  countryName: 'Egypt',
  postalCodeFormat: '5Digits.json',
  alpha2: 'EG',
  alpha3: 'EGY',
  numeric3: '818',
};
const SLV = {
  countryName: 'El Salvador',
  postalCodeFormat: '4Digits.json',
  alpha2: 'SV',
  alpha3: 'SLV',
  numeric3: '222',
};
const GNQ = {
  countryName: 'Equatorial Guinea',
  alpha2: 'GQ',
  alpha3: 'GNQ',
  numeric3: '226',
};
const ERI = {
  countryName: 'Eritrea',
  alpha2: 'ER',
  alpha3: 'ERI',
  numeric3: '232',
};
const EST = {
  countryName: 'Estonia',
  postalCodeFormat: '5Digits.json',
  alpha2: 'EE',
  alpha3: 'EST',
  numeric3: '233',
};
const ETH = {
  countryName: 'Ethiopia',
  postalCodeFormat: '4Digits.json',
  alpha2: 'ET',
  alpha3: 'ETH',
  numeric3: '231',
};
const FLK = {
  countryName: 'Falkland Islands (Malvinas)',
  postalCodeFormat: 'FK.json',
  alpha2: 'FK',
  alpha3: 'FLK',
  numeric3: '238',
};
const FRO = {
  countryName: 'Faroe Islands',
  postalCodeFormat: '3Digits.json',
  alpha2: 'FO',
  alpha3: 'FRO',
  numeric3: '234',
};
const FJI = {
  countryName: 'Fiji',
  alpha2: 'FJ',
  alpha3: 'FJI',
  numeric3: '242',
};
const FIN = {
  countryName: 'Finland',
  postalCodeFormat: '5Digits.json',
  alpha2: 'FI',
  alpha3: 'FIN',
  numeric3: '246',
};
const FRA = {
  countryName: 'France',
  postalCodeFormat: '5Digits.json',
  alpha2: 'FR',
  alpha3: 'FRA',
  numeric3: '250',
};
const GUF = {
  countryName: 'French Guiana',
  postalCodeFormat: 'GF.json',
  alpha2: 'GF',
  alpha3: 'GUF',
  numeric3: '254',
};
const PYF = {
  countryName: 'French Polynesia',
  postalCodeFormat: 'PF.json',
  alpha2: 'PF',
  alpha3: 'PYF',
  numeric3: '258',
};
const ATF = {
  countryName: 'French Southern Territories',
  alpha2: 'TF',
  alpha3: 'ATF',
  numeric3: '260',
};
const GAB = {
  countryName: 'Gabon',
  alpha2: 'GA',
  alpha3: 'GAB',
  numeric3: '266',
};
const GMB = {
  countryName: 'Gambia',
  alpha2: 'GM',
  alpha3: 'GMB',
  numeric3: '270',
};
const GEO = {
  countryName: 'Georgia',
  postalCodeFormat: '4Digits.json',
  alpha2: 'GE',
  alpha3: 'GEO',
  numeric3: '268',
};
const DEU = {
  countryName: 'Germany',
  postalCodeFormat: '5Digits.json',
  alpha2: 'DE',
  alpha3: 'DEU',
  numeric3: '276',
};
const GHA = {
  countryName: 'Ghana',
  alpha2: 'GH',
  alpha3: 'GHA',
  numeric3: '288',
};
const GIB = {
  countryName: 'Gibraltar',
  postalCodeFormat: 'GI.json',
  alpha2: 'GI',
  alpha3: 'GIB',
  numeric3: '292',
};
const GRC = {
  countryName: 'Greece',
  postalCodeFormat: '5Digits.json',
  alpha2: 'GR',
  alpha3: 'GRC',
  numeric3: '300',
};
const GRL = {
  countryName: 'Greenland',
  postalCodeFormat: '4Digits.json',
  alpha2: 'GL',
  alpha3: 'GRL',
  numeric3: '304',
};
const GRD = {
  countryName: 'Grenada',
  alpha2: 'GD',
  alpha3: 'GRD',
  numeric3: '308',
};
const GLP = {
  countryName: 'Guadeloupe',
  postalCodeFormat: 'GP.json',
  alpha2: 'GP',
  alpha3: 'GLP',
  numeric3: '312',
};
const GUM = {
  countryName: 'Guam',
  postalCodeFormat: 'US.json',
  alpha2: 'GU',
  alpha3: 'GUM',
  numeric3: '316',
};
const GTM = {
  countryName: 'Guatemala',
  postalCodeFormat: '5Digits.json',
  alpha2: 'GT',
  alpha3: 'GTM',
  numeric3: '320',
};
const GGY = {
  countryName: 'Guernsey',
  postalCodeFormat: 'GG.json',
  alpha2: 'GG',
  alpha3: 'GGY',
  numeric3: '831',
};
const GIN = {
  countryName: 'Guinea',
  postalCodeFormat: '3Digits.json',
  alpha2: 'GN',
  alpha3: 'GIN',
  numeric3: '324',
};
const GNB = {
  countryName: 'Guinea-Bissau',
  postalCodeFormat: '4Digits.json',
  alpha2: 'GW',
  alpha3: 'GNB',
  numeric3: '624',
};
const GUY = {
  countryName: 'Guyana',
  alpha2: 'GY',
  alpha3: 'GUY',
  numeric3: '328',
};
const HTI = {
  countryName: 'Haiti',
  postalCodeFormat: '4Digits.json',
  alpha2: 'HT',
  alpha3: 'HTI',
  numeric3: '332',
};
const HMD = {
  countryName: 'Heard Island and Mcdonald Islands',
  postalCodeFormat: '4Digits.json',
  alpha2: 'HM',
  alpha3: 'HMD',
  numeric3: '334',
};
const VAT = {
  countryName: 'Holy See (Vatican City State)',
  postalCodeFormat: 'VA.json',
  alpha2: 'VA',
  alpha3: 'VAT',
  numeric3: '336',
};
const HND = {
  countryName: 'Honduras',
  postalCodeFormat: 'HN.json',
  alpha2: 'HN',
  alpha3: 'HND',
  numeric3: '340',
};
const HUN = {
  countryName: 'Hungary',
  postalCodeFormat: '4Digits.json',
  alpha2: 'HU',
  alpha3: 'HUN',
  numeric3: '348',
};
const ISL = {
  countryName: 'Iceland',
  postalCodeFormat: '3Digits.json',
  alpha2: 'IS',
  alpha3: 'ISL',
  numeric3: '352',
};
const IND = {
  countryName: 'India',
  postalCodeFormat: '6Digits.json',
  alpha2: 'IN',
  alpha3: 'IND',
  numeric3: '356',
};
const IDN = {
  countryName: 'Indonesia',
  postalCodeFormat: '5Digits.json',
  alpha2: 'ID',
  alpha3: 'IDN',
  numeric3: '360',
};
const IRN = {
  countryName: 'Iran, Islamic Republic of',
  postalCodeFormat: '10Digits.json',
  alpha2: 'IR',
  alpha3: 'IRN',
  numeric3: '364',
};
const IRQ = {
  countryName: 'Iraq',
  postalCodeFormat: '5Digits.json',
  alpha2: 'IQ',
  alpha3: 'IRQ',
  numeric3: '368',
};
const IRL = {
  countryName: 'Ireland',
  postalCodeFormat: 'IE.json',
  alpha2: 'IE',
  alpha3: 'IRL',
  numeric3: '372',
};
const IMN = {
  countryName: 'Isle of Man',
  postalCodeFormat: 'IM.json',
  alpha2: 'IM',
  alpha3: 'IMN',
  numeric3: '833',
};
const ISR = {
  countryName: 'Israel',
  postalCodeFormat: '7Digits.json',
  alpha2: 'IL',
  alpha3: 'ISR',
  numeric3: '376',
};
const ITA = {
  countryName: 'Italy',
  postalCodeFormat: '5Digits.json',
  alpha2: 'IT',
  alpha3: 'ITA',
  numeric3: '380',
};
const JAM = {
  countryName: 'Jamaica',
  postalCodeFormat: '2Digits.json',
  alpha2: 'JM',
  alpha3: 'JAM',
  numeric3: '388',
};
const JPN = {
  countryName: 'Japan',
  postalCodeFormat: '7Digits.json',
  alpha2: 'JP',
  alpha3: 'JPN',
  numeric3: '392',
};
const JEY = {
  countryName: 'Jersey',
  postalCodeFormat: 'JE.json',
  alpha2: 'JE',
  alpha3: 'JEY',
  numeric3: '832',
};
const JOR = {
  countryName: 'Jordan',
  postalCodeFormat: '5Digits.json',
  alpha2: 'JO',
  alpha3: 'JOR',
  numeric3: '400',
};
const KAZ = {
  countryName: 'Kazakhstan',
  postalCodeFormat: '6Digits.json',
  alpha2: 'KZ',
  alpha3: 'KAZ',
  numeric3: '398',
};
const KEN = {
  countryName: 'Kenya',
  postalCodeFormat: '5Digits.json',
  alpha2: 'KE',
  alpha3: 'KEN',
  numeric3: '404',
};
const KIR = {
  countryName: 'Kiribati',
  alpha2: 'KI',
  alpha3: 'KIR',
  numeric3: '296',
};
const PRK = {
  countryName: "Korea, Democratic People's Republic of",
  alpha2: 'KP',
  alpha3: 'PRK',
  numeric3: '408',
};
const KOR = {
  countryName: 'Korea, Republic of',
  postalCodeFormat: '5Digits.json',
  alpha2: 'KR',
  alpha3: 'KOR',
  numeric3: '410',
};
const KWT = {
  countryName: 'Kuwait',
  postalCodeFormat: '5Digits.json',
  alpha2: 'KW',
  alpha3: 'KWT',
  numeric3: '414',
};
const KGZ = {
  countryName: 'Kyrgyzstan',
  postalCodeFormat: '6Digits.json',
  alpha2: 'KG',
  alpha3: 'KGZ',
  numeric3: '417',
};
const LAO = {
  countryName: 'Lao PDR',
  postalCodeFormat: '5Digits.json',
  alpha2: 'LA',
  alpha3: 'LAO',
  numeric3: '418',
};
const LVA = {
  countryName: 'Latvia',
  postalCodeFormat: 'LV.json',
  alpha2: 'LV',
  alpha3: 'LVA',
  numeric3: '428',
};
const LBN = {
  countryName: 'Lebanon',
  postalCodeFormat: 'LB.json',
  alpha2: 'LB',
  alpha3: 'LBN',
  numeric3: '422',
};
const LSO = {
  countryName: 'Lesotho',
  postalCodeFormat: '3Digits.json',
  alpha2: 'LS',
  alpha3: 'LSO',
  numeric3: '426',
};
const LBR = {
  countryName: 'Liberia',
  postalCodeFormat: '4Digits.json',
  alpha2: 'LR',
  alpha3: 'LBR',
  numeric3: '430',
};
const LBY = {
  countryName: 'Libya',
  postalCodeFormat: '5Digits.json',
  alpha2: 'LY',
  alpha3: 'LBY',
  numeric3: '434',
};
const LIE = {
  countryName: 'Liechtenstein',
  postalCodeFormat: '4Digits.json',
  alpha2: 'LI',
  alpha3: 'LIE',
  numeric3: '438',
};
const LTU = {
  countryName: 'Lithuania',
  postalCodeFormat: 'LT.json',
  alpha2: 'LT',
  alpha3: 'LTU',
  numeric3: '440',
};
const LUX = {
  countryName: 'Luxembourg',
  postalCodeFormat: 'LU.json',
  alpha2: 'LU',
  alpha3: 'LUX',
  numeric3: '442',
};
const MKD = {
  countryName: 'Macedonia, Republic of',
  postalCodeFormat: '4Digits.json',
  alpha2: 'MK',
  alpha3: 'MKD',
  numeric3: '807',
};
const MDG = {
  countryName: 'Madagascar',
  postalCodeFormat: '3Digits.json',
  alpha2: 'MG',
  alpha3: 'MDG',
  numeric3: '450',
};
const MWI = {
  countryName: 'Malawi',
  alpha2: 'MW',
  alpha3: 'MWI',
  numeric3: '454',
};
const MYS = {
  countryName: 'Malaysia',
  postalCodeFormat: '5Digits.json',
  alpha2: 'MY',
  alpha3: 'MYS',
  numeric3: '458',
};
const MDV = {
  countryName: 'Maldives',
  postalCodeFormat: '5Digits.json',
  alpha2: 'MV',
  alpha3: 'MDV',
  numeric3: '462',
};
const MLI = {
  countryName: 'Mali',
  alpha2: 'ML',
  alpha3: 'MLI',
  numeric3: '466',
};
const MLT = {
  countryName: 'Malta',
  postalCodeFormat: 'MT.json',
  alpha2: 'MT',
  alpha3: 'MLT',
  numeric3: '470',
};
const MHL = {
  countryName: 'Marshall Islands',
  postalCodeFormat: 'US.json',
  alpha2: 'MH',
  alpha3: 'MHL',
  numeric3: '584',
};
const MTQ = {
  countryName: 'Martinique',
  postalCodeFormat: '5Digits.json',
  alpha2: 'MQ',
  alpha3: 'MTQ',
  numeric3: '474',
};
const MRT = {
  countryName: 'Mauritania',
  alpha2: 'MR',
  alpha3: 'MRT',
  numeric3: '478',
};
const MUS = {
  countryName: 'Mauritius',
  postalCodeFormat: '5Digits.json',
  alpha2: 'MU',
  alpha3: 'MUS',
  numeric3: '480',
};
const MYT = {
  countryName: 'Mayotte',
  postalCodeFormat: '5Digits.json',
  alpha2: 'YT',
  alpha3: 'MYT',
  numeric3: '175',
};
const MEX = {
  countryName: 'Mexico',
  postalCodeFormat: '5Digits.json',
  alpha2: 'MX',
  alpha3: 'MEX',
  numeric3: '484',
};
const FSM = {
  countryName: 'Micronesia, Federated States of',
  postalCodeFormat: 'US.json',
  alpha2: 'FM',
  alpha3: 'FSM',
  numeric3: '583',
};
const MDA = {
  countryName: 'Moldova',
  postalCodeFormat: 'MD.json',
  alpha2: 'MD',
  alpha3: 'MDA',
  numeric3: '498',
};
const MCO = {
  countryName: 'Monaco',
  postalCodeFormat: 'MC.json',
  alpha2: 'MC',
  alpha3: 'MCO',
  numeric3: '492',
};
const MNG = {
  countryName: 'Mongolia',
  postalCodeFormat: '5Digits.json',
  alpha2: 'MN',
  alpha3: 'MNG',
  numeric3: '496',
};
const MNE = {
  countryName: 'Montenegro',
  postalCodeFormat: '5Digits.json',
  alpha2: 'ME',
  alpha3: 'MNE',
  numeric3: '499',
};
const MSR = {
  countryName: 'Montserrat',
  postalCodeFormat: 'MS.json',
  alpha2: 'MS',
  alpha3: 'MSR',
  numeric3: '500',
};
const MAR = {
  countryName: 'Morocco',
  postalCodeFormat: '5Digits.json',
  alpha2: 'MA',
  alpha3: 'MAR',
  numeric3: '504',
};
const MOZ = {
  countryName: 'Mozambique',
  postalCodeFormat: '4Digits.json',
  alpha2: 'MZ',
  alpha3: 'MOZ',
  numeric3: '508',
};
const MMR = {
  countryName: 'Myanmar',
  postalCodeFormat: '5Digits.json',
  alpha2: 'MM',
  alpha3: 'MMR',
  numeric3: '104',
};
const NAM = {
  countryName: 'Namibia',
  postalCodeFormat: '5Digits.json',
  alpha2: 'NA',
  alpha3: 'NAM',
  numeric3: '516',
};
const NRU = {
  countryName: 'Nauru',
  alpha2: 'NR',
  alpha3: 'NRU',
  numeric3: '520',
};
const NPL = {
  countryName: 'Nepal',
  postalCodeFormat: '5Digits.json',
  alpha2: 'NP',
  alpha3: 'NPL',
  numeric3: '524',
};
const NLD = {
  countryName: 'Netherlands',
  postalCodeFormat: 'NL.json',
  alpha2: 'NL',
  alpha3: 'NLD',
  numeric3: '528',
};
const ANT = {
  countryName: 'Netherlands Antilles',
  alpha2: 'AN',
  alpha3: 'ANT',
  numeric3: '530',
};
const NCL = {
  countryName: 'New Caledonia',
  postalCodeFormat: 'NC.json',
  alpha2: 'NC',
  alpha3: 'NCL',
  numeric3: '540',
};
const NZL = {
  countryName: 'New Zealand',
  postalCodeFormat: '4Digits.json',
  alpha2: 'NZ',
  alpha3: 'NZL',
  numeric3: '554',
};
const NIC = {
  countryName: 'Nicaragua',
  postalCodeFormat: '5Digits.json',
  alpha2: 'NI',
  alpha3: 'NIC',
  numeric3: '558',
};
const NER = {
  countryName: 'Niger',
  postalCodeFormat: '4Digits.json',
  alpha2: 'NE',
  alpha3: 'NER',
  numeric3: '562',
};
const NGA = {
  countryName: 'Nigeria',
  postalCodeFormat: '6Digits.json',
  alpha2: 'NG',
  alpha3: 'NGA',
  numeric3: '566',
};
const NIU = {
  countryName: 'Niue',
  alpha2: 'NU',
  alpha3: 'NIU',
  numeric3: '570',
};
const NFK = {
  countryName: 'Norfolk Island',
  postalCodeFormat: '4Digits.json',
  alpha2: 'NF',
  alpha3: 'NFK',
  numeric3: '574',
};
const MNP = {
  countryName: 'Northern Mariana Islands',
  postalCodeFormat: 'US.json',
  alpha2: 'MP',
  alpha3: 'MNP',
  numeric3: '580',
};
const NOR = {
  countryName: 'Norway',
  postalCodeFormat: '4Digits.json',
  alpha2: 'NO',
  alpha3: 'NOR',
  numeric3: '578',
};
const OMN = {
  countryName: 'Oman',
  postalCodeFormat: '3Digits.json',
  alpha2: 'OM',
  alpha3: 'OMN',
  numeric3: '512',
};
const PAK = {
  countryName: 'Pakistan',
  postalCodeFormat: '5Digits.json',
  alpha2: 'PK',
  alpha3: 'PAK',
  numeric3: '586',
};
const PLW = {
  countryName: 'Palau',
  postalCodeFormat: 'US.json',
  alpha2: 'PW',
  alpha3: 'PLW',
  numeric3: '585',
};
const PSE = {
  countryName: 'Palestinian Territory, Occupied',
  postalCodeFormat: '3Digits.json',
  alpha2: 'PS',
  alpha3: 'PSE',
  numeric3: '275',
};
const PAN = {
  countryName: 'Panama',
  postalCodeFormat: '4Digits.json',
  alpha2: 'PA',
  alpha3: 'PAN',
  numeric3: '591',
};
const PNG = {
  countryName: 'Papua New Guinea',
  postalCodeFormat: '3Digits.json',
  alpha2: 'PG',
  alpha3: 'PNG',
  numeric3: '598',
};
const PRY = {
  countryName: 'Paraguay',
  postalCodeFormat: '4Digits.json',
  alpha2: 'PY',
  alpha3: 'PRY',
  numeric3: '600',
};
const PER = {
  countryName: 'Peru',
  postalCodeFormat: '5Digits.json',
  alpha2: 'PE',
  alpha3: 'PER',
  numeric3: '604',
};
const PHL = {
  countryName: 'Philippines',
  postalCodeFormat: '4Digits.json',
  alpha2: 'PH',
  alpha3: 'PHL',
  numeric3: '608',
};
const PCN = {
  countryName: 'Pitcairn',
  postalCodeFormat: 'PN.json',
  alpha2: 'PN',
  alpha3: 'PCN',
  numeric3: '612',
};
const POL = {
  countryName: 'Poland',
  postalCodeFormat: 'PL.json',
  alpha2: 'PL',
  alpha3: 'POL',
  numeric3: '616',
};
const PRT = {
  countryName: 'Portugal',
  postalCodeFormat: 'PT.json',
  alpha2: 'PT',
  alpha3: 'PRT',
  numeric3: '620',
};
const PRI = {
  countryName: 'Puerto Rico',
  postalCodeFormat: 'US.json',
  alpha2: 'PR',
  alpha3: 'PRI',
  numeric3: '630',
};
const QAT = {
  countryName: 'Qatar',
  alpha2: 'QA',
  alpha3: 'QAT',
  numeric3: '634',
};
const REU = {
  countryName: 'Réunion',
  postalCodeFormat: 'RE.json',
  alpha2: 'RE',
  alpha3: 'REU',
  numeric3: '638',
};
const ROU = {
  countryName: 'Romania',
  postalCodeFormat: '6Digits.json',
  alpha2: 'RO',
  alpha3: 'ROU',
  numeric3: '642',
};
const RUS = {
  countryName: 'Russian Federation',
  postalCodeFormat: 'RU.json',
  alpha2: 'RU',
  alpha3: 'RUS',
  numeric3: '643',
};
const RWA = {
  countryName: 'Rwanda',
  alpha2: 'RW',
  alpha3: 'RWA',
  numeric3: '646',
};
const BLM = {
  countryName: 'Saint-Barthélemy',
  postalCodeFormat: 'BL.json',
  alpha2: 'BL',
  alpha3: 'BLM',
  numeric3: '652',
};
const SHN = {
  countryName: 'Saint Helena',
  postalCodeFormat: 'SH.json',
  alpha2: 'SH',
  alpha3: 'SHN',
  numeric3: '654',
};
const KNA = {
  countryName: 'Saint Kitts and Nevis',
  alpha2: 'KN',
  alpha3: 'KNA',
  numeric3: '659',
};
const LCA = {
  countryName: 'Saint Lucia',
  postalCodeFormat: 'LC.json',
  alpha2: 'LC',
  alpha3: 'LCA',
  numeric3: '662',
};
const MAF = {
  countryName: 'Saint-Martin (French part)',
  postalCodeFormat: 'MF.json',
  alpha2: 'MF',
  alpha3: 'MAF',
  numeric3: '663',
};
const SPM = {
  countryName: 'Saint Pierre and Miquelon',
  postalCodeFormat: 'PM.json',
  alpha2: 'PM',
  alpha3: 'SPM',
  numeric3: '666',
};
const VCT = {
  countryName: 'Saint Vincent and Grenadines',
  postalCodeFormat: 'VC.json',
  alpha2: 'VC',
  alpha3: 'VCT',
  numeric3: '670',
};
const WSM = {
  countryName: 'Samoa',
  postalCodeFormat: 'WS.json',
  alpha2: 'WS',
  alpha3: 'WSM',
  numeric3: '882',
};
const SMR = {
  countryName: 'San Marino',
  postalCodeFormat: 'SM.json',
  alpha2: 'SM',
  alpha3: 'SMR',
  numeric3: '674',
};
const STP = {
  countryName: 'Sao Tome and Principe',
  alpha2: 'ST',
  alpha3: 'STP',
  numeric3: '678',
};
const SAU = {
  countryName: 'Saudi Arabia',
  postalCodeFormat: 'US.json',
  alpha2: 'SA',
  alpha3: 'SAU',
  numeric3: '682',
};
const SEN = {
  countryName: 'Senegal',
  postalCodeFormat: '5Digits.json',
  alpha2: 'SN',
  alpha3: 'SEN',
  numeric3: '686',
};
const SRB = {
  countryName: 'Serbia',
  postalCodeFormat: '5Digits.json',
  alpha2: 'RS',
  alpha3: 'SRB',
  numeric3: '688',
};
const SYC = {
  countryName: 'Seychelles',
  alpha2: 'SC',
  alpha3: 'SYC',
  numeric3: '690',
};
const SLE = {
  countryName: 'Sierra Leone',
  alpha2: 'SL',
  alpha3: 'SLE',
  numeric3: '694',
};
const SGP = {
  countryName: 'Singapore',
  postalCodeFormat: '6Digits.json',
  alpha2: 'SG',
  alpha3: 'SGP',
  numeric3: '702',
};
const SVK = {
  countryName: 'Slovakia',
  postalCodeFormat: '5Digits.json',
  alpha2: 'SK',
  alpha3: 'SVK',
  numeric3: '703',
};
const SVN = {
  countryName: 'Slovenia',
  postalCodeFormat: '4Digits.json',
  alpha2: 'SI',
  alpha3: 'SVN',
  numeric3: '705',
};
const SLB = {
  countryName: 'Solomon Islands',
  alpha2: 'SB',
  alpha3: 'SLB',
  numeric3: '90',
};
const SOM = {
  countryName: 'Somalia',
  postalCodeFormat: 'SO.json',
  alpha2: 'SO',
  alpha3: 'SOM',
  numeric3: '706',
};
const ZAF = {
  countryName: 'South Africa',
  postalCodeFormat: '4Digits.json',
  alpha2: 'ZA',
  alpha3: 'ZAF',
  numeric3: '710',
};
const SGS = {
  countryName: 'South Georgia and the South Sandwich Islands',
  postalCodeFormat: 'GS.json',
  alpha2: 'GS',
  alpha3: 'SGS',
  numeric3: '239',
};
const SSD = {
  countryName: 'South Sudan',
  alpha2: 'SS',
  alpha3: 'SSD',
  numeric3: '728',
};
const ESP = {
  countryName: 'Spain',
  postalCodeFormat: '5Digits.json',
  alpha2: 'ES',
  alpha3: 'ESP',
  numeric3: '724',
};
const LKA = {
  countryName: 'Sri Lanka',
  postalCodeFormat: '5Digits.json',
  alpha2: 'LK',
  alpha3: 'LKA',
  numeric3: '144',
};
const SDN = {
  countryName: 'Sudan',
  postalCodeFormat: '5Digits.json',
  alpha2: 'SD',
  alpha3: 'SDN',
  numeric3: '736',
};
const SUR = {
  countryName: 'Suriname *',
  alpha2: 'SR',
  alpha3: 'SUR',
  numeric3: '740',
};
const SJM = {
  countryName: 'Svalbard and Jan Mayen Islands',
  postalCodeFormat: '4Digits.json',
  alpha2: 'SJ',
  alpha3: 'SJM',
  numeric3: '744',
};
const SWZ = {
  countryName: 'Swaziland',
  postalCodeFormat: 'SZ.json',
  alpha2: 'SZ',
  alpha3: 'SWZ',
  numeric3: '748',
};
const SWE = {
  countryName: 'Sweden',
  postalCodeFormat: '5Digits.json',
  alpha2: 'SE',
  alpha3: 'SWE',
  numeric3: '752',
};
const CHE = {
  countryName: 'Switzerland',
  postalCodeFormat: '4Digits.json',
  alpha2: 'CH',
  alpha3: 'CHE',
  numeric3: '756',
};
const SYR = {
  countryName: 'Syrian Arab Republic (Syria)',
  alpha2: 'SY',
  alpha3: 'SYR',
  numeric3: '760',
};
const TWN = {
  countryName: 'Taiwan, Republic of China',
  postalCodeFormat: 'TW.json',
  alpha2: 'TW',
  alpha3: 'TWN',
  numeric3: '158',
};
const TJK = {
  countryName: 'Tajikistan',
  postalCodeFormat: '6Digits.json',
  alpha2: 'TJ',
  alpha3: 'TJK',
  numeric3: '762',
};
const TZA = {
  countryName: 'Tanzania *, United Republic of',
  postalCodeFormat: '5Digits.json',
  alpha2: 'TZ',
  alpha3: 'TZA',
  numeric3: '834',
};
const THA = {
  countryName: 'Thailand',
  postalCodeFormat: '5Digits.json',
  alpha2: 'TH',
  alpha3: 'THA',
  numeric3: '764',
};
const TLS = {
  countryName: 'Timor-Leste',
  alpha2: 'TL',
  alpha3: 'TLS',
  numeric3: '626',
};
const TGO = {
  countryName: 'Togo',
  alpha2: 'TG',
  alpha3: 'TGO',
  numeric3: '768',
};
const TKL = {
  countryName: 'Tokelau',
  alpha2: 'TK',
  alpha3: 'TKL',
  numeric3: '772',
};
const TON = {
  countryName: 'Tonga',
  alpha2: 'TO',
  alpha3: 'TON',
  numeric3: '776',
};
const TTO = {
  countryName: 'Trinidad and Tobago',
  postalCodeFormat: '6Digits.json',
  alpha2: 'TT',
  alpha3: 'TTO',
  numeric3: '780',
};
const TUN = {
  countryName: 'Tunisia',
  postalCodeFormat: '4Digits.json',
  alpha2: 'TN',
  alpha3: 'TUN',
  numeric3: '788',
};
const TUR = {
  countryName: 'Turkey',
  postalCodeFormat: '5Digits.json',
  alpha2: 'TR',
  alpha3: 'TUR',
  numeric3: '792',
};
const TKM = {
  countryName: 'Turkmenistan',
  postalCodeFormat: '6Digits.json',
  alpha2: 'TM',
  alpha3: 'TKM',
  numeric3: '795',
};
const TCA = {
  countryName: 'Turks and Caicos Islands',
  postalCodeFormat: 'TC.json',
  alpha2: 'TC',
  alpha3: 'TCA',
  numeric3: '796',
};
const TUV = {
  countryName: 'Tuvalu',
  alpha2: 'TV',
  alpha3: 'TUV',
  numeric3: '798',
};
const UGA = {
  countryName: 'Uganda',
  alpha2: 'UG',
  alpha3: 'UGA',
  numeric3: '800',
};
const UKR = {
  countryName: 'Ukraine',
  postalCodeFormat: '5Digits.json',
  alpha2: 'UA',
  alpha3: 'UKR',
  numeric3: '804',
};
const ARE = {
  countryName: 'United Arab Emirates',
  alpha2: 'AE',
  alpha3: 'ARE',
  numeric3: '784',
};
const GBR = {
  countryName: 'United Kingdom',
  postalCodeFormat: 'GB.json',
  alpha2: 'GB',
  alpha3: 'GBR',
  numeric3: '826',
};
const USA = {
  countryName: 'United States of America',
  postalCodeFormat: 'US.json',
  alpha2: 'US',
  alpha3: 'USA',
  numeric3: '840',
};
const UMI = {
  countryName: 'United States Minor Outlying Islands',
  alpha2: 'UM',
  alpha3: 'UMI',
  numeric3: '581',
};
const URY = {
  countryName: 'Uruguay',
  postalCodeFormat: '5Digits.json',
  alpha2: 'UY',
  alpha3: 'URY',
  numeric3: '858',
};
const UZB = {
  countryName: 'Uzbekistan',
  postalCodeFormat: '6Digits.json',
  alpha2: 'UZ',
  alpha3: 'UZB',
  numeric3: '860',
};
const VUT = {
  countryName: 'Vanuatu',
  alpha2: 'VU',
  alpha3: 'VUT',
  numeric3: '548',
};
const VEN = {
  countryName: 'Venezuela (Bolivarian Republic of)',
  postalCodeFormat: 'VE.json',
  alpha2: 'VE',
  alpha3: 'VEN',
  numeric3: '862',
};
const VNM = {
  countryName: 'Viet Nam',
  postalCodeFormat: '6Digits.json',
  alpha2: 'VN',
  alpha3: 'VNM',
  numeric3: '704',
};
const VIR = {
  countryName: 'Virgin Islands, US',
  postalCodeFormat: 'US.json',
  alpha2: 'VI',
  alpha3: 'VIR',
  numeric3: '850',
};
const WLF = {
  countryName: 'Wallis and Futuna Islands',
  postalCodeFormat: 'WF.json',
  alpha2: 'WF',
  alpha3: 'WLF',
  numeric3: '876',
};
const ESH = {
  countryName: 'Western Sahara',
  alpha2: 'EH',
  alpha3: 'ESH',
  numeric3: '732',
};
const YEM = {
  countryName: 'Yemen',
  alpha2: 'YE',
  alpha3: 'YEM',
  numeric3: '887',
};
const ZMB = {
  countryName: 'Zambia',
  postalCodeFormat: '5Digits.json',
  alpha2: 'ZM',
  alpha3: 'ZMB',
  numeric3: '894',
};
const ZWE = {
  countryName: 'Zimbabwe',
  alpha2: 'ZW',
  alpha3: 'ZWE',
  numeric3: '716',
};
const require$$1$1 = {
  AFG,
  ALA,
  ALB,
  DZA,
  ASM,
  AND,
  AGO,
  AIA,
  ATA,
  ATG,
  ARG,
  ARM,
  ABW,
  AUS,
  AUT,
  AZE,
  BHS,
  BHR,
  BGD,
  BRB,
  BLR,
  BEL,
  BLZ,
  BEN,
  BMU,
  BTN,
  BOL,
  BIH,
  BWA,
  BVT,
  BRA,
  VGB,
  IOT,
  BRN,
  BGR,
  BFA,
  BDI,
  KHM,
  CMR,
  CAN,
  CPV,
  CYM,
  CAF,
  TCD,
  CHL,
  CHN,
  HKG,
  MAC,
  CXR,
  CCK,
  COL,
  COM,
  COG,
  COD,
  COK,
  CRI,
  CIV,
  HRV,
  CUB,
  CYP,
  CZE,
  DNK,
  DJI,
  DMA,
  DOM,
  ECU,
  EGY,
  SLV,
  GNQ,
  ERI,
  EST,
  ETH,
  FLK,
  FRO,
  FJI,
  FIN,
  FRA,
  GUF,
  PYF,
  ATF,
  GAB,
  GMB,
  GEO,
  DEU,
  GHA,
  GIB,
  GRC,
  GRL,
  GRD,
  GLP,
  GUM,
  GTM,
  GGY,
  GIN,
  GNB,
  GUY,
  HTI,
  HMD,
  VAT,
  HND,
  HUN,
  ISL,
  IND,
  IDN,
  IRN,
  IRQ,
  IRL,
  IMN,
  ISR,
  ITA,
  JAM,
  JPN,
  JEY,
  JOR,
  KAZ,
  KEN,
  KIR,
  PRK,
  KOR,
  KWT,
  KGZ,
  LAO,
  LVA,
  LBN,
  LSO,
  LBR,
  LBY,
  LIE,
  LTU,
  LUX,
  MKD,
  MDG,
  MWI,
  MYS,
  MDV,
  MLI,
  MLT,
  MHL,
  MTQ,
  MRT,
  MUS,
  MYT,
  MEX,
  FSM,
  MDA,
  MCO,
  MNG,
  MNE,
  MSR,
  MAR,
  MOZ,
  MMR,
  NAM,
  NRU,
  NPL,
  NLD,
  ANT,
  NCL,
  NZL,
  NIC,
  NER,
  NGA,
  NIU,
  NFK,
  MNP,
  NOR,
  OMN,
  PAK,
  PLW,
  PSE,
  PAN,
  PNG,
  PRY,
  PER,
  PHL,
  PCN,
  POL,
  PRT,
  PRI,
  QAT,
  REU,
  ROU,
  RUS,
  RWA,
  BLM,
  SHN,
  KNA,
  LCA,
  MAF,
  SPM,
  VCT,
  WSM,
  SMR,
  STP,
  SAU,
  SEN,
  SRB,
  SYC,
  SLE,
  SGP,
  SVK,
  SVN,
  SLB,
  SOM,
  ZAF,
  SGS,
  SSD,
  ESP,
  LKA,
  SDN,
  SUR,
  SJM,
  SWZ,
  SWE,
  CHE,
  SYR,
  TWN,
  TJK,
  TZA,
  THA,
  TLS,
  TGO,
  TKL,
  TON,
  TTO,
  TUN,
  TUR,
  TKM,
  TCA,
  TUV,
  UGA,
  UKR,
  ARE,
  GBR,
  USA,
  UMI,
  URY,
  UZB,
  VUT,
  VEN,
  VNM,
  VIR,
  WLF,
  ESH,
  YEM,
  ZMB,
  ZWE,
};
const Description$$ = '10-Digits - NNNNNNNNNN';
const RedundantCharacters$$ = ' -';
const ValidationRegex$$ = '^[0-9]{10}$';
const TestData$$ = {
  Valid: [
    '1234567890',
    '5678567833',
  ],
  Invalid: [
    '12334545698',
    '123s33s12',
    '123456789',
  ],
};
const require$$0 = {
  Description: Description$$,
  RedundantCharacters: RedundantCharacters$$,
  ValidationRegex: ValidationRegex$$,
  TestData: TestData$$,
};
const Description$_ = '2-Digits - NN';
const RedundantCharacters$_ = ' -';
const ValidationRegex$_ = '^[0-9]{2}$';
const TestData$_ = {
  Valid: [
    '12',
    '56',
  ],
  Invalid: [
    '012',
    '1s',
    '1',
    'x3',
  ],
};
const require$$1 = {
  Description: Description$_,
  RedundantCharacters: RedundantCharacters$_,
  ValidationRegex: ValidationRegex$_,
  TestData: TestData$_,
};
const Description$Z = '3-Digits - NNN';
const RedundantCharacters$Z = ' -';
const ValidationRegex$Z = '^[0-9]{3}$';
const TestData$Z = {
  Valid: [
    '123',
    '567',
  ],
  Invalid: [
    '1234',
    '13s',
    '1x3',
  ],
};
const require$$2 = {
  Description: Description$Z,
  RedundantCharacters: RedundantCharacters$Z,
  ValidationRegex: ValidationRegex$Z,
  TestData: TestData$Z,
};
const Description$Y = '4-Digits - NNNN';
const RedundantCharacters$Y = ' -';
const ValidationRegex$Y = '^[0-9]{4}$';
const TestData$Y = {
  Valid: [
    '1234',
    '5678',
  ],
  Invalid: [
    '12345',
    '123s',
    '12x3',
  ],
};
const require$$3 = {
  Description: Description$Y,
  RedundantCharacters: RedundantCharacters$Y,
  ValidationRegex: ValidationRegex$Y,
  TestData: TestData$Y,
};
const Description$X = '5-Digits - NNNNN';
const RedundantCharacters$X = ' -';
const ValidationRegex$X = '^[0-9]{5}$';
const TestData$X = {
  Valid: [
    '12345',
    '56785',
  ],
  Invalid: [
    '123456',
    '1233s',
    '123x3',
  ],
};
const require$$4 = {
  Description: Description$X,
  RedundantCharacters: RedundantCharacters$X,
  ValidationRegex: ValidationRegex$X,
  TestData: TestData$X,
};
const Description$W = '6-Digits - NNNNNN';
const RedundantCharacters$W = ' -';
const ValidationRegex$W = '^[0-9]{6}$';
const TestData$W = {
  Valid: [
    '123456',
    '567856',
  ],
  Invalid: [
    '1233456',
    '123s3s',
    '1s23x3',
  ],
};
const require$$5 = {
  Description: Description$W,
  RedundantCharacters: RedundantCharacters$W,
  ValidationRegex: ValidationRegex$W,
  TestData: TestData$W,
};
const Description$V = '7-Digits - NNNNNNN';
const RedundantCharacters$V = ' -';
const ValidationRegex$V = '^[0-9]{7}$';
const TestData$V = {
  Valid: [
    '1234567',
    '5678567',
  ],
  Invalid: [
    '123345456',
    '123s33s',
    '1s23x3',
  ],
};
const require$$6 = {
  Description: Description$V,
  RedundantCharacters: RedundantCharacters$V,
  ValidationRegex: ValidationRegex$V,
  TestData: TestData$V,
};
const Description$U = '8-Digits - NNNNNNNN';
const RedundantCharacters$U = ' -';
const ValidationRegex$U = '^[0-9]{8}$';
const TestData$U = {
  Valid: [
    '12345678',
    '56785678',
  ],
  Invalid: [
    '123345456',
    '123s33s',
    '1s23x3',
  ],
};
const require$$7 = {
  Description: Description$U,
  RedundantCharacters: RedundantCharacters$U,
  ValidationRegex: ValidationRegex$U,
  TestData: TestData$U,
};
const Description$T = 'AD : CCNNN';
const RedundantCharacters$T = ' -';
const ValidationRegex$T = '^AD[0-9]{3}$';
const TestData$T = {
  Valid: [
    'AD123',
    'AD001',
  ],
  Invalid: [
    'A1234',
    'AD12',
    'AD1234',
  ],
};
const require$$8 = {
  Description: Description$T,
  RedundantCharacters: RedundantCharacters$T,
  ValidationRegex: ValidationRegex$T,
  TestData: TestData$T,
};
const Description$S = 'AI : CC2640';
const RedundantCharacters$S = ' -';
const ValidationRegex$S = '^AI2640$';
const TestData$S = {
  Valid: [
    'AI2640',
    'AI-2640',
  ],
  Invalid: [
    'A2640',
    'AI02640',
    'AI-02640',
  ],
};
const require$$9 = {
  Description: Description$S,
  RedundantCharacters: RedundantCharacters$S,
  ValidationRegex: ValidationRegex$S,
  TestData: TestData$S,
};
const Description$R = 'AQ : BIQQ 1ZZ';
const RedundantCharacters$R = ' -';
const ValidationRegex$R = '^BIQQ1ZZ$';
const TestData$R = {
  Valid: [
    'BIQQ 1ZZ',
    'BIQQ1ZZ',
  ],
  Invalid: [
    'BIQQ1Z',
    'BIQQ01ZZ',
  ],
};
const require$$10 = {
  Description: Description$R,
  RedundantCharacters: RedundantCharacters$R,
  ValidationRegex: ValidationRegex$R,
  TestData: TestData$R,
};
const Description$Q = 'AX : NNNNN, CC-NNNNN';
const RedundantCharacters$Q = ' -';
const ValidationRegex$Q = '^(AX)?[0-9]{5}$';
const TestData$Q = {
  Valid: [
    '12345',
    'AX-12345',
    'AX12345',
  ],
  Invalid: [
    'AX123',
    'A1234',
    'AX-1234',
  ],
};
const require$$11 = {
  Description: Description$Q,
  RedundantCharacters: RedundantCharacters$Q,
  ValidationRegex: ValidationRegex$Q,
  TestData: TestData$Q,
};
const Description$P = 'AZ : CCNNNNN';
const RedundantCharacters$P = ' -';
const ValidationRegex$P = '^AZ[0-9]{4}$';
const TestData$P = {
  Valid: [
    'AZ1234',
    'AZ-1234',
  ],
  Invalid: [
    'AZ123',
    'A1234',
    'AZ-12345',
  ],
};
const require$$12 = {
  Description: Description$P,
  RedundantCharacters: RedundantCharacters$P,
  ValidationRegex: ValidationRegex$P,
  TestData: TestData$P,
};
const Description$O = 'BB : CCNNNNN';
const RedundantCharacters$O = ' -';
const ValidationRegex$O = '^(BB)?[0-9]{5}$';
const TestData$O = {
  Valid: [
    'BB12345',
    '12345',
  ],
  Invalid: [
    'x1231s',
    '1231sd',
  ],
};
const require$$13 = {
  Description: Description$O,
  RedundantCharacters: RedundantCharacters$O,
  ValidationRegex: ValidationRegex$O,
  TestData: TestData$O,
};
const Description$N = 'BH : NNN, NNNN';
const RedundantCharacters$N = ' -';
const ValidationRegex$N = '^[0-9]{3,4}$';
const TestData$N = {
  Valid: [
    '123',
    '1234',
  ],
  Invalid: [
    '12',
    '12345',
  ],
};
const require$$14 = {
  Description: Description$N,
  RedundantCharacters: RedundantCharacters$N,
  ValidationRegex: ValidationRegex$N,
  TestData: TestData$N,
};
const Description$M = 'BL : 97133';
const RedundantCharacters$M = ' -';
const ValidationRegex$M = '^97133$';
const TestData$M = {
  Valid: [
    '97133',
  ],
  Invalid: [
    '971330',
    '9713',
  ],
};
const require$$15 = {
  Description: Description$M,
  RedundantCharacters: RedundantCharacters$M,
  ValidationRegex: ValidationRegex$M,
  TestData: TestData$M,
};
const Description$L = 'BN : LLNNNN';
const RedundantCharacters$L = ' -';
const ValidationRegex$L = '^[a-zA-Z]{2}[0-9]{4}$';
const TestData$L = {
  Valid: [
    'AB1234',
    'tK0987',
  ],
  Invalid: [
    'abc123',
    'a12345',
    'at123',
    'BH12345',
  ],
};
const require$$16 = {
  Description: Description$L,
  RedundantCharacters: RedundantCharacters$L,
  ValidationRegex: ValidationRegex$L,
  TestData: TestData$L,
};
const Description$K = 'CA : A0A 0A0';
const RedundantCharacters$K = ' -';
const ValidationRegex$K = '^[ABCEGHJKLMNPRSTVXY]\\d[ABCEGHJ-NPRSTV-Z][\\s\\-]?\\d[ABCEGHJ-NPRSTV-Z]\\d$';
const TestData$K = {
  Valid: [
    'A4B5X5',
    'A4B5A5',
  ],
  Invalid: [
    '123AAA',
    '12A5AA',
  ],
};
const require$$17 = {
  Description: Description$K,
  RedundantCharacters: RedundantCharacters$K,
  ValidationRegex: ValidationRegex$K,
  TestData: TestData$K,
};
const Description$J = 'DK';
const RedundantCharacters$J = ' -';
const ValidationRegex$J = '^(DK){0,1}\\d{4}$';
const TestData$J = {
  Valid: [
    '1124',
    'DK1054',
    'DK-1120',
    'DK1120',
    'DK 1125',
    'DK - 1234',
    'dk-1123',
  ],
  Invalid: [
    '1125DK',
    'DK12345',
    'DK123',
    '123',
    '',
  ],
};
const require$$18 = {
  Description: Description$J,
  RedundantCharacters: RedundantCharacters$J,
  ValidationRegex: ValidationRegex$J,
  TestData: TestData$J,
};
const Description$I = 'FK : FIQQ 1ZZ';
const RedundantCharacters$I = ' -';
const ValidationRegex$I = '^FIQQ1ZZ$';
const TestData$I = {
  Valid: [
    'FIQQ 1ZZ',
    'FIQQ1ZZ',
  ],
  Invalid: [
    'FIQQ01ZZ',
    'FIQQ1ZZZ',
  ],
};
const require$$19 = {
  Description: Description$I,
  RedundantCharacters: RedundantCharacters$I,
  ValidationRegex: ValidationRegex$I,
  TestData: TestData$I,
};
const Description$H = 'GB';
const RedundantCharacters$H = ' -';
const ValidationRegex$H = '((([A-Za-z][0-9]{1,2})|(([A-Za-z][A-Ha-hJ-Yj-y][0-9]{1,2})|(([AZa-z][0-9][A-Za-z])|([A-Za-z][A-Ha-hJ-Yj-y][0-9]?[A-Za-z]))))[0-9][A-Za-z]{2})|GIR0AA';
const TestData$H = {
  Valid: [
    'CW3 9SS',
    'SE5 0EG',
    'SE50EG',
    'WC2H 7LT',
    'se5 0eg',
    'Z29ZZ',
    'Z699ZZ',
    'ZX99ZZ',
    'ZC999ZZ',
    'EC1A 1BB',
    'W1A 0AX',
    'M1 1AE',
    'B33 8TH',
    'CR2 6XH',
    'DN55 1PT',
    'GIR 0AA',
    'W1U 1BW',
    'SK8 7NA',
  ],
  Invalid: [
    'WC2H 7LTa',
    'WC2H',
  ],
};
const require$$20 = {
  Description: Description$H,
  RedundantCharacters: RedundantCharacters$H,
  ValidationRegex: ValidationRegex$H,
  'ValidationRegex.DOC': 'https://www.gov.uk/government/uploads/system/uploads/attachment_data/file/488478/Bulk_Data_Transfer_-_additional_validation_valid_from_12_November_2015.pdf',
  TestData: TestData$H,
};
const Description$G = 'GF : 973NN';
const RedundantCharacters$G = ' -';
const ValidationRegex$G = '^973[0-9]{2}$';
const TestData$G = {
  Valid: [
    '97300',
    '97390',
  ],
  Invalid: [
    '9732',
    '973999',
    '97290',
    '097390',
  ],
};
const require$$21 = {
  Description: Description$G,
  RedundantCharacters: RedundantCharacters$G,
  ValidationRegex: ValidationRegex$G,
  TestData: TestData$G,
};
const Description$F = 'GG';
const RedundantCharacters$F = ' -';
const ValidationRegex$F = '^GY[0-9]{2,3}[A-Za-z]{2}$';
const TestData$F = {
  Valid: [
    'GY1 1AA',
    'GY111AA',
  ],
  Invalid: [
    'CW3 9SS',
    'GG1 1AA',
    'SE5 0EG',
    'SE50EG',
    'WC2H 7LTa',
    'WC2H',
  ],
};
const require$$22 = {
  Description: Description$F,
  RedundantCharacters: RedundantCharacters$F,
  ValidationRegex: ValidationRegex$F,
  TestData: TestData$F,
};
const Description$E = 'GI : GX11 1AA';
const RedundantCharacters$E = ' -';
const ValidationRegex$E = '^GX111AA$';
const TestData$E = {
  Valid: [
    'GX111AA',
    'GX11 1AA',
  ],
  Invalid: [
    'GX1101AA',
    'GX111AAA',
  ],
};
const require$$23 = {
  Description: Description$E,
  RedundantCharacters: RedundantCharacters$E,
  ValidationRegex: ValidationRegex$E,
  TestData: TestData$E,
};
const Description$D = 'GP : 971NN';
const RedundantCharacters$D = ' -';
const ValidationRegex$D = '^971[0-9]{2}$';
const TestData$D = {
  Valid: [
    '97100',
    '97190',
  ],
  Invalid: [
    '9712',
    '971999',
    '97290',
    '097190',
  ],
};
const require$$24 = {
  Description: Description$D,
  RedundantCharacters: RedundantCharacters$D,
  ValidationRegex: ValidationRegex$D,
  TestData: TestData$D,
};
const Description$C = 'GS : SIQQ 1ZZ';
const RedundantCharacters$C = ' -';
const ValidationRegex$C = '^SIQQ1ZZ$';
const TestData$C = {
  Valid: [
    'SIQQ 1ZZ',
    'SIqq 1zz',
    'SIQQ1ZZ',
  ],
  Invalid: [
    'SIQQ01ZZ',
    'SIQQ1ZZZ',
  ],
};
const require$$25 = {
  Description: Description$C,
  RedundantCharacters: RedundantCharacters$C,
  ValidationRegex: ValidationRegex$C,
  TestData: TestData$C,
};
const Description$B = 'HN : CCNNNNN';
const RedundantCharacters$B = ' -';
const ValidationRegex$B = '^(HN)?[0-9]{5}$';
const TestData$B = {
  Valid: [
    'HN12345',
    '12345',
  ],
  Invalid: [
    '123456',
    'HN123456',
    'HN1234',
  ],
};
const require$$26 = {
  Description: Description$B,
  RedundantCharacters: RedundantCharacters$B,
  ValidationRegex: ValidationRegex$B,
  TestData: TestData$B,
};
const Description$A = 'IE';
const RedundantCharacters$A = '';
const ValidationRegex$A = '^[AaC-Fc-fHhKkNnPpRrTtV-Yv-y]\\d[0-9Ww][ -]?[0-9AaC-Fc-fHhKkNnPpRrTtV-Yv-y]{4}$';
const TestData$A = {
  Valid: [
    'D6W1234',
    'A23 0984',
    'D00-AV92',
    'y631fhk',
    'a00 0000',
    'd44-n4x4',
    'A65F4E2',
  ],
  Invalid: [
    'D6Z1234',
    'y63  1fhk',
  ],
};
const require$$27 = {
  Description: Description$A,
  RedundantCharacters: RedundantCharacters$A,
  ValidationRegex: ValidationRegex$A,
  'ValidationRegex.DOC': 'https://www.eircode.ie/docs/default-source/Common/prepareyourbusinessforeircode-edition3published.pdf?sfvrsn=2',
  TestData: TestData$A,
};
const Description$z = 'IM';
const RedundantCharacters$z = ' -';
const ValidationRegex$z = '^IM[0-9]{2,3}[A-Za-z]{2}$';
const TestData$z = {
  Valid: [
    'IM1 1AA',
    'IM111AA',
  ],
  Invalid: [
    'CW3 9SS',
    'SE5 0EG',
    'SE50EG',
    'WC2H 7LTa',
    'WC2H',
  ],
};
const require$$28 = {
  Description: Description$z,
  RedundantCharacters: RedundantCharacters$z,
  ValidationRegex: ValidationRegex$z,
  TestData: TestData$z,
};
const Description$y = 'IO : BBND 1ZZ';
const RedundantCharacters$y = ' -';
const ValidationRegex$y = '^BBND1ZZ$';
const TestData$y = {
  Valid: [
    'BBND 1ZZ',
    'BBND1ZZ',
  ],
  Invalid: [
    'BBND01ZZ',
    'BBND1ZZZ',
  ],
};
const require$$29 = {
  Description: Description$y,
  RedundantCharacters: RedundantCharacters$y,
  ValidationRegex: ValidationRegex$y,
  TestData: TestData$y,
};
const Description$x = 'JE';
const RedundantCharacters$x = ' -';
const ValidationRegex$x = '^JE[0-9]{2,3}[A-Za-z]{2}$';
const TestData$x = {
  Valid: [
    'JE1 1AA',
    'JE111AA',
  ],
  Invalid: [
    'CW3 9SS',
    'SE5 0EG',
    'SE50EG',
    'WC2H 7LTa',
    'WC2H',
  ],
};
const require$$30 = {
  Description: Description$x,
  RedundantCharacters: RedundantCharacters$x,
  ValidationRegex: ValidationRegex$x,
  TestData: TestData$x,
};
const Description$w = 'KY : CCN-NNNN';
const RedundantCharacters$w = ' -';
const ValidationRegex$w = '^KY[0-9]{5}$';
const TestData$w = {
  Valid: [
    'KY1-1234',
    'KY12345',
  ],
  Invalid: [
    'KY1234',
    'KY123456',
    'K1-1234',
  ],
};
const require$$31 = {
  Description: Description$w,
  RedundantCharacters: RedundantCharacters$w,
  ValidationRegex: ValidationRegex$w,
  TestData: TestData$w,
};
const Description$v = 'LB : NNNNN, NNNN NNNN';
const RedundantCharacters$v = ' -';
const ValidationRegex$v = '^[0-9]{4}(?:[0-9]{4})?$';
const TestData$v = {
  Valid: [
    '1234',
    '1234 1234',
    '12341234',
  ],
  Invalid: [
    '123',
    '1234567',
    '123456789',
  ],
};
const require$$32 = {
  Description: Description$v,
  RedundantCharacters: RedundantCharacters$v,
  ValidationRegex: ValidationRegex$v,
  TestData: TestData$v,
};
const Description$u = 'LC : CCNN NNN';
const RedundantCharacters$u = ' -';
const ValidationRegex$u = '^LC[0-9]{5}$';
const TestData$u = {
  Valid: [
    'LC12 345',
    'LC12345',
  ],
  Invalid: [
    '12345',
    'x1231s',
    '1231sd',
  ],
};
const require$$33 = {
  Description: Description$u,
  RedundantCharacters: RedundantCharacters$u,
  ValidationRegex: ValidationRegex$u,
  TestData: TestData$u,
};
const Description$t = 'LT : LT-NNNNN';
const RedundantCharacters$t = ' -';
const ValidationRegex$t = '^(LT)?[0-9]{5}$';
const TestData$t = {
  Valid: [
    '12345',
    'LT12345',
    'LT-12345',
  ],
  Invalid: [
    '1234',
    '123456',
    'LT-1234',
  ],
};
const require$$34 = {
  Description: Description$t,
  RedundantCharacters: RedundantCharacters$t,
  ValidationRegex: ValidationRegex$t,
  TestData: TestData$t,
};
const Description$s = 'LU';
const RedundantCharacters$s = ' -';
const ValidationRegex$s = '^(L){0,1}\\d{4}$';
const TestData$s = {
  Valid: [
    '1124',
    'L1054',
    'L-1120',
    'L1120',
    'L 1125',
    'L - 1234',
    'l-1123',
  ],
  Invalid: [
    '1125L',
    'L12345',
    'L123',
    '123',
    '',
  ],
};
const require$$35 = {
  Description: Description$s,
  RedundantCharacters: RedundantCharacters$s,
  ValidationRegex: ValidationRegex$s,
  TestData: TestData$s,
};
const Description$r = 'LV : NNNNN, CC-NNNNN';
const RedundantCharacters$r = ' -';
const ValidationRegex$r = '^(LV)?[0-9]{4}$';
const TestData$r = {
  Valid: [
    '1234',
    'LV-1234',
    'LV1234',
  ],
  Invalid: [
    'LV123',
    'L1234',
    'LV-12345',
  ],
};
const require$$36 = {
  Description: Description$r,
  RedundantCharacters: RedundantCharacters$r,
  ValidationRegex: ValidationRegex$r,
  TestData: TestData$r,
};
const Description$q = 'MC : 980NN';
const RedundantCharacters$q = ' -';
const ValidationRegex$q = '^980[0-9]{2}$';
const TestData$q = {
  Valid: [
    '98000',
    '98099',
  ],
  Invalid: [
    '98100',
    '97099',
  ],
};
const require$$37 = {
  Description: Description$q,
  RedundantCharacters: RedundantCharacters$q,
  ValidationRegex: ValidationRegex$q,
  TestData: TestData$q,
};
const Description$p = 'MD : CCNNNN, CC-NNNN';
const RedundantCharacters$p = ' -';
const ValidationRegex$p = '^(MD)?[0-9]{4}$';
const TestData$p = {
  Valid: [
    '1234',
    'MD1234',
    'MD-1234',
  ],
  Invalid: [
    'MD123',
    'M1234',
    'MD-12345',
  ],
};
const require$$38 = {
  Description: Description$p,
  RedundantCharacters: RedundantCharacters$p,
  ValidationRegex: ValidationRegex$p,
  TestData: TestData$p,
};
const Description$o = 'MF : 97150';
const RedundantCharacters$o = ' -';
const ValidationRegex$o = '^97150$';
const TestData$o = {
  Valid: [
    '97150',
  ],
  Invalid: [
    '971500',
    '9715',
  ],
};
const require$$39 = {
  Description: Description$o,
  RedundantCharacters: RedundantCharacters$o,
  ValidationRegex: ValidationRegex$o,
  TestData: TestData$o,
};
const Description$n = 'MS : MSR NNNN';
const RedundantCharacters$n = ' -';
const ValidationRegex$n = '^(MSR)?[0-9]{4}$';
const TestData$n = {
  Valid: [
    'MSR 1110',
    'MSR 1350',
    '1350',
  ],
  Invalid: [
    'MS1110',
    'MSR01350',
    '12345',
  ],
};
const require$$40 = {
  Description: Description$n,
  RedundantCharacters: RedundantCharacters$n,
  ValidationRegex: ValidationRegex$n,
  TestData: TestData$n,
};
const Description$m = 'MA : LLL NNNN';
const RedundantCharacters$m = ' -';
const ValidationRegex$m = '^[A-Z]{3}[0-9]{4}$';
const TestData$m = {
  Valid: [
    'abc1234',
    'ABC1234',
    'SHD4783',
  ],
  Invalid: [
    'ABCABC',
    '123ABCD',
  ],
};
const require$$41 = {
  Description: Description$m,
  RedundantCharacters: RedundantCharacters$m,
  ValidationRegex: ValidationRegex$m,
  TestData: TestData$m,
};
const Description$l = 'NC : 988NN';
const RedundantCharacters$l = ' -';
const ValidationRegex$l = '^988[0-9]{2}$';
const TestData$l = {
  Valid: [
    '98800',
    '98890',
  ],
  Invalid: [
    '9882',
    '988999',
    '98990',
    '098890',
  ],
};
const require$$42 = {
  Description: Description$l,
  RedundantCharacters: RedundantCharacters$l,
  ValidationRegex: ValidationRegex$l,
  TestData: TestData$l,
};
const Description$k = 'NL : NNNN LL';
const RedundantCharacters$k = ' -';
const ValidationRegex$k = '^[1-9][0-9]{3}(?!SA|SD|SS)[A-Z]{2}$';
const TestData$k = {
  Valid: [
    '1235DF',
    '5983DH',
    '1000 AP',
  ],
  Invalid: [
    '1235D',
    '12j4h',
    'k3j51l',
    '1945SS',
  ],
};
const require$$43 = {
  Description: Description$k,
  RedundantCharacters: RedundantCharacters$k,
  ValidationRegex: ValidationRegex$k,
  TestData: TestData$k,
};
const Description$j = 'PF : 987NN';
const RedundantCharacters$j = ' -';
const ValidationRegex$j = '^987[0-9]{2}$';
const TestData$j = {
  Valid: [
    '98700',
    '98790',
  ],
  Invalid: [
    '9872',
    '987999',
    '98690',
    '098790',
  ],
};
const require$$44 = {
  Description: Description$j,
  RedundantCharacters: RedundantCharacters$j,
  ValidationRegex: ValidationRegex$j,
  TestData: TestData$j,
};
const Description$i = 'PL : 99-999';
const RedundantCharacters$i = ' ';
const ValidationRegex$i = '^[0-9]{2}-[0-9]{3}$';
const TestData$i = {
  Valid: [
    '44-100 ',
    '44-100',
  ],
  Invalid: [
    '44100',
    '44f00',
    'e4410',
    '44-100d',
    'c44-100',
    'b44100',
    '44100a',
  ],
};
const require$$45 = {
  Description: Description$i,
  RedundantCharacters: RedundantCharacters$i,
  ValidationRegex: ValidationRegex$i,
  TestData: TestData$i,
};
const Description$h = 'PM : 97500';
const RedundantCharacters$h = ' -';
const ValidationRegex$h = '^97500$';
const TestData$h = {
  Valid: [
    '97500',
  ],
  Invalid: [
    '975000',
    '9750',
  ],
};
const require$$46 = {
  Description: Description$h,
  RedundantCharacters: RedundantCharacters$h,
  ValidationRegex: ValidationRegex$h,
  TestData: TestData$h,
};
const Description$g = 'PN : PCRN 1ZZ';
const RedundantCharacters$g = ' -';
const ValidationRegex$g = '^PCRN1ZZ$';
const TestData$g = {
  Valid: [
    'PCRN 1ZZ',
    'PCRN1ZZ',
  ],
  Invalid: [
    'PCRN01ZZ',
    'PCRN1ZZZ',
  ],
};
const require$$47 = {
  Description: Description$g,
  RedundantCharacters: RedundantCharacters$g,
  ValidationRegex: ValidationRegex$g,
  TestData: TestData$g,
};
const Description$f = 'PT : NNNN-NNN';
const RedundantCharacters$f = ' ';
const ValidationRegex$f = '^[0-9]{4}-[0-9]{3}$';
const TestData$f = {
  Valid: [
    '1234-123',
  ],
  Invalid: [
    '1255',
    '1234567',
    '1234 123',
    'x1231s',
    '1231sd',
    '1010101010',
    '1234 12',
  ],
};
const require$$48 = {
  Description: Description$f,
  RedundantCharacters: RedundantCharacters$f,
  ValidationRegex: ValidationRegex$f,
  TestData: TestData$f,
};
const Description$e = 'RE : 974NN';
const RedundantCharacters$e = ' -';
const ValidationRegex$e = '^974[0-9]{2}$';
const TestData$e = {
  Valid: [
    '97400',
    '97490',
  ],
  Invalid: [
    '9742',
    '974999',
    '97390',
    '097490',
  ],
};
const require$$49 = {
  Description: Description$e,
  RedundantCharacters: RedundantCharacters$e,
  ValidationRegex: ValidationRegex$e,
  TestData: TestData$e,
};
const Description$d = 'RU : NNN[-NNN]';
const RedundantCharacters$d = ' -';
const ValidationRegex$d = '^[0-9]{3}([0-9]{3})?$';
const TestData$d = {
  Valid: [
    '125',
    '123456',
  ],
  Invalid: [
    'x1231s',
    '1231sd',
    '1010101010',
  ],
};
const require$$50 = {
  Description: Description$d,
  RedundantCharacters: RedundantCharacters$d,
  ValidationRegex: ValidationRegex$d,
  TestData: TestData$d,
};
const Description$c = 'SH : STHL 1ZZ';
const RedundantCharacters$c = ' -';
const ValidationRegex$c = '^STHL1ZZ$';
const TestData$c = {
  Valid: [
    'STHL 1ZZ',
    'STHL1ZZ',
  ],
  Invalid: [
    'STHL01ZZ',
    'STHL1ZZZ',
  ],
};
const require$$51 = {
  Description: Description$c,
  RedundantCharacters: RedundantCharacters$c,
  ValidationRegex: ValidationRegex$c,
  TestData: TestData$c,
};
const Description$b = 'SM : 4789N';
const RedundantCharacters$b = ' -';
const ValidationRegex$b = '^4789[0-9]{1}$';
const TestData$b = {
  Valid: [
    '47890',
    '47899',
  ],
  Invalid: [
    '4789',
    '478900',
    '47889',
  ],
};
const require$$52 = {
  Description: Description$b,
  RedundantCharacters: RedundantCharacters$b,
  ValidationRegex: ValidationRegex$b,
  TestData: TestData$b,
};
const Description$a = 'SO : AA NNNNN';
const RedundantCharacters$a = ' -';
const ValidationRegex$a = '^[a-zA-Z]{2}[0-9]{5}$';
const TestData$a = {
  Valid: [
    'AW12345',
    'BN47899',
  ],
  Invalid: [
    '12345',
    'A12345',
    'SL123456',
  ],
};
const require$$53 = {
  Description: Description$a,
  RedundantCharacters: RedundantCharacters$a,
  ValidationRegex: ValidationRegex$a,
  TestData: TestData$a,
};
const Description$9 = 'SZ : ANNN';
const RedundantCharacters$9 = ' -';
const ValidationRegex$9 = '^[a-zA-Z]{1}[0-9]{3}$';
const TestData$9 = {
  Valid: [
    'S123',
    'a789',
  ],
  Invalid: [
    'F1234',
    'D12',
  ],
};
const require$$54 = {
  Description: Description$9,
  RedundantCharacters: RedundantCharacters$9,
  ValidationRegex: ValidationRegex$9,
  TestData: TestData$9,
};
const Description$8 = 'TC : TKCA 1ZZ';
const RedundantCharacters$8 = ' -';
const ValidationRegex$8 = '^TKCA1ZZ$';
const TestData$8 = {
  Valid: [
    'TKCA1ZZ',
    'TKCA 1ZZ',
  ],
  Invalid: [
    'TKCA01ZZ',
    'TKCA1ZZZ',
  ],
};
const require$$55 = {
  Description: Description$8,
  RedundantCharacters: RedundantCharacters$8,
  ValidationRegex: ValidationRegex$8,
  TestData: TestData$8,
};
const Description$7 = 'TW : NNN[-NN]';
const RedundantCharacters$7 = ' -';
const ValidationRegex$7 = '^[0-9]{3}([0-9]{2})?$';
const TestData$7 = {
  Valid: [
    '123',
    '123-45',
    '12345',
  ],
  Invalid: [
    '12',
    '1234',
    '101010',
  ],
};
const require$$56 = {
  Description: Description$7,
  RedundantCharacters: RedundantCharacters$7,
  ValidationRegex: ValidationRegex$7,
  TestData: TestData$7,
};
const Description$6 = 'US : NNNNN[-NNNN]';
const RedundantCharacters$6 = ' -';
const ValidationRegex$6 = '^[0-9]{5}([0-9]{4})?$';
const TestData$6 = {
  Valid: [
    '12345',
    '12345-7689',
  ],
  Invalid: [
    'x1231s',
    '1231sd',
    '1010101010',
  ],
};
const require$$57 = {
  Description: Description$6,
  RedundantCharacters: RedundantCharacters$6,
  ValidationRegex: ValidationRegex$6,
  TestData: TestData$6,
};
const Description$5 = 'VA : 00120';
const RedundantCharacters$5 = ' -';
const ValidationRegex$5 = '^00120$';
const TestData$5 = {
  Valid: [
    '00120',
  ],
  Invalid: [
    '0012',
    '001200',
  ],
};
const require$$58 = {
  Description: Description$5,
  RedundantCharacters: RedundantCharacters$5,
  ValidationRegex: ValidationRegex$5,
  TestData: TestData$5,
};
const Description$4 = 'VC : CCNNNNN';
const RedundantCharacters$4 = ' -';
const ValidationRegex$4 = '^(VC)?[0-9]{4}$';
const TestData$4 = {
  Valid: [
    '1234',
    'VC1234',
    'VC-1234',
  ],
  Invalid: [
    'VC123',
    'V1234',
    'VC-12345',
  ],
};
const require$$59 = {
  Description: Description$4,
  RedundantCharacters: RedundantCharacters$4,
  ValidationRegex: ValidationRegex$4,
  TestData: TestData$4,
};
const Description$3 = 'VE : NNNN, NNNN-A';
const RedundantCharacters$3 = ' -';
const ValidationRegex$3 = '^[0-9]{4}[a-zA-Z]?$';
const TestData$3 = {
  Valid: [
    '1234',
    '1234-A',
  ],
  Invalid: [
    '123',
    '1234AA',
  ],
};
const require$$60 = {
  Description: Description$3,
  RedundantCharacters: RedundantCharacters$3,
  ValidationRegex: ValidationRegex$3,
  TestData: TestData$3,
};
const Description$2 = 'VG : CCNNNN';
const RedundantCharacters$2 = ' -';
const ValidationRegex$2 = '^(VG)?[0-9]{4}$';
const TestData$2 = {
  Valid: [
    '1234',
    'VG1234',
    'VG-1234',
  ],
  Invalid: [
    'VG123',
    'V1234',
    'VG-12345',
  ],
};
const require$$61 = {
  Description: Description$2,
  RedundantCharacters: RedundantCharacters$2,
  ValidationRegex: ValidationRegex$2,
  TestData: TestData$2,
};
const Description$1 = 'WF : 986NN';
const RedundantCharacters$1 = ' -';
const ValidationRegex$1 = '^986[0-9]{2}$';
const TestData$1 = {
  Valid: [
    '98600',
    '98690',
  ],
  Invalid: [
    '9862',
    '986999',
    '98990',
    '098690',
  ],
};
const require$$62 = {
  Description: Description$1,
  RedundantCharacters: RedundantCharacters$1,
  ValidationRegex: ValidationRegex$1,
  TestData: TestData$1,
};
const Description = 'WS : CCNNNNN';
const RedundantCharacters = ' -';
const ValidationRegex = '^(WS)?[0-9]{4}$';
const TestData = {
  Valid: [
    '1234',
    'WS1234',
    'WS-1234',
  ],
  Invalid: [
    'WS123',
    'V1234',
    'WS-12345',
  ],
};
const require$$63 = {
  Description,
  RedundantCharacters,
  ValidationRegex,
  TestData,
};
var formatsWeb;
var hasRequiredFormatsWeb;
function requireFormatsWeb() {
  if (hasRequiredFormatsWeb)
    return formatsWeb;
  hasRequiredFormatsWeb = 1;
  const formats = {};
  formats['10Digits.json'] = require$$0;
  formats['2Digits.json'] = require$$1;
  formats['3Digits.json'] = require$$2;
  formats['4Digits.json'] = require$$3;
  formats['5Digits.json'] = require$$4;
  formats['6Digits.json'] = require$$5;
  formats['7Digits.json'] = require$$6;
  formats['8Digits.json'] = require$$7;
  formats['AD.json'] = require$$8;
  formats['AI.json'] = require$$9;
  formats['AQ.json'] = require$$10;
  formats['AX.json'] = require$$11;
  formats['AZ.json'] = require$$12;
  formats['BB.json'] = require$$13;
  formats['BH.json'] = require$$14;
  formats['BL.json'] = require$$15;
  formats['BN.json'] = require$$16;
  formats['CA.json'] = require$$17;
  formats['DK.json'] = require$$18;
  formats['FK.json'] = require$$19;
  formats['GB.json'] = require$$20;
  formats['GF.json'] = require$$21;
  formats['GG.json'] = require$$22;
  formats['GI.json'] = require$$23;
  formats['GP.json'] = require$$24;
  formats['GS.json'] = require$$25;
  formats['HN.json'] = require$$26;
  formats['IE.json'] = require$$27;
  formats['IM.json'] = require$$28;
  formats['IO.json'] = require$$29;
  formats['JE.json'] = require$$30;
  formats['KY.json'] = require$$31;
  formats['LB.json'] = require$$32;
  formats['LC.json'] = require$$33;
  formats['LT.json'] = require$$34;
  formats['LU.json'] = require$$35;
  formats['LV.json'] = require$$36;
  formats['MC.json'] = require$$37;
  formats['MD.json'] = require$$38;
  formats['MF.json'] = require$$39;
  formats['MS.json'] = require$$40;
  formats['MT.json'] = require$$41;
  formats['NC.json'] = require$$42;
  formats['NL.json'] = require$$43;
  formats['PF.json'] = require$$44;
  formats['PL.json'] = require$$45;
  formats['PM.json'] = require$$46;
  formats['PN.json'] = require$$47;
  formats['PT.json'] = require$$48;
  formats['RE.json'] = require$$49;
  formats['RU.json'] = require$$50;
  formats['SH.json'] = require$$51;
  formats['SM.json'] = require$$52;
  formats['SO.json'] = require$$53;
  formats['SZ.json'] = require$$54;
  formats['TC.json'] = require$$55;
  formats['TW.json'] = require$$56;
  formats['US.json'] = require$$57;
  formats['VA.json'] = require$$58;
  formats['VC.json'] = require$$59;
  formats['VE.json'] = require$$60;
  formats['VG.json'] = require$$61;
  formats['WF.json'] = require$$62;
  formats['WS.json'] = require$$63;
  formatsWeb = function getFormat2(postalCodeFormat) {
    return formats[postalCodeFormat];
  };
  return formatsWeb;
}
const byAlpha2 = require$$0$1;
const byAlpha3 = require$$1$1;
var getFormat = null;
{
  getFormat = requireFormatsWeb();
}
var validate = function (countryCode, postalCode) {
  if (!countryCode) {
    return 'Missing country code.';
  }
  if (!postalCode) {
    return 'Missing postal code.';
  }
  var countryData = void 0;
  var preparedCountryCode = countryCode.trim().toUpperCase();
  if (preparedCountryCode.length == 2) {
    countryData = byAlpha2[preparedCountryCode];
  }
  if (preparedCountryCode.length == 3) {
    countryData = byAlpha3[preparedCountryCode];
  }
  if (!countryData) {
    return 'Unknown alpha2/alpha3 country code: ' + preparedCountryCode;
  }
  if (!countryData.postalCodeFormat) {
    return true;
  }
  var format = getFormat(countryData.postalCodeFormat);
  if (!format) {
    return 'Failed to load postal code format "' + countryData.postalCodeFormat + '".';
  }
  var preparedPostalCode = postalCode.toString().trim().slice(0);
  for (var i = 0; i < format.RedundantCharacters.length; i++) {
    preparedPostalCode = preparedPostalCode.replace(new RegExp(format.RedundantCharacters[i], 'g'), '');
  }
  var expression = format.ValidationRegex;
  if (expression instanceof Array) {
    expression = '^' + expression.join('|') + '$';
  }
  const regexp = new RegExp(expression, 'i');
  var result = regexp.exec(preparedPostalCode);
  if (!result) {
    return 'Postal code ' + preparedPostalCode + ' is not valid for country ' + preparedCountryCode;
  }
  if (result[0].toLowerCase() != preparedPostalCode.toLowerCase()) {
    return 'Postal code ' + preparedPostalCode + ' is not valid for country ' + preparedCountryCode;
  }
  return true;
};
function searchElement(addressParent, searchElem) {
  const addressContainer = Array.from(addressParent == null ? void 0 : addressParent.children);
  let result;
  addressContainer.forEach((e) => {
    if (e instanceof HTMLElement && e.classList.contains(searchElem)) {
      result = e;
    }
  });
  return result;
}
function searchInput(addressParent) {
  const addressContainer = Array.from(addressParent == null ? void 0 : addressParent.children);
  let result;
  addressContainer.forEach((e) => {
    if (e.tagName === 'INPUT') {
      result = e;
    }
  });
  return result;
}
function findElement(element, searchElem, getAllMatches = false) {
  const matches = [];
  if (element.classList.contains(searchElem)) {
    if (getAllMatches) {
      matches.push(element);
    } else {
      return element;
    }
  }
  const children = element.children;
  for (let i = 0; i < children.length; i++) {
    const result = findElement(children[i], searchElem, getAllMatches);
    if (result) {
      if (Array.isArray(result)) {
        matches.push(...result);
      } else {
        if (getAllMatches) {
          matches.push(result);
        } else {
          return result;
        }
      }
    }
  }
  if (matches.length > 0) {
    return matches;
  }
  return;
}
function getCountriesList(elements) {
  return elements.map((element) => {
    const parent = element.parentElement;
    if (parent && parent.parentElement) {
      return parent.parentElement;
    } else {
      return null;
    }
  }).filter((parent) => parent !== null).flatMap((elem) => {
    const wrapper = searchElement(elem, 'country-wrapper');
    return wrapper ? [wrapper] : [];
  }).flatMap((elem) => {
    const wrapper = searchElement(elem, 'countries-list');
    return wrapper ? [wrapper] : [];
  }).filter((elem) => elem !== void 0);
}
const ERROR_MESSAGES = {
  shortInput: 'Must contain at least 2 letters',
  longInput: 'Must contain less than 40 letters',
  invalidEmail: 'Invalid email format',
  missingAtSymbol: "Email must contain an '@' symbol",
  missingDomain: 'Email must contain a domain name',
  invalidCharacters: 'Email contains invalid characters',
  onlyEnglishLetters: 'Must contain only English letters',
  onlyEnglishLettersAndNumbers: 'Must contain only English letters and numbers',
  invalidFormat: 'Incorrect format',
  passwordRequirements: 'Password must meet requirements',
  mustBeNumber: 'Must be a number',
  dateOfBirth: 'Please enter your date of birth',
  atLeast8Characters: 'Password must contain at least 8 characters',
  passwordDetails: 'Password must contain at  at least 1 uppercase letter, 1 lowercase letter and 1 number',
  ageRequirement: 'You must be 13 or older',
  incorrectData: 'Please enter correct data',
  passwordNoSpaces: 'Password must not contain spaces',
};
const REGEX = {
  email: /[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}/,
  lettersOnly: /^[a-zA-Z]+$/,
  lettersAndNumbers: /^[A-Za-z0-9._%+-]+$/,
  lettersAndNumbersAndWhiteSpaces: /^[A-Za-z0-9._%+-\s]+$/,
  birthDate: /^(0[1-9]|1[0-2]).(0[1-9]|[12][0-9]|3[01]).\d{4}$/,
  number: /^\d+$/,
  password: /^(?=.*[A-Z])(?=.*[a-z])(?=.*\d)(?=.*[!@#$%^&*])[\S]{8,}$/,
  lettersAndSpacesAndHyphens: /^[A-Za-z\s-]+$/,
};
function incorectValidation(errorSpan, errorMessage) {
  errorSpan.textContent = errorMessage;
}
function mailValidation(value, err, index) {
  if (err && index != null) {
    if (value.length === 0) {
      incorectValidation(err, ERROR_MESSAGES.invalidEmail);
      setValidStatus(index, false);
      checkAllInputs();
      return false;
    }
    if (value.length >= 40) {
      incorectValidation(err, ERROR_MESSAGES.longInput);
      setValidStatus(index, false);
      checkAllInputs();
      return false;
    }
    if (!value.includes('@')) {
      incorectValidation(err, ERROR_MESSAGES.missingAtSymbol);
      setValidStatus(index, false);
      checkAllInputs();
      return false;
    }
    const domainPart = value.split('@');
    if (!domainPart) {
      incorectValidation(err, ERROR_MESSAGES.missingDomain);
      setValidStatus(index, false);
      checkAllInputs();
      return false;
    }
    if (!REGEX.email.test(String(value).toLowerCase())) {
      incorectValidation(err, ERROR_MESSAGES.invalidEmail);
      setValidStatus(index, false);
      checkAllInputs();
      return false;
    }
    incorectValidation(err, '');
    setValidStatus(index, true);
    checkAllInputs();
    return true;
  }
  return true;
}
function validationBirth(value, err) {
  if (err) {
    const regex = REGEX.birthDate;
    if (!regex.test(value)) {
      incorectValidation(err, ERROR_MESSAGES.invalidFormat);
      return false;
    }
  }
  return true;
}
function nameValidation(value, err, index) {
  if (err && index != null) {
    if (value.length === 0) {
      incorectValidation(err, '');
      setValidStatus(index, false);
      checkAllInputs();
      return false;
    }
    if (value.length <= 1) {
      incorectValidation(err, ERROR_MESSAGES.shortInput);
      setValidStatus(index, false);
      checkAllInputs();
      return false;
    }
    if (value.length >= 40) {
      incorectValidation(err, ERROR_MESSAGES.longInput);
      setValidStatus(index, false);
      checkAllInputs();
      return false;
    }
    if (!REGEX.lettersOnly.test(value)) {
      incorectValidation(err, ERROR_MESSAGES.onlyEnglishLetters);
      setValidStatus(index, false);
      checkAllInputs();
      return false;
    }
    setValidStatus(index, true);
    checkAllInputs();
    incorectValidation(err, '');
    return true;
  }
  return true;
}
function lastNameValidation(value, err, index) {
  if (err && index != null) {
    if (value.length === 0) {
      incorectValidation(err, '');
      setValidStatus(index, false);
      checkAllInputs();
      return false;
    }
    if (value.length <= 1) {
      incorectValidation(err, ERROR_MESSAGES.shortInput);
      setValidStatus(index, false);
      checkAllInputs();
      return false;
    }
    if (!REGEX.lettersOnly.test(value)) {
      incorectValidation(err, ERROR_MESSAGES.onlyEnglishLetters);
      setValidStatus(index, false);
      checkAllInputs();
      return false;
    }
    setValidStatus(index, true);
    checkAllInputs();
    incorectValidation(err, '');
    return true;
  }
  return true;
}
function cityValidation(value, err, index, form) {
  var _a;
  if (err && form && index != null) {
    const filterArr = filterArray(form);
    const street = filterArr[index + 1];
    const streetErr = checkError((_a = street.parentElement) == null ? void 0 : _a.children);
    if (streetErr) {
      if (value.length === 0) {
        if (street instanceof HTMLInputElement) {
          setValidStatus(index, false);
          setValidStatus(index + 1, false);
          checkAllInputs();
          street.value = '';
          incorectValidation(err, '');
          return false;
        }
      }
      if (value.length >= 40) {
        incorectValidation(err, ERROR_MESSAGES.longInput);
        setValidStatus(index, false);
        checkAllInputs();
        return false;
      }
      if (value.length <= 1) {
        if (street instanceof HTMLInputElement) {
          street.setAttribute('disabled', '');
          incorectValidation(err, ERROR_MESSAGES.shortInput);
          setValidStatus(index, false);
          setValidStatus(index + 1, false);
          checkAllInputs();
          streetErr.textContent = '';
          street.value = '';
          return false;
        }
      }
      if (!REGEX.lettersAndSpacesAndHyphens.test(value)) {
        if (street instanceof HTMLInputElement) {
          setValidStatus(index, false);
          setValidStatus(index + 1, false);
          checkAllInputs();
          street.setAttribute('disabled', '');
          streetErr.textContent = '';
          street.value = '';
          incorectValidation(err, ERROR_MESSAGES.incorrectData);
          return false;
        }
      }
      incorectValidation(err, '');
      setValidStatus(index, true);
      checkAllInputs();
      street.removeAttribute('disabled');
      return true;
    }
  }
  return true;
}
function streetValidation(value, err, index) {
  if (err && index != null) {
    if (value.length === 0) {
      setValidStatus(index, false);
      checkAllInputs();
      incorectValidation(err, '');
      return false;
    }
    if (value.length >= 40) {
      incorectValidation(err, ERROR_MESSAGES.longInput);
      setValidStatus(index, false);
      checkAllInputs();
      return false;
    }
    if (value.length <= 1) {
      setValidStatus(index, false);
      checkAllInputs();
      incorectValidation(err, ERROR_MESSAGES.shortInput);
      return false;
    }
    if (!REGEX.lettersAndNumbersAndWhiteSpaces.test(value)) {
      setValidStatus(index, false);
      checkAllInputs();
      incorectValidation(err, ERROR_MESSAGES.onlyEnglishLetters);
      return false;
    }
    setValidStatus(index, true);
    checkAllInputs();
    incorectValidation(err, '');
    return true;
  }
  return true;
}
function passwordValidation(value, err, index, form) {
  if (err && index != null && form) {
    if (/\s/.test(value)) {
      setValidStatus(index, false);
      checkAllInputs(form);
      incorectValidation(err, ERROR_MESSAGES.passwordNoSpaces);
      err.style.bottom = '0px';
      return false;
    }
    if (value.length >= 40) {
      incorectValidation(err, ERROR_MESSAGES.longInput);
      setValidStatus(index, false);
      checkAllInputs();
      return false;
    }
    if (value.length < 8) {
      setValidStatus(index, false);
      checkAllInputs(form);
      incorectValidation(err, ERROR_MESSAGES.atLeast8Characters);
      err.style.bottom = '0px';
      return false;
    }
    if (!/[A-Z]/.test(value)) {
      setValidStatus(index, false);
      checkAllInputs(form);
      incorectValidation(err, ERROR_MESSAGES.passwordDetails);
      err.style.bottom = '-4px';
      return false;
    }
    if (!/[a-z]/.test(value)) {
      setValidStatus(index, false);
      checkAllInputs(form);
      err.style.bottom = '0px';
      incorectValidation(err, ERROR_MESSAGES.passwordDetails);
      return false;
    }
    if (!/\d/.test(value)) {
      setValidStatus(index, false);
      checkAllInputs(form);
      incorectValidation(err, ERROR_MESSAGES.passwordDetails);
      err.style.bottom = '0px';
      return false;
    }
    setValidStatus(index, true);
    checkAllInputs(form);
    incorectValidation(err, '');
    err.style.bottom = '0px';
    return true;
  }
  return true;
}
function dayValidation(value, err) {
  const dateMonth = monthDate;
  const dateYear = yearDate;
  const daysInMonth = checkDaysInMonth(dateMonth.value, dateYear.value);
  if (err) {
    if (value.length === 0) {
      incorectValidation(err, '');
      return;
    }
    if (!parseInt(value)) {
      incorectValidation(err, ERROR_MESSAGES.mustBeNumber);
      if (parseInt(value) > daysInMonth) {
        incorectValidation(err, ERROR_MESSAGES.dateOfBirth);
        return;
      }
      return;
    } else {
      incorectValidation(err, '');
      return parseInt(value);
    }
  }
}
function monthValidation(value, err, index) {
  if (err && index != null) {
    if (value.length === 0) {
      incorectValidation(err, '');
      return;
    }
    if (!parseInt(value)) {
      incorectValidation(err, ERROR_MESSAGES.mustBeNumber);
      if (parseInt(value) > 12) {
        incorectValidation(err, ERROR_MESSAGES.dateOfBirth);
        return;
      }
      return;
    } else {
      incorectValidation(err, '');
      return parseInt(value);
    }
  }
}
function yearValidation(value, err, index) {
  if (err && index != null) {
    const year = parseInt(value);
    if (isNaN(year)) {
      incorectValidation(err, ERROR_MESSAGES.mustBeNumber);
      return;
    }
    const age = calculateAge(new Date(year, 0, 1));
    if (age < 13) {
      incorectValidation(err, ERROR_MESSAGES.ageRequirement);
      return;
    }
    incorectValidation(err, '');
    return year;
  }
  return parseInt(value);
}
function checkNumber(event2) {
  var _a;
  const elem = event2.target;
  const parent = elem.parentNode;
  const form = elem.form;
  const err = checkError((_a = parent == null ? void 0 : parent.parentElement) == null ? void 0 : _a.children);
  const dateDay = form == null ? void 0 : form.querySelector('.date__day');
  const dateMonth = form == null ? void 0 : form.querySelector('.date__month');
  const dateYear = form == null ? void 0 : form.querySelector('.date__year');
  const daysInMonth = checkDaysInMonth(dateMonth.value, dateYear.value);
  if (!parent) {
    return;
  }
  if (+dateYear.value && +dateMonth.value && +dateDay.value) {
    if (+dateMonth.value <= 12 && +dateDay.value <= daysInMonth && +dateYear.value <= 2024 && +dateYear.value >= 1900) {
      const age = new Date(
        +dateYear.value,
        +dateMonth.value - 1,
        +dateDay.value,
      );
      if (calculateAge(age) < 13) {
        incorectValidation(err, ERROR_MESSAGES.ageRequirement);
      } else {
        setValidStatus(4, true);
        checkAllInputs();
        incorectValidation(err, '');
      }
    } else {
      setValidStatus(4, false);
      checkAllInputs();
      incorectValidation(err, ERROR_MESSAGES.incorrectData);
    }
  } else {
    setValidStatus(4, false);
    checkAllInputs();
    incorectValidation(err, ERROR_MESSAGES.incorrectData);
  }
}
function postCodeValidation(value, err, index, form) {
  var _a, _b, _c;
  if (err && form && index != null) {
    const filterArr = filterArray(form);
    const city = filterArr[index + 1];
    const container = (_a = city.parentElement) == null ? void 0 : _a.parentElement;
    const contryWrapper = searchElement(
      container,
      'country-wrapper',
    );
    const contryList = searchElement(
      contryWrapper,
      'countries-list',
    );
    const countryNames = countrys.names();
    const countryIndex = countryNames.indexOf(contryList.textContent || '');
    const street = filterArr[index + 2];
    const streetErr = checkError((_b = street.parentElement) == null ? void 0 : _b.children);
    const cityErr = checkError((_c = city.parentElement) == null ? void 0 : _c.children);
    if (streetErr && cityErr) {
      const postCode = Object.keys(countrys.all)[countryIndex];
      if (value.length === 0) {
        if (street instanceof HTMLInputElement && city instanceof HTMLInputElement) {
          incorectValidation(err, '');
          city.setAttribute('disabled', '');
          street.setAttribute('disabled', '');
          setValidStatus(index, false);
          setValidStatus(index + 1, false);
          setValidStatus(index + 2, false);
          checkAllInputs();
          cityErr.textContent = '';
          streetErr.textContent = '';
          city.value = '';
          street.value = '';
          return;
        }
      }
      if (validate(postCode, value) === true) {
        city.removeAttribute('disabled');
        incorectValidation(err, '');
        setValidStatus(index, true);
        checkAllInputs();
      } else {
        if (city instanceof HTMLInputElement && street instanceof HTMLInputElement) {
          city.setAttribute('disabled', '');
          street.setAttribute('disabled', '');
          setValidStatus(index, false);
          setValidStatus(index + 1, false);
          setValidStatus(index + 2, false);
          checkAllInputs();
          cityErr.textContent = '';
          streetErr.textContent = '';
          city.value = '';
          street.value = '';
          incorectValidation(err, ERROR_MESSAGES.incorrectData);
        }
      }
    }
  }
}
function disableLocation(wrapper) {
  var _a;
  const parent = (_a = wrapper.parentElement) == null ? void 0 : _a.parentElement;
  const postLabel = searchElement(parent, 'label-post');
  const cityLabel = searchElement(parent, 'label-city');
  const streetLabel = searchElement(parent, 'label-street');
  const post = searchInput(postLabel);
  const city = searchInput(cityLabel);
  const street = searchInput(streetLabel);
  const postErr = checkError(postLabel.children);
  const cityErr = checkError(cityLabel.children);
  const streetErr = checkError(streetLabel.children);
  if (postErr && cityErr && streetErr) {
    postErr.textContent = '';
    cityErr.textContent = '';
    streetErr.textContent = '';
    street.setAttribute('disabled', '');
    city.setAttribute('disabled', '');
    const cityIndex = checkInputIndex(city);
    const streetIndex = checkInputIndex(street);
    const postIndex = checkInputIndex(street);
    setValidStatus(cityIndex, false);
    setValidStatus(streetIndex, false);
    setValidStatus(postIndex, false);
    checkAllInputs();
    street.value = '';
    post.value = '';
    city.value = '';
  }
}
function checkError(childrens) {
  if (childrens) {
    const childrenArray = Array.from(childrens);
    for (const element of childrenArray) {
      if (element.classList.contains('error')) {
        return element;
      }
    }
  }
  return null;
}
function checkInputIndex(event2) {
  if (event2 instanceof Event) {
    const elem = event2.target;
    const form = elem.form;
    const formArray = Array.from(form.elements).filter(
      (element) => element.tagName === 'INPUT' && element.getAttribute('type') !== 'checkbox' && element.getAttribute('hide') !== '',
    );
    const index = formArray.indexOf(elem);
    return index;
  } else {
    const form = event2.form;
    const formArray = filterArray(form);
    const index = formArray.indexOf(event2);
    return index;
  }
}
function validateInput(event2) {
  var _a;
  const indexOfInput = checkInputIndex(event2);
  const element = event2.target;
  const value = element.value.trim();
  const error = checkError((_a = element.parentElement) == null ? void 0 : _a.children);
  const form = element.form;
  const attribute = element.getAttribute('data-validation-type');
  const validationMap = {
    name: nameValidation,
    lastName: lastNameValidation,
    city: cityValidation,
    post: postCodeValidation,
    street: streetValidation,
    password: passwordValidation,
    email: mailValidation,
    birthday: validationBirth,
    day: dayValidation,
    month: monthValidation,
    year: yearValidation,
  };
  if (attribute && validationMap[attribute]) {
    validationMap[attribute](value, error, indexOfInput, form);
  }
  return true;
}
function addPasswordModal(userData) {
  const app = document.querySelector('#app');
  const profileForm = app.querySelector(
    '.profile-container__profile-form',
  );
  const passwordModalParams = {
    tag: 'div',
    classNames: ['modal__change-password', 'modal_container'],
  };
  const passwordModal = createElement$1(passwordModalParams);
  const passwordFormParams = {
    tag: 'form',
    classNames: ['modal__password-form'],
    attributes: { id: 'change-password-form' },
  };
  const formTitleParams = {
    tag: 'h2',
    classNames: ['password-form__title'],
    textContent: 'Enter your new Password',
  };
  const formTitle = createElement$1(formTitleParams);
  const passwordForm = createElement$1(passwordFormParams);
  const [currentPasswordLabel, currentPasswordInput] = createInput(
    'current-password',
    [
      ['current-password-label', 'prof-label'],
      ['current-passwrod-input', 'prof-input'],
    ],
    'password',
    'password',
  );
  const currentPasswordIconParams = {
    tag: 'img',
    attributes: {
      src: '/assets/authpage/hide.png',
      alt: 'make your password visible/hide',
      title: 'Click to make your password visible',
    },
    classNames: ['password_icon', 'change-password-icon'],
  };
  const currentPasswordIcon = createElement$1(
    currentPasswordIconParams,
  );
  currentPasswordIcon.addEventListener('click', showPassword);
  const currentPasswordError = createErrorElement();
  currentPasswordInput.addEventListener('input', validateInput);
  currentPasswordLabel.textContent = 'Current Password';
  const [newPasswordLabel, newPasswordInput] = createInput(
    'confirm-password',
    [
      ['new-password-label', 'prof-label'],
      ['new-passwrod-input', 'prof-input'],
    ],
    'password',
    'password',
  );
  const newPasswordIconParams = {
    tag: 'img',
    attributes: {
      src: '/assets/authpage/hide.png',
      alt: 'make your password visible/hide',
      title: 'Click to make your password visible',
    },
    classNames: ['password_icon', 'change-password-icon'],
  };
  const newPasswordIcon = createElement$1(
    newPasswordIconParams,
  );
  newPasswordIcon.addEventListener('click', showPassword);
  newPasswordLabel.textContent = 'New Password';
  newPasswordInput.addEventListener('input', validateInput);
  const newPasswordError = createErrorElement();
  const buttonsContainerParams = {
    tag: 'div',
    classNames: ['password-form__btn-container'],
  };
  const buttonCloseParams = {
    tag: 'button',
    classNames: ['password-form__close', 'profile-btn'],
    textContent: 'Close',
  };
  const buttonSaveParams = {
    tag: 'button',
    classNames: ['password-form__save', 'profile-btn'],
    textContent: 'Save',
    attributes: { form: 'change-password-form', disabled: '' },
  };
  const buttonsContainer = createElement$1(buttonsContainerParams);
  const buttonClose = createElement$1(buttonCloseParams);
  const buttonSave = createElement$1(buttonSaveParams);
  buttonClose.addEventListener('click', (e) => {
    e.preventDefault();
    passwordModal.remove();
    fillObjectWithUniqueKeys(profileForm, true, validStatus, true);
  });
  buttonSave.addEventListener('click', (e) => {
    e.preventDefault();
    passwordModal.remove();
    const body = {
      id: userData.id,
      version: userData.version,
      currentPassword: currentPasswordInput.value,
      newPassword: newPasswordInput.value,
    };
    changePassword(userData, body);
    fillObjectWithUniqueKeys(profileForm, true, validStatus, true);
  });
  addInnerComponent(buttonsContainer, buttonClose);
  addInnerComponent(buttonsContainer, buttonSave);
  if (app) {
    addInnerComponent(app, passwordModal);
    addInnerComponent(passwordModal, passwordForm);
    addInnerComponent(passwordForm, formTitle);
    addInnerComponent(passwordForm, currentPasswordLabel);
    addInnerComponent(currentPasswordLabel, currentPasswordInput);
    addInnerComponent(currentPasswordLabel, currentPasswordError);
    addInnerComponent(currentPasswordLabel, newPasswordIcon);
    addInnerComponent(passwordForm, newPasswordLabel);
    addInnerComponent(newPasswordLabel, newPasswordInput);
    addInnerComponent(newPasswordLabel, newPasswordError);
    addInnerComponent(newPasswordLabel, currentPasswordIcon);
    addInnerComponent(passwordForm, buttonsContainer);
    fillObjectWithUniqueKeys(passwordForm, false, validStatus, true);
  }
  return passwordModal;
}
function showPassword(e) {
  e.preventDefault();
  const elem = e.target;
  const lable = elem.parentElement;
  const input = searchInput(lable);
  if (input.getAttribute('type') === 'password') {
    input.setAttribute('type', 'text');
    elem.setAttribute('src', '/assets/authpage/show.png');
    elem.setAttribute('title', 'Click to hide your password');
  } else {
    input.setAttribute('type', 'password');
    elem.setAttribute('src', '/assets/authpage/hide.png');
    elem.setAttribute('title', 'Click to make your password visible');
  }
}
function resultPasswordModal(text) {
  const app = document.querySelector('#app');
  const resultPasswordContainerParams = {
    tag: 'div',
    classNames: ['password-result__modal-container', 'modal_container'],
  };
  const passwordContainerParams = {
    tag: 'div',
    classNames: ['password-result__result-container'],
  };
  const passwordContainer = createElement$1(passwordContainerParams);
  const resultPasswordContainer = createElement$1(resultPasswordContainerParams);
  const resultPasswordTitleParams = {
    tag: 'h2',
    classNames: ['password-result__title'],
    textContent: text,
  };
  const resultPasswordTitle = createElement$1(resultPasswordTitleParams);
  const buttonCloseParams = {
    tag: 'button',
    classNames: ['password-result__close', 'profile-btn'],
    textContent: 'Close',
  };
  const buttonClose = createElement$1(buttonCloseParams);
  addInnerComponent(app, resultPasswordContainer);
  addInnerComponent(resultPasswordContainer, passwordContainer);
  addInnerComponent(passwordContainer, resultPasswordTitle);
  addInnerComponent(passwordContainer, buttonClose);
  buttonClose.addEventListener('click', () => {
    resultPasswordContainer.remove();
  });
}
async function updateCustomer(bodya) {
  const unparsedToken = localStorage.getItem('token');
  if (!unparsedToken) {
    throw new Error('No token found in local storage');
  }
  const token = JSON.parse(unparsedToken);
  const refreshToken = token.refreshToken;
  const refreshFlowClient = createApiBuilderFromCtpClient(
    createRefreshTokenClient(refreshToken),
  ).withProjectKey({ projectKey: 'valenki-store' });
  try {
    await refreshFlowClient.me().post({ body: bodya }).execute();
  } catch (error) {
    if (isCustomError(error)) {
      showToast(error.body.message);
    } else if (error instanceof Error) {
      showToast(error.message);
    } else {
      showToast('An unknown error occurred');
    }
  }
}
async function changePassword(dataCustomer, customerPassword) {
  const unparsedToken = localStorage.getItem('token');
  if (!unparsedToken) {
    throw new Error('No token found in local storage');
  }
  const token = JSON.parse(unparsedToken);
  const refreshToken = token.refreshToken;
  const refreshFlowClient = createApiBuilderFromCtpClient(
    createRefreshTokenClient(refreshToken),
  ).withProjectKey({ projectKey: 'valenki-store' });
  try {
    const body = {
      email: dataCustomer.email,
      password: customerPassword.newPassword,
    };
    await refreshFlowClient.me().password().post({ body: customerPassword }).execute();
    localStorage.removeItem('token');
    await loginStayUser(body);
    resultPasswordModal('Password is changed');
  } catch (error) {
    resultPasswordModal(
      'Error: The entered password does not match the current one',
    );
  }
}
const apiRoot = createApiBuilderFromCtpClient(ctpClient).withProjectKey({
  projectKey: 'valenki-store',
});
const anonymousApiRoot = createApiBuilderFromCtpClient(
  anonymousCtpClient,
).withProjectKey({
  projectKey: 'valenki-store',
});
const getProject = () => {
  return anonymousApiRoot.get().execute();
};
const loginUser = async (body) => {
  try {
    const passFlowClient = createApiBuilderFromCtpClient(
      createPasswordFlowClient({ email: body.email, password: body.password }),
    ).withProjectKey({
      projectKey: 'valenki-store',
    });
    const data = await passFlowClient.login().post({ body }).execute();
    localStorage.setItem('userId', data.body.customer.id);
    router.navigate('/');
    appEvents.emit('login', void 0);
    return data;
  } catch (error) {
    if (isCustomError(error)) {
      showToast(error.body.message);
    } else if (error instanceof Error) {
      showToast(error.message);
    } else {
      showToast('An unknown error occurred');
    }
    throw error;
  }
};
const loginStayUser = async (body) => {
  try {
    const passFlowClient = createApiBuilderFromCtpClient(
      createPasswordFlowClient({ email: body.email, password: body.password }),
    ).withProjectKey({
      projectKey: 'valenki-store',
    });
    const data = await passFlowClient.login().post({ body }).execute();
    return data;
  } catch (error) {
    if (isCustomError(error)) {
      showToast(error.body.message);
    } else if (error instanceof Error) {
      showToast(error.message);
    } else {
      showToast('An unknown error occurred');
    }
    throw error;
  }
};
const logoutUser = async () => {
  try {
    localStorage.removeItem('token');
    await anonymousApiRoot.get().execute();
    router.navigate('/login');
    appEvents.emit('logout', void 0);
  } catch (error) {
    if (isCustomError(error)) {
      showToast(error.body.message);
    } else if (error instanceof Error) {
      showToast(error.message);
    } else {
      showToast('An unknown error occurred');
    }
  }
};
async function isUserLogined() {
  if (localStorage.getItem('token')) {
    const unparsedToken = JSON.parse(localStorage.getItem('token'));
    const currentPath = window.location.pathname;
    const refreshToken = unparsedToken.refreshToken;
    const refreshFlowClient = createApiBuilderFromCtpClient(
      createRefreshTokenClient(refreshToken),
    ).withProjectKey({
      projectKey: 'valenki-store',
    });
    try {
      const userData = await refreshFlowClient.me().get().execute();
      if (currentPath === '/' || currentPath === '/login') {
        router.navigate('/');
      }
      appEvents.emit('login', void 0);
      return userData;
    } catch (error) {
      router.navigate('/login');
    }
  } else {
    await getProject();
  }
}
async function getUserData() {
  if (localStorage.getItem('token')) {
    const unparsedToken = JSON.parse(localStorage.getItem('token'));
    const refreshToken = unparsedToken.refreshToken;
    const refreshFlowClient = createApiBuilderFromCtpClient(
      createRefreshTokenClient(refreshToken),
    ).withProjectKey({
      projectKey: 'valenki-store',
    });
    try {
      const response = await refreshFlowClient.me().get().execute();
      if (!response.body) {
        throw new Error('No user data found');
      }
      const userData = response.body;
      return userData;
    } catch (error) {
      if (isCustomError(error)) {
        showToast(error.body.message);
      } else if (error instanceof Error) {
        showToast(error.message);
      } else {
        showToast('An unknown error occurred');
      }
      throw error;
    }
  } else {
    throw new Error('No token found');
  }
}
function checkLoginStatus() {
  return Boolean(localStorage.getItem('token'));
}
async function regUser(regData) {
  try {
    const addresses = [
      {
        key: 'Shipping-Address',
        city: regData.shippingAddress.city,
        country: regData.shippingAddress.country,
        postalCode: regData.shippingAddress.postaCode,
        streetName: regData.shippingAddress.streetName,
      },
      {
        key: 'Billing-Address',
        city: regData.billingAddress.city,
        country: regData.billingAddress.country,
        postalCode: regData.billingAddress.postaCode,
        streetName: regData.billingAddress.streetName,
      },
    ];
    const requestBody = {
      email: regData.mailValue,
      firstName: regData.name,
      lastName: regData.lastName,
      password: regData.password,
      dateOfBirth: regData.DOB,
      addresses,
      ...regData.shippingAddress.isDefault ? { defaultShippingAddress: 0 } : {},
      ...regData.billingAddress.isDefault ? { defaultBillingAddress: 1 } : {},
    };
    await apiRoot.customers().post({
      body: requestBody,
    }).execute();
    await loginUser({
      email: regData.mailValue,
      password: regData.password,
    });
  } catch (error) {
    if (isCustomError(error)) {
      showToast(error.body.message);
    } else if (error instanceof Error) {
      showToast(error.message);
    } else {
      showToast('An unknown error occurred');
    }
    return void 0;
  }
}
async function getDetailedProduct(ID2) {
  try {
    const response = await apiRoot.products().withId({ ID: ID2 }).get().execute();
    const categories = response.body.masterData.current.categories;
    const categoryIds = categories.map((category) => category.id);
    const categoryPromises = categoryIds.map(
      (categoryID) => apiRoot.categories().withId({ ID: categoryID }).get().execute(),
    );
    const categoryResponses = await Promise.all(categoryPromises);
    return { productResponse: response, categoryResponses };
  } catch (error) {
    if (isCustomError(error)) {
      showToast(error.body.message);
    } else if (error instanceof Error) {
      showToast(error.message);
    } else {
      showToast('An unknown error occurred');
    }
    return void 0;
  }
}
async function fetchProducts(sort) {
  try {
    let offset = 0;
    const limit = 500;
    let allProducts = [];
    let hasMore = true;
    const queryArgs = {
      limit,
      offset,
    };
    if (sort) {
      queryArgs.sort = [sort];
    }
    while (hasMore) {
      const response = await apiRoot.productProjections().search().get({
        queryArgs,
      }).execute();
      if (response.body.results.length === 0) {
        hasMore = false;
      } else {
        allProducts = allProducts.concat(response.body.results);
        offset += limit;
        if (response.body.results.length < limit) {
          hasMore = false;
        }
      }
    }
    return allProducts;
  } catch (error) {
    if (isCustomError(error)) {
      showToast(error.body.message);
    } else if (error instanceof Error) {
      showToast(error.message);
    } else {
      showToast('An unknown error occurred');
    }
    return [];
  }
}
async function fetchProductAttributes() {
  try {
    let offset = 0;
    const limit = 500;
    let allProducts = [];
    let hasMore = true;
    while (hasMore) {
      const response = await apiRoot.productProjections().search().get({
        queryArgs: {
          limit,
          offset,
        },
      }).execute();
      if (response.body.results.length === 0) {
        hasMore = false;
      } else {
        allProducts = allProducts.concat(response.body.results);
        offset += limit;
        if (response.body.results.length < limit) {
          hasMore = false;
        }
      }
    }
    if (allProducts.length === 0) {
      return null;
    }
    const sizes = /* @__PURE__ */ new Set();
    allProducts.forEach((product) => {
      var _a;
      (_a = product.masterVariant.attributes) == null ? void 0 : _a.forEach((attribute) => {
        if (attribute.name === 'size') {
          const sizeValue = Array.isArray(attribute.value) ? attribute.value[0] : attribute.value;
          sizes.add(sizeValue);
        }
      });
      product.variants.forEach((variant) => {
        var _a2;
        (_a2 = variant.attributes) == null ? void 0 : _a2.forEach((attribute) => {
          if (attribute.name === 'size') {
            const sizeValue = Array.isArray(attribute.value) ? attribute.value[0] : attribute.value;
            sizes.add(sizeValue);
          }
        });
      });
    });
    const uniqueSizes = Array.from(sizes).sort((a, b) => a - b);
    return uniqueSizes;
  } catch (error) {
    if (isCustomError(error)) {
      showToast(error.body.message);
    } else if (error instanceof Error) {
      showToast(error.message);
    } else {
      showToast('An unknown error occurred');
    }
    return null;
  }
}
async function fetchSizesForCategory(categoryId) {
  try {
    const response = await apiRoot.productProjections().search().get({
      queryArgs: {
        filter: `categories.id: subtree("${categoryId}")`,
        limit: 500,
      },
    }).execute();
    const products = response.body.results;
    const sizes = /* @__PURE__ */ new Set();
    products.forEach((product) => {
      var _a;
      (_a = product.masterVariant.attributes) == null ? void 0 : _a.forEach((attribute) => {
        if (attribute.name === 'size') {
          const sizeValue = Array.isArray(attribute.value) ? attribute.value[0] : attribute.value;
          sizes.add(sizeValue);
        }
      });
      product.variants.forEach((variant) => {
        var _a2;
        (_a2 = variant.attributes) == null ? void 0 : _a2.forEach((attribute) => {
          if (attribute.name === 'size') {
            const sizeValue = Array.isArray(attribute.value) ? attribute.value[0] : attribute.value;
            sizes.add(sizeValue);
          }
        });
      });
    });
    return Array.from(sizes).sort((a, b) => a - b);
  } catch (error) {
    if (isCustomError(error)) {
      showToast(error.body.message);
    } else if (error instanceof Error) {
      showToast(error.message);
    } else {
      showToast('An unknown error occurred');
    }
    return [];
  }
}
async function fetchCategories() {
  try {
    const response = await anonymousApiRoot.categories().get().execute();
    const categories = response.body.results;
    return categories;
  } catch (error) {
    if (isCustomError(error)) {
      showToast(error.body.message);
    } else if (error instanceof Error) {
      showToast(error.message);
    } else {
      showToast('An unknown error occurred');
    }
    return [];
  }
}
async function fetchFilteredProducts(filters, sort) {
  try {
    const queryArgs = {
      filter: filters,
    };
    if (sort) {
      queryArgs.sort = [sort];
    }
    const response = await apiRoot.productProjections().search().get({
      queryArgs,
    }).execute();
    return response.body.results;
  } catch (error) {
    if (isCustomError(error)) {
      showToast(error.body.message);
    } else if (error instanceof Error) {
      showToast(error.message);
    } else {
      showToast('An unknown error occurred');
    }
    return [];
  }
}
async function searchProducts(searchText) {
  try {
    const queryArgs = {
      'text.en-US': searchText,
      fuzzy: true,
    };
    const response = await apiRoot.productProjections().search().get({ queryArgs }).execute();
    return response.body;
  } catch (error) {
    console.error('Error during product search:', error);
    throw error;
  }
}
function createSearchComponent() {
  const searchWrapperParams = {
    tag: 'div',
    classNames: ['search__wrapper'],
  };
  const searchWrapper = createElement$1(searchWrapperParams);
  const searchInputParams = {
    tag: 'input',
    classNames: ['search__input'],
    attributes: { placeholder: 'Search' },
  };
  const searchInput2 = createElement$1(searchInputParams);
  const searchButtonParams = {
    tag: 'button',
    classNames: ['search__button'],
  };
  const searchButton = createElement$1(searchButtonParams);
  const searchIcon = createElement$1({
    tag: 'img',
    classNames: ['search__icon'],
    attributes: {
      src: '/assets/header/search.png',
      alt: 'Search',
    },
  });
  addInnerComponent(searchButton, searchIcon);
  const searchFormParams = {
    tag: 'form',
    classNames: ['search__form'],
  };
  const searchForm = createElement$1(searchFormParams);
  addInnerComponent(searchForm, searchInput2);
  addInnerComponent(searchForm, searchButton);
  addInnerComponent(searchWrapper, searchForm);
  searchForm.addEventListener('submit', async (event2) => {
    event2.preventDefault();
    const searchText = searchInput2.value.trim();
    if (searchText) {
      try {
        const searchResults = await searchProducts(searchText);
        const customEvent = new CustomEvent('searchResults', {
          detail: searchResults,
        });
        document.dispatchEvent(customEvent);
      } catch (error) {
        console.error('Search error:', error);
      }
    }
  });
  return searchWrapper;
}
function createHeader() {
  const headerParams = {
    tag: 'div',
    classNames: ['header'],
  };
  const header = createElement$1(headerParams);
  const logoLink = createElement$1({
    tag: 'a',
    attributes: { href: '/' },
    classNames: ['header__logo-link'],
  });
  const logo = createElement$1({
    tag: 'div',
    classNames: ['header__logo'],
    textContent: '・valenki store・',
  });
  addInnerComponent(logoLink, logo);
  const logoSearchContainer = createElement$1({
    tag: 'div',
    classNames: ['header__logo-search-container'],
  });
  addInnerComponent(logoSearchContainer, logoLink);
  const isCatalogPage = window.location.pathname === '/catalog';
  if (isCatalogPage) {
    const searchComponent = createSearchComponent();
    addInnerComponent(logoSearchContainer, searchComponent);
  }
  const navContainer = createElement$1({
    tag: 'div',
    classNames: ['header__nav-links'],
  });
  if (!isCatalogPage) {
    const homeLink = createElement$1({
      tag: 'a',
      attributes: { href: '/' },
      classNames: ['header__nav-link'],
      textContent: 'Home',
    });
    const aboutLink = createElement$1({
      tag: 'a',
      attributes: { href: '/catalog' },
      classNames: ['header__nav-link'],
      textContent: 'Catalog',
    });
    addInnerComponent(navContainer, homeLink);
    addInnerComponent(navContainer, aboutLink);
  }
  const rightContainer = createElement$1({
    tag: 'div',
    classNames: ['header__right-container'],
  });
  const iconsContainer = createElement$1({
    tag: 'div',
    classNames: ['header__icons'],
  });
  const basketIcon = createElement$1({
    tag: 'a',
    attributes: { href: '/basket' },
    classNames: ['header__icon', 'header__basket-icon'],
  });
  const basketImage = createElement$1({
    tag: 'img',
    attributes: {
      src: '/assets/header/basket.png',
      alt: 'Basket',
    },
  });
  const userIcon = createElement$1({
    tag: 'a',
    classNames: ['header__icon', 'header__user-icon'],
  });
  const userImage = createElement$1({
    tag: 'img',
    attributes: {
      src: '/assets/header/user-profile.png',
      alt: 'User',
    },
  });
  addInnerComponent(userIcon, userImage);
  userIcon.onclick = () => {
    const userId = localStorage.getItem('userId');
    if (userId) {
      navigateToProfile(userId);
    } else {
      router.navigate('/login');
    }
  };
  addInnerComponent(iconsContainer, basketIcon);
  addInnerComponent(iconsContainer, userIcon);
  addInnerComponent(basketIcon, basketImage);
  addInnerComponent(userIcon, userImage);
  addInnerComponent(iconsContainer, basketIcon);
  addInnerComponent(iconsContainer, userIcon);
  const authNavContainer = createElement$1({
    tag: 'div',
    classNames: ['header__auth-nav-container'],
  });
  const authContainer = createElement$1({
    tag: 'div',
    classNames: ['header__auth-buttons'],
  });
  const registerButton = createElement$1({
    tag: 'a',
    attributes: { href: '/register' },
    classNames: ['header__auth-button', 'register-button'],
    textContent: 'Register',
  });
  const authButton = createElement$1({
    tag: 'a',
    attributes: { href: '/login' },
    classNames: ['header__auth-button', 'login-button'],
    textContent: 'Log In',
  });
  addInnerComponent(authContainer, registerButton);
  addInnerComponent(authContainer, authButton);
  addInnerComponent(authNavContainer, authContainer);
  addInnerComponent(rightContainer, iconsContainer);
  addInnerComponent(rightContainer, authNavContainer);
  addInnerComponent(header, logoSearchContainer);
  if (!isCatalogPage) {
    addInnerComponent(header, navContainer);
  }
  addInnerComponent(header, rightContainer);
  const burgerMenu = createElement$1({
    tag: 'div',
    classNames: ['header__burger'],
  });
  const burgerLine1 = createElement$1({ tag: 'div', classNames: ['line1'] });
  const burgerLine2 = createElement$1({ tag: 'div', classNames: ['line2'] });
  const burgerLine3 = createElement$1({ tag: 'div', classNames: ['line3'] });
  addInnerComponent(burgerMenu, burgerLine1);
  addInnerComponent(burgerMenu, burgerLine2);
  addInnerComponent(burgerMenu, burgerLine3);
  addInnerComponent(header, burgerMenu);
  burgerMenu.onclick = () => {
    authNavContainer.classList.toggle('open');
    burgerMenu.classList.toggle('change');
  };
  const closeBurgerMenu = (event2) => {
    if (!header.contains(event2.target) && authNavContainer.classList.contains('open')) {
      authNavContainer.classList.remove('open');
      burgerMenu.classList.remove('change');
    }
  };
  document.addEventListener('click', closeBurgerMenu);
  const tabletScreenWidthInPx = 870;
  const moveNavLinks = () => {
    const isMobile = window.innerWidth <= tabletScreenWidthInPx;
    if (isMobile && !isCatalogPage) {
      addInnerComponent(authNavContainer, navContainer);
    } else if (!isCatalogPage) {
      if (authNavContainer.classList.contains('open')) {
        authNavContainer.classList.remove('open');
        burgerMenu.classList.remove('change');
      }
      header.insertBefore(navContainer, rightContainer);
    }
  };
  window.addEventListener('resize', moveNavLinks);
  document.addEventListener('DOMContentLoaded', moveNavLinks);
  window.addEventListener('load', moveNavLinks);
  moveNavLinks();
  async function handleLogout() {
    await logoutUser();
    appEvents.emit('logout', void 0);
  }
  async function updateAuthButton(isLoggedIn) {
    registerButton.style.display = isLoggedIn ? 'none' : 'block';
    authButton.textContent = isLoggedIn ? 'Log Out' : 'Log In';
    authButton.setAttribute('href', isLoggedIn ? '#' : '/login');
    authButton.onclick = isLoggedIn ? async () => {
      await handleLogout();
      appEvents.emit('logout', void 0);
    } : null;
  }
  document.addEventListener('DOMContentLoaded', initializeAuthButtons);
  function initializeAuthButtons() {
    const isLoggedIn = checkLoginStatus();
    updateAuthButton(isLoggedIn);
  }
  initializeAuthButtons();
  appEvents.on('login', () => updateAuthButton(true));
  appEvents.on('logout', () => updateAuthButton(false));
  return header;
}
function createHero() {
  const containerParams = {
    tag: 'div',
    classNames: ['hero-container'],
    textContent: '',
  };
  const heroContainer = createElement$1(containerParams);
  const imageParams = {
    tag: 'img',
    classNames: ['hero-image'],
    attributes: {
      src: '/assets/mainPage/hero-img.png',
      alt: 'Not Found',
    },
  };
  const heroImg = createElement$1(imageParams);
  addInnerComponent(heroContainer, heroImg);
  return heroContainer;
}
function createMainPage() {
  const pageContainerParams = {
    tag: 'div',
    classNames: ['main-page-wrapper'],
  };
  const container = createElement$1(pageContainerParams);
  const header = createHeader();
  addInnerComponent(container, header);
  const hero = createHero();
  addInnerComponent(container, hero);
  return container;
}
function createNotFoundPage() {
  const containerParams = {
    tag: 'div',
    classNames: ['not-found-container'],
    textContent: '',
  };
  const container = createElement$1(containerParams);
  const imageParams = {
    tag: 'img',
    classNames: ['not-found-image'],
    attributes: {
      src: '/assets/notFoundComponent/404-img.png',
      alt: 'Not Found',
    },
  };
  const image = createElement$1(imageParams);
  const contentContainer = createElement$1({
    tag: 'div',
    classNames: ['not-found-content'],
  });
  const headingParams = {
    tag: 'h1',
    classNames: ['not-found-title'],
    textContent: 'OOPS!',
  };
  const heading = createElement$1(headingParams);
  const descriptionParams = {
    tag: 'p',
    classNames: ['not-found-description'],
    textContent: 'Looks like Bigfoot has broken the link.',
  };
  const description = createElement$1(descriptionParams);
  const backHomeCallback = {
    eventType: 'click',
    callback: () => window.location.href = '/',
  };
  const buttonParams = {
    tag: 'button',
    classNames: ['back-home-button'],
    textContent: 'Back to homepage',
    callbacks: [backHomeCallback],
  };
  const backButton = createElement$1(buttonParams);
  addInnerComponent(contentContainer, heading);
  addInnerComponent(contentContainer, description);
  addInnerComponent(contentContainer, backButton);
  addInnerComponent(container, image);
  addInnerComponent(container, contentContainer);
  return container;
}
function notFoundPage() {
  return createNotFoundPage();
}
function createAuthForm() {
  const formContainerParams = {
    tag: 'form',
    classNames: ['auth_form'],
  };
  const submitButtonParams = {
    tag: 'button',
    textContent: 'Sign In',
    attributes: {
      type: 'submit',
      disabled: '',
    },
    classNames: ['submit_button'],
  };
  const authForm = createElement$1(formContainerParams);
  const authFormHeaderParams = {
    tag: 'h2',
    textContent: 'Sign in & choose your best felt boots!',
    classNames: ['auth_form_header'],
  };
  const authFormFooterParams = {
    tag: 'h3',
    textContent: "Don't have an account yet? ",
    classNames: ['auth_form_footer'],
  };
  const authFormFooterSpanParams = {
    tag: 'a',
    attributes: {
      href: '/register',
    },
    textContent: 'Register',
    classNames: ['auth_form_footer_link-to-registration'],
  };
  const authFormHeader = createElement$1(authFormHeaderParams);
  const authFormFooter = createElement$1(authFormFooterParams);
  const authFormFooterHref = createElement$1(authFormFooterSpanParams);
  addInnerComponent(authFormFooter, authFormFooterHref);
  const authFormEmailContainerParams = {
    tag: 'div',
    classNames: ['email_container'],
  };
  const authFormPasswordContainerParams = {
    tag: 'div',
    classNames: ['password_container'],
  };
  const emailErrorSpanParams = {
    tag: 'span',
    classNames: ['error'],
  };
  const emailIconParams = {
    tag: 'img',
    attributes: {
      src: '/assets/authpage/mail.png',
      alt: 'email icon',
    },
    classNames: ['email_icon'],
  };
  const passwordErrorSpanParams = {
    tag: 'span',
    classNames: ['error'],
  };
  const emailIcon = createElement$1(emailIconParams);
  const passwordIcon = commonFormCompontens.passwordIcon;
  const emailErrorSpan = createElement$1(emailErrorSpanParams);
  const passwordErrorSpan = createElement$1(passwordErrorSpanParams);
  const [emailLabel, emailInput] = createInput(
    'email',
    [['form-label'], ['form-input']],
    'email',
    'email',
  );
  const [passwordLabel, passwordInput] = createInput(
    'password',
    [['form-label'], ['form-input']],
    'password',
    'password',
  );
  const emailContainer = createElement$1(authFormEmailContainerParams);
  const passwordContainer = createElement$1(authFormPasswordContainerParams);
  const submitButton = createElement$1(submitButtonParams);
  addInnerComponent(emailContainer, emailLabel);
  addInnerComponent(emailContainer, emailInput);
  addInnerComponent(emailContainer, emailErrorSpan);
  addInnerComponent(emailContainer, emailIcon);
  addInnerComponent(passwordContainer, passwordLabel);
  addInnerComponent(passwordContainer, passwordInput);
  addInnerComponent(passwordContainer, passwordErrorSpan);
  addInnerComponent(passwordContainer, passwordIcon);
  addInnerComponent(authForm, authFormHeader);
  addInnerComponent(authForm, emailContainer);
  addInnerComponent(authForm, passwordContainer);
  addInnerComponent(authForm, submitButton);
  addInnerComponent(authForm, authFormFooter);
  fillObjectWithUniqueKeys(authForm, false, validStatus);
  return [authForm, emailInput, passwordInput, passwordIcon, submitButton];
}
function createAuthPage() {
  const authSectionContainerParams = {
    tag: 'section',
    classNames: ['auth_section'],
  };
  const authSectionContainer = createElement$1(authSectionContainerParams);
  const imageParams = {
    tag: 'img',
    classNames: ['auth_section-background_image'],
    attributes: {
      src: '/assets/authpage/witcher_felt_boots_auth_page_2.jpg',
      alt: 'Beautiful Felt Boots',
    },
  };
  const errorLoginParams = {
    tag: 'span',
    classNames: ['auth_error'],
  };
  const errorLogin = createElement$1(errorLoginParams);
  const header = createHeader();
  const authFormBgImage = createElement$1(imageParams);
  const authFormArray = createAuthForm();
  const authForm = authFormArray[0];
  const emailInput = authFormArray[1];
  const passwordInput = authFormArray[2];
  const passwordInputIcon = authFormArray[3];
  const submitButton = authFormArray[4];
  emailInput.addEventListener('input', validateInput);
  passwordInput.addEventListener('input', validateInput);
  passwordInputIcon.addEventListener('click', (event2) => {
    event2.preventDefault();
    if (passwordInput.getAttribute('type') === 'password') {
      passwordInput.setAttribute('type', 'text');
      passwordInputIcon.setAttribute('src', '/assets/authpage/show.png');
      passwordInputIcon.setAttribute('title', 'Click to hide your password');
    } else {
      passwordInput.setAttribute('type', 'password');
      passwordInputIcon.setAttribute('src', '/assets/authpage/hide.png');
      passwordInputIcon.setAttribute(
        'title',
        'Click to make your password visible',
      );
    }
  });
  authForm.addEventListener('submit', async (event2) => {
    event2.preventDefault();
    const formData = new FormData(authForm);
    const formDataObject = {
      email: '',
      password: '',
    };
    for (const [key, value] of formData.entries()) {
      if (key in formDataObject) {
        formDataObject[key] = value;
      }
    }
    const response = await loginUser(formDataObject);
    if (response.statusCode !== 200) {
      errorLogin.textContent = 'Wrong email and/or password!';
      authForm.insertBefore(errorLogin, submitButton);
    } else {
      if (errorLogin && errorLogin.parentNode === authForm) {
        authForm.removeChild(errorLogin);
      }
    }
  });
  authSectionContainer.prepend(header);
  addInnerComponent(authSectionContainer, authFormBgImage);
  addInnerComponent(authSectionContainer, authForm);
  return authSectionContainer;
}
function createRegistrationComponent() {
  const wrapper = createElement$1({
    tag: 'div',
    classNames: ['wrapper__registration', 'wrapper'],
  });
  const authSide = createElement$1({
    tag: 'div',
    classNames: ['registration__auth-side'],
  });
  const authSideTitle = createElement$1({
    tag: 'h2',
    classNames: ['auth-side__title'],
    textContent: 'Create an account',
  });
  const authSideForm$1 = authSideForm;
  const signIn = createElement$1({
    tag: 'div',
    classNames: ['auth-side__sign-in'],
  });
  const signInText = createElement$1({
    tag: 'div',
    classNames: ['sign-in__text'],
    textContent: 'Already have an account?',
  });
  const signInButton = createElement$1({
    tag: 'button',
    classNames: ['sign-in__button', 'button'],
    attributes: { type: 'submit' },
    textContent: 'Sign in',
  });
  signInButton.addEventListener('click', () => {
    router.navigate('/login');
  });
  addInnerComponent(wrapper, authSide);
  addInnerComponent(authSide, authSideTitle);
  addInnerComponent(authSide, authSideForm$1);
  addInnerComponent(authSide, signIn);
  addInnerComponent(signIn, signInText);
  addInnerComponent(signIn, signInButton);
  return wrapper;
}
function buildRegistrationPage() {
  const registrationPage = createElement$1({
    tag: 'div',
    classNames: ['registration__page'],
  });
  const regImg = createElement$1({
    tag: 'img',
    classNames: ['registration-img'],
    attributes: {
      alt: 'Registration Page Background Image',
      src: '/assets/registration/background.jpg',
    },
  });
  const header = createHeader();
  const registrationComponent = createRegistrationComponent();
  createForm();
  registrationPage.append(header);
  registrationPage.append(regImg);
  registrationPage.append(registrationComponent);
  return registrationPage;
}
function createProductCatalog(products) {
  const catalogContainer = createElement$1({
    tag: 'div',
    classNames: ['catalog-grid'],
  });
  products.forEach((product) => {
    var _a, _b, _c, _d;
    const productName = ((_a = product.name) == null ? void 0 : _a['en-US']) ?? 'No name';
    const productDescription = ((_b = product.description) == null ? void 0 : _b['en-US']) ?? 'No description';
    const productImage = ((_d = (_c = product.masterVariant.images) == null ? void 0 : _c[0]) == null ? void 0 : _d.url) ?? 'No image';
    let price = void 0;
    let discountedPrice = void 0;
    if (product.masterVariant.prices && product.masterVariant.prices[0]) {
      const priceObj = product.masterVariant.prices[0];
      price = `$${(priceObj.value.centAmount / 100).toFixed(2)}`;
      if (priceObj.discounted) {
        discountedPrice = `$${(priceObj.discounted.value.centAmount / 100).toFixed(2)}`;
      }
    }
    const productCard = createElement$1({
      tag: 'div',
      classNames: ['product-card'],
      callbacks: [
        {
          eventType: 'click',
          callback: () => navigateTo(`/product/${product.id}`),
        },
      ],
    });
    const imageElement = createElement$1({
      tag: 'img',
      classNames: ['product-image'],
      attributes: { src: productImage, alt: productName },
    });
    const nameElement = createElement$1({
      tag: 'h3',
      classNames: ['product-name'],
      textContent: productName,
    });
    const descriptionElement = createElement$1({
      tag: 'p',
      classNames: ['product-description'],
      textContent: productDescription,
    });
    const priceContainer = createElement$1({
      tag: 'div',
      classNames: ['product-price-container'],
    });
    if (discountedPrice) {
      const originalPriceElement = createElement$1({
        tag: 'p',
        classNames: ['product-original-price'],
        textContent: price,
      });
      const discountedPriceElement = createElement$1({
        tag: 'p',
        classNames: ['product-discounted-price'],
        textContent: discountedPrice,
      });
      addInnerComponent(priceContainer, originalPriceElement);
      addInnerComponent(priceContainer, discountedPriceElement);
    } else {
      const priceElement = createElement$1({
        tag: 'p',
        classNames: ['product-price'],
        textContent: price,
      });
      addInnerComponent(priceContainer, priceElement);
    }
    addInnerComponent(productCard, imageElement);
    addInnerComponent(productCard, nameElement);
    addInnerComponent(productCard, descriptionElement);
    addInnerComponent(productCard, priceContainer);
    addInnerComponent(catalogContainer, productCard);
  });
  return catalogContainer;
}
function createSortComponent(onSortChange) {
  const sortContainerParams = {
    tag: 'div',
    classNames: ['sort-container'],
  };
  const sortContainer = createElement$1(sortContainerParams);
  const sortLabelParams = {
    tag: 'div',
    classNames: ['sort-label'],
    textContent: 'Sort by ',
  };
  const sortLabel = createElement$1(sortLabelParams);
  const arrowParams = {
    tag: 'span',
    classNames: ['triangle'],
  };
  const arrow = createElement$1(arrowParams);
  const sortOptionsParams = {
    tag: 'div',
    classNames: ['sort-options'],
  };
  const sortOptions = createElement$1(sortOptionsParams);
  const sortOptionsData = [
    { value: 'price asc', text: 'Lowest price' },
    { value: 'price desc', text: 'Highest price' },
    { value: 'createdAt desc', text: 'Newest' },
  ];
  sortOptionsData.forEach((option) => {
    const labelParams = {
      tag: 'label',
    };
    const label = createElement$1(labelParams);
    const inputParams = {
      tag: 'input',
      attributes: { type: 'radio', name: 'sort', value: option.value },
    };
    const input = createElement$1(inputParams);
    input.addEventListener('change', () => {
      onSortChange(input.value);
      sortOptions.classList.remove('show');
      arrow.classList.remove('open');
    });
    const textNode = document.createTextNode(option.text);
    label.append(input);
    label.append(textNode);
    sortOptions.append(label);
  });
  sortLabel.addEventListener('click', () => {
    sortOptions.classList.toggle('show');
    arrow.classList.toggle('open');
  });
  addInnerComponent(sortLabel, arrow);
  addInnerComponent(sortContainer, sortLabel);
  addInnerComponent(sortContainer, sortOptions);
  return sortContainer;
}
let keyDownListener = null;
function createPagination({
  totalItems,
  itemsPerPage,
  currentPage,
  onPageChange,
}) {
  const paginationContainerParams = {
    tag: 'div',
    classNames: ['pagination'],
  };
  const paginationContainer = createElement$1(paginationContainerParams);
  const totalPages = Math.ceil(totalItems / itemsPerPage);
  const createPageButton = (pageNumber) => {
    const pageButton = createElement$1({
      tag: 'button',
      textContent: pageNumber.toString(),
      classNames: pageNumber === currentPage ? ['pagination-button', 'active'] : ['pagination-button'],
      callbacks: [
        {
          eventType: 'click',
          callback: () => {
            onPageChange(pageNumber);
          },
        },
      ],
    });
    return pageButton;
  };
  if (currentPage > 1) {
    const prevButton = createElement$1({
      tag: 'button',
      classNames: ['pagination-arrow', 'prev'],
      attributes: { type: 'button' },
      callbacks: [
        {
          eventType: 'click',
          callback: () => {
            onPageChange(currentPage - 1);
          },
        },
      ],
    });
    const prevImg = createElement$1({
      tag: 'img',
      attributes: {
        src: '/assets/catalog/back.png',
        alt: 'Previous',
      },
    });
    addInnerComponent(prevButton, prevImg);
    addInnerComponent(paginationContainer, prevButton);
  }
  for (let i = 1; i <= totalPages; i++) {
    const pageButton = createPageButton(i);
    addInnerComponent(paginationContainer, pageButton);
  }
  if (currentPage < totalPages) {
    const nextButton = createElement$1({
      tag: 'button',
      classNames: ['pagination-arrow', 'next'],
      attributes: { type: 'button' },
      callbacks: [
        {
          eventType: 'click',
          callback: () => {
            onPageChange(currentPage + 1);
          },
        },
      ],
    });
    const nextImg = createElement$1({
      tag: 'img',
      attributes: {
        src: '/assets/catalog/forward.png',
        alt: 'Next',
      },
    });
    addInnerComponent(nextButton, nextImg);
    addInnerComponent(paginationContainer, nextButton);
  }
  const handleKeyDown = (event2) => {
    if (event2.key === 'ArrowLeft' && currentPage > 1) {
      onPageChange(currentPage - 1);
    } else if (event2.key === 'ArrowRight' && currentPage < totalPages) {
      onPageChange(currentPage + 1);
    }
  };
  if (keyDownListener) {
    document.removeEventListener('keydown', keyDownListener);
  }
  keyDownListener = handleKeyDown;
  document.addEventListener('keydown', keyDownListener);
  return paginationContainer;
}
const categoriesMap = {};
async function fetchAndMapCategories() {
  const categories = await fetchCategories();
  categories.forEach((category) => {
    var _a;
    categoriesMap[category.id] = { name: category.name['en-US'], parent: (_a = category.parent) == null ? void 0 : _a.id };
  });
}
function getFiltersFromURL() {
  const params = new URLSearchParams(window.location.search);
  const filters = {
    audience: new Set(params.getAll('audience')),
    category: Object.keys(categoriesMap).find((id) => categoriesMap[id].name === params.get('category')) || '',
    size: new Set(params.getAll('size')),
  };
  return filters;
}
function updateURLWithFilters(filters) {
  var _a;
  const url = new URL(window.location.href);
  url.searchParams.forEach((_, key) => {
    url.searchParams.delete(key);
  });
  if (filters.category) {
    url.searchParams.append('category', ((_a = categoriesMap[filters.category]) == null ? void 0 : _a.name) || '');
  }
  if (filters.audience.size > 0) {
    url.searchParams.set('audience', Array.from(filters.audience).join(','));
  }
  if (filters.size.size > 0) {
    url.searchParams.set('size', Array.from(filters.size).join(','));
  }
  history.pushState({}, '', url.toString());
}
function buildCategoryPath(categoryId) {
  const path = [];
  let currentCategory = categoriesMap[categoryId];
  while (currentCategory) {
    path.unshift({ id: categoryId, name: currentCategory.name });
    if (currentCategory.parent) {
      categoryId = currentCategory.parent;
      currentCategory = categoriesMap[categoryId];
    } else {
      break;
    }
  }
  return path;
}
async function createFilterComponent() {
  const filterContainerParams = {
    tag: 'div',
    classNames: ['filter-container'],
  };
  const filterContainer = createElement$1(filterContainerParams);
  const sizesResponse = await fetchProductAttributes();
  const categoriesResponse = await fetchCategories();
  if (categoriesResponse) {
    const categoryOrder = ['men', 'women', 'unisex', 'kids'];
    const sortedCategories = categoriesResponse.sort((a, b) => {
      const aIndex = categoryOrder.indexOf(a.slug['en-US']);
      const bIndex = categoryOrder.indexOf(b.slug['en-US']);
      return aIndex - bIndex;
    });
    sortedCategories.forEach((category) => {
      if (!category.parent) {
        const filterGroup = createCategoryFilterGroup(
          category,
          categoriesResponse,
        );
        addInnerComponent(filterContainer, filterGroup);
      }
    });
  }
  if (sizesResponse) {
    const filterGroup = createFilterGroup('size', sizesResponse);
    filterGroup.classList.add('size-filter-group');
    addInnerComponent(filterContainer, filterGroup);
  }
  const clearButtonParams = {
    tag: 'button',
    classNames: ['clear-filters-button'],
    textContent: 'Clear all',
  };
  const clearButton = createElement$1(clearButtonParams);
  clearButton.addEventListener('click', clearAllFilters);
  addInnerComponent(filterContainer, clearButton);
  return filterContainer;
}
async function updateSizeFilterForCategory(categoryId) {
  const sizesResponse = await fetchSizesForCategory(categoryId);
  const sizeFilterGroup = document.querySelector('.size-filter-group');
  if (sizeFilterGroup) {
    sizeFilterGroup.innerHTML = '';
    const newFilterGroup = createFilterGroup('size', sizesResponse);
    sizeFilterGroup.append(newFilterGroup);
  }
}
function createCategoryFilterGroup(category, allCategories) {
  const filterGroupParams = {
    tag: 'div',
    classNames: ['filter-group'],
  };
  const filterGroup = createElement$1(filterGroupParams);
  const filterLabelWrapperParams = {
    tag: 'div',
    classNames: ['filter-label-wrapper'],
  };
  const filterLabelWrapper = createElement$1(filterLabelWrapperParams);
  const filterLabelParams = {
    tag: 'div',
    classNames: ['filter-label'],
    textContent: category.name['en-US'].charAt(0).toUpperCase() + category.name['en-US'].slice(1),
  };
  const filterLabel = createElement$1(filterLabelParams);
  const triangleParams = {
    tag: 'div',
    classNames: ['triangle'],
  };
  const triangle = createElement$1(triangleParams);
  const radioContainerParams = {
    tag: 'div',
    classNames: ['radio-container', 'hidden', `${category.id}-radio-container`],
  };
  const radioContainer = createElement$1(radioContainerParams);
  const subCategories = allCategories.filter(
    (cat) => cat.parent && cat.parent.id === category.id,
  );
  subCategories.forEach((subCategory) => {
    const radioWrapper = createElement$1({
      tag: 'div',
      classNames: ['radio-wrapper'],
    });
    const radio = createElement$1({
      tag: 'input',
      attributes: { type: 'radio', name: 'category', value: subCategory.id },
      classNames: ['category-filter'],
    });
    radio.addEventListener('change', () => {
      const event2 = new CustomEvent('filtersChanged', {
        detail: {
          name: 'category',
          value: radio.value,
          checked: radio.checked,
        },
      });
      filterGroup.dispatchEvent(event2);
    });
    const radioLabel = createElement$1({
      tag: 'label',
      textContent: subCategory.name['en-US'],
    });
    radioLabel.addEventListener('click', () => {
      radio.checked = true;
      const event2 = new Event('change', { bubbles: true });
      radio.dispatchEvent(event2);
    });
    addInnerComponent(radioWrapper, radio);
    addInnerComponent(radioWrapper, radioLabel);
    addInnerComponent(radioContainer, radioWrapper);
  });
  const toggleMenu = () => {
    radioContainer.classList.toggle('hidden');
    triangle.classList.toggle('open');
  };
  filterLabel.addEventListener('click', toggleMenu);
  triangle.addEventListener('click', toggleMenu);
  addInnerComponent(filterLabelWrapper, filterLabel);
  addInnerComponent(filterLabelWrapper, triangle);
  addInnerComponent(filterGroup, filterLabelWrapper);
  addInnerComponent(filterGroup, radioContainer);
  return filterGroup;
}
function createFilterGroup(name, values) {
  const filterGroupParams = {
    tag: 'div',
    classNames: ['filter-group'],
  };
  const filterGroup = createElement$1(filterGroupParams);
  const filterLabelWrapperParams = {
    tag: 'div',
    classNames: ['filter-label-wrapper'],
  };
  const filterLabelWrapper = createElement$1(filterLabelWrapperParams);
  const filterLabelParams = {
    tag: 'div',
    classNames: ['filter-label'],
    textContent: name.charAt(0).toUpperCase() + name.slice(1),
  };
  const filterLabel = createElement$1(filterLabelParams);
  const triangleParams = {
    tag: 'div',
    classNames: ['triangle'],
  };
  const triangle = createElement$1(triangleParams);
  const checkboxContainerParams = {
    tag: 'div',
    classNames: ['checkbox-container', 'hidden', `${name}-checkbox-container`],
  };
  const checkboxContainer = createElement$1(checkboxContainerParams);
  values.forEach((value) => {
    const checkboxWrapper = createElement$1({
      tag: 'div',
      classNames: ['checkbox-wrapper'],
    });
    const checkbox = createElement$1({
      tag: 'input',
      attributes: { type: 'checkbox', value: value.toString() },
      classNames: [`${name}-filter`],
    });
    checkbox.addEventListener('change', () => {
      const event2 = new CustomEvent('filtersChanged', {
        detail: { name, value: checkbox.value, checked: checkbox.checked },
      });
      filterGroup.dispatchEvent(event2);
    });
    const checkboxLabel = createElement$1({
      tag: 'label',
      textContent: value.toString(),
    });
    checkboxLabel.addEventListener('click', () => {
      checkbox.checked = !checkbox.checked;
      const event2 = new Event('change', { bubbles: true });
      checkbox.dispatchEvent(event2);
    });
    addInnerComponent(checkboxWrapper, checkbox);
    addInnerComponent(checkboxWrapper, checkboxLabel);
    addInnerComponent(checkboxContainer, checkboxWrapper);
  });
  const toggleMenu = () => {
    checkboxContainer.classList.toggle('hidden');
    triangle.classList.toggle('open');
  };
  filterLabel.addEventListener('click', toggleMenu);
  triangle.addEventListener('click', toggleMenu);
  addInnerComponent(filterLabelWrapper, filterLabel);
  addInnerComponent(filterLabelWrapper, triangle);
  addInnerComponent(filterGroup, filterLabelWrapper);
  addInnerComponent(filterGroup, checkboxContainer);
  return filterGroup;
}
function clearAllFilters() {
  const filters = {
    audience: /* @__PURE__ */ new Set(),
    category: '',
    size: /* @__PURE__ */ new Set(),
  };
  updateURLWithFilters(filters);
  document.querySelectorAll('.filter-group input').forEach((input) => {
    input.checked = false;
  });
}
function createLoadingOverlay() {
  const overlay = createElement$1({
    tag: 'div',
    classNames: ['loading-overlay'],
  });
  const spinner = createElement$1({
    tag: 'div',
    classNames: ['loading-spinner'],
  });
  overlay.append(spinner);
  return overlay;
}
function generateBreadcrumbLinks(breadcrumbs) {
  const breadcrumbContainerParams = {
    tag: 'div',
    classNames: ['breadcrumb-container'],
  };
  const breadcrumbContainer = createElement$1(breadcrumbContainerParams);
  breadcrumbs.forEach((breadcrumb, index) => {
    const breadcrumbItemParams = {
      tag: 'a',
      classNames: ['breadcrumb-item'],
      textContent: breadcrumb.name,
      attributes: { href: breadcrumb.url },
    };
    const breadcrumbItem = createElement$1(breadcrumbItemParams);
    breadcrumbItem.addEventListener('click', (event2) => {
      event2.preventDefault();
      navigateTo(breadcrumb.url);
    });
    addInnerComponent(breadcrumbContainer, breadcrumbItem);
    if (index < breadcrumbs.length - 1) {
      const separatorParams = {
        tag: 'span',
        textContent: '>',
      };
      const separator = createElement$1(separatorParams);
      addInnerComponent(breadcrumbContainer, separator);
    }
  });
  return breadcrumbContainer;
}
async function buildBreadcrumbsFromUrl() {
  const url = new URL(window.location.href);
  const categoryName = url.searchParams.get('category');
  const breadcrumbs = [
    { name: 'home', url: '/' },
    { name: 'catalog', url: '/catalog' },
  ];
  if (!categoryName) {
    return breadcrumbs;
  }
  const categoryId = Object.keys(categoriesMap).find(
    (id) => categoriesMap[id].name === categoryName,
  );
  if (!categoryId) {
    return breadcrumbs;
  }
  const categoryPath = buildCategoryPath(categoryId);
  categoryPath.forEach((category) => {
    breadcrumbs.push({
      name: category.name,
      url: `/catalog?category=${category.name}`,
    });
  });
  return breadcrumbs;
}
async function createCatalogPage() {
  await fetchAndMapCategories();
  const pageContainerParams = {
    tag: 'div',
    classNames: ['catalog-page-container'],
  };
  const pageContainer = createElement$1(pageContainerParams);
  const breadcrumbContainerParams = {
    tag: 'div',
    classNames: ['breadcrumb-container'],
  };
  const breadcrumbContainer = createElement$1(breadcrumbContainerParams);
  const filterWrapperParams = {
    tag: 'div',
    classNames: ['filter-wrapper'],
  };
  const filterIconContainerParams = {
    tag: 'div',
    classNames: ['filter-icon-container'],
  };
  const filterWrapper = createElement$1(filterWrapperParams);
  const filterIconContainer = createElement$1(filterIconContainerParams);
  const filterIconParams = {
    tag: 'img',
    classNames: ['filter-icon'],
    attributes: {
      src: '../assets/catalog/filtericon.png',
      alt: 'Filters Icon',
    },
  };
  const filterIcon = createElement$1(filterIconParams);
  addInnerComponent(filterIconContainer, filterIcon);
  const catalogContainerWrapperParams = {
    tag: 'div',
    classNames: ['catalog-container-wrapper'],
  };
  const catalogContainerWrapper = createElement$1(catalogContainerWrapperParams);
  const catalogContainerParams = {
    tag: 'section',
    classNames: ['catalog-container'],
  };
  const catalogContainer = createElement$1(catalogContainerParams);
  const paginationContainerParams = {
    tag: 'div',
    classNames: ['pagination-container'],
  };
  const paginationContainer = createElement$1(paginationContainerParams);
  const header = createHeader();
  const filterComponent = await createFilterComponent();
  const loadingOverlay = createLoadingOverlay();
  let currentPage = 1;
  const itemsPerPage = 8;
  let currentSort = 'price asc';
  let filters = getFiltersFromURL();
  const updateBreadcrumbs = async () => {
    const breadcrumbs = await buildBreadcrumbsFromUrl();
    const breadcrumbLinks = generateBreadcrumbLinks(breadcrumbs);
    clear(breadcrumbContainer);
    addInnerComponent(breadcrumbContainer, breadcrumbLinks);
    breadcrumbContainer.querySelectorAll('a').forEach((anchor) => {
      anchor.addEventListener('click', async (event2) => {
        event2.preventDefault();
        const target = event2.currentTarget;
        const url = new URL(target.href);
        const params = new URLSearchParams(url.search);
        filters = {
          ...filters,
          category: params.get('category') || '',
        };
        if (filters.category) {
          const categoryId = Object.keys(categoriesMap).find(
            (id) => categoriesMap[id].name === filters.category,
          );
          if (categoryId) {
            filters.category = categoryId;
          }
        }
        updateURLWithFilters(filters);
        history.replaceState({}, '', url.toString());
        await updateBreadcrumbs();
        await renderProducts(1, itemsPerPage, currentSort);
      });
    });
  };
  const updateFilters = async (filterName, value, checked) => {
    if (filterName === 'category') {
      filters.category = checked ? value : '';
      await updateSizeFilterForCategory(filters.category);
    } else {
      if (checked) {
        filters[filterName].add(value);
      } else {
        filters[filterName].delete(value);
      }
    }
    updateURLWithFilters(filters);
    await updateBreadcrumbs();
  };
  const showLoadingOverlay = () => {
    loadingOverlay.style.display = 'flex';
    paginationContainer.classList.remove('visible');
  };
  const hideLoadingOverlay = () => {
    loadingOverlay.style.display = 'none';
    paginationContainer.classList.add('visible');
  };
  const renderProducts = async (page, itemsPerPageCount, sort) => {
    showLoadingOverlay();
    clear(catalogContainer);
    const selectedFilters = [];
    const buildFilterString = (key) => {
      if (key === 'category') {
        return filters.category ? `categories.id: subtree("${filters.category}")` : '';
      } else if (filters[key].size > 0) {
        const values = Array.from(filters[key]).map((value) => `${value}`).join(',');
        return `variants.attributes.${key}:${values}`;
      }
      return '';
    };
    const emptyRequestParams = {
      tag: 'div',
      textContent: 'Sorry, there are no results for your request. Please try another option 📭 ',
      classNames: ['empty-request'],
    };
    const emptyRequest = createElement$1(emptyRequestParams);
    const audienceFilter = buildFilterString('audience');
    const categoryFilter = buildFilterString('category');
    const sizeFilter = buildFilterString('size');
    if (audienceFilter)
      selectedFilters.push(audienceFilter);
    if (categoryFilter)
      selectedFilters.push(categoryFilter);
    if (sizeFilter)
      selectedFilters.push(sizeFilter);
    let products = [];
    if (selectedFilters.length > 0) {
      products = await fetchFilteredProducts(selectedFilters, sort);
      if (products.length <= 0) {
        clear(catalogContainer);
        addInnerComponent(catalogContainer, emptyRequest);
        clear(paginationContainer);
      }
    } else {
      products = await fetchProducts(sort);
    }
    if (products.length > 0) {
      const start = (page - 1) * itemsPerPageCount;
      const end = start + itemsPerPageCount;
      const paginatedProducts = products.slice(start, end);
      const productCatalog = createProductCatalog(paginatedProducts);
      addInnerComponent(catalogContainer, productCatalog);
      const pagination = createPagination({
        totalItems: products.length,
        itemsPerPage: itemsPerPageCount,
        currentPage: page,
        onPageChange: (newPage) => {
          currentPage = newPage;
          renderProducts(currentPage, itemsPerPageCount, currentSort);
        },
      });
      clear(paginationContainer);
      addInnerComponent(paginationContainer, pagination);
    } else {
      clear(paginationContainer);
      addInnerComponent(catalogContainer, emptyRequest);
    }
    hideLoadingOverlay();
  };
  filterComponent.addEventListener('change', async (event2) => {
    const target = event2.target;
    const filterName = target.classList[0].split('-')[0];
    await updateFilters(filterName, target.value, target.checked);
    clear(catalogContainer);
    await renderProducts(1, itemsPerPage, currentSort);
  });
  const sortComponent = createSortComponent(async (sort) => {
    currentSort = sort;
    await renderProducts(1, itemsPerPage, currentSort);
  });
  const initialBreadcrumbs = await buildBreadcrumbsFromUrl();
  const initialBreadcrumbLinks = generateBreadcrumbLinks(initialBreadcrumbs);
  addInnerComponent(breadcrumbContainer, initialBreadcrumbLinks);
  breadcrumbContainer.querySelectorAll('a').forEach((anchor) => {
    anchor.addEventListener('click', async (event2) => {
      event2.preventDefault();
      const target = event2.currentTarget;
      const url = new URL(target.href);
      const params = new URLSearchParams(url.search);
      filters = {
        ...filters,
        category: params.get('category') || '',
      };
      if (filters.category) {
        const categoryId = Object.keys(categoriesMap).find(
          (id) => categoriesMap[id].name === filters.category,
        );
        if (categoryId) {
          filters.category = categoryId;
        }
      }
      updateURLWithFilters(filters);
      history.replaceState({}, '', url.toString());
      await updateBreadcrumbs();
      await renderProducts(1, itemsPerPage, currentSort);
    });
  });
  pageContainer.prepend(header);
  addInnerComponent(pageContainer, breadcrumbContainer);
  addInnerComponent(pageContainer, filterWrapper);
  addInnerComponent(filterWrapper, filterIconContainer);
  addInnerComponent(filterWrapper, filterComponent);
  addInnerComponent(pageContainer, catalogContainerWrapper);
  addInnerComponent(catalogContainerWrapper, sortComponent);
  addInnerComponent(catalogContainerWrapper, catalogContainer);
  addInnerComponent(catalogContainerWrapper, paginationContainer);
  pageContainer.append(loadingOverlay);
  const filterContainer = filterWrapper.querySelector('.filter-container');
  filterIconContainer.addEventListener('click', (e) => {
    e.preventDefault();
    const catalogPage = document.querySelector('.catalog-page-container');
    filterContainer == null ? void 0 : filterContainer.classList.toggle('open');
    catalogPage == null ? void 0 : catalogPage.classList.toggle('hidden');
  });
  document.addEventListener('searchResults', (event2) => {
    const customEvent = event2;
    const searchResults = customEvent.detail;
    displaySearchResults(searchResults);
  });
  const displaySearchResults = (searchResults) => {
    const products = searchResults.results;
    clear(catalogContainer);
    if (products.length > 0) {
      const productCatalog = createProductCatalog(products);
      addInnerComponent(catalogContainer, productCatalog);
      const pagination = createPagination({
        totalItems: products.length,
        itemsPerPage,
        currentPage,
        onPageChange: (newPage) => {
          currentPage = newPage;
          renderProducts(currentPage, itemsPerPage, currentSort);
        },
      });
      clear(paginationContainer);
      addInnerComponent(paginationContainer, pagination);
    } else {
      clear(paginationContainer);
      const noResultsMessage = createElement$1({
        tag: 'div',
        classNames: ['no-results-message'],
        textContent: 'No products found.',
      });
      addInnerComponent(catalogContainer, noResultsMessage);
    }
  };
  const setupFilterContainer = () => {
    if (window.innerWidth <= 800) {
      filterContainer == null ? void 0 : filterContainer.addEventListener('click', handleFilterClick);
    } else {
      filterContainer == null ? void 0 : filterContainer.removeEventListener('click', handleFilterClick);
    }
  };
  const handleFilterClick = (event2) => {
    const catalogPage = document.querySelector('.catalog-page-container');
    const target = event2.target;
    if (target.classList.contains('filter-label')) {
      return;
    }
    if (target.tagName === 'LABEL') {
      if (target.closest('.checkbox-wrapper'))
        return;
      filterContainer == null ? void 0 : filterContainer.classList.remove('open');
    }
    const parent = target.closest('.filter-group');
    const triangle = parent == null ? void 0 : parent.querySelector('.triangle');
    const radioContainer = (parent == null ? void 0 : parent.querySelector('.radio-container')) || (parent == null ? void 0 : parent.querySelector('.checkbox-container'));
    triangle == null ? void 0 : triangle.classList.toggle('open');
    radioContainer == null ? void 0 : radioContainer.classList.toggle('hidden');
    if (catalogPage == null ? void 0 : catalogPage.classList.contains('hidden')) {
      catalogPage.classList.remove('hidden');
    }
  };
  setupFilterContainer();
  window.addEventListener('resize', setupFilterContainer);
  await renderProducts(currentPage, itemsPerPage, currentSort);
  window.addEventListener('popstate', async () => {
    await updateBreadcrumbs();
    await renderProducts(currentPage, itemsPerPage, currentSort);
  });
  return pageContainer;
}
function isObject$1(obj) {
  return obj !== null && typeof obj === 'object' && 'constructor' in obj && obj.constructor === Object;
}
function extend$1(target, src) {
  if (target === void 0) {
    target = {};
  }
  if (src === void 0) {
    src = {};
  }
  Object.keys(src).forEach((key) => {
    if (typeof target[key] === 'undefined')
      target[key] = src[key];
    else if (isObject$1(src[key]) && isObject$1(target[key]) && Object.keys(src[key]).length > 0) {
      extend$1(target[key], src[key]);
    }
  });
}
const ssrDocument = {
  body: {},
  addEventListener() {
  },
  removeEventListener() {
  },
  activeElement: {
    blur() {
    },
    nodeName: '',
  },
  querySelector() {
    return null;
  },
  querySelectorAll() {
    return [];
  },
  getElementById() {
    return null;
  },
  createEvent() {
    return {
      initEvent() {
      },
    };
  },
  createElement() {
    return {
      children: [],
      childNodes: [],
      style: {},
      setAttribute() {
      },
      getElementsByTagName() {
        return [];
      },
    };
  },
  createElementNS() {
    return {};
  },
  importNode() {
    return null;
  },
  location: {
    hash: '',
    host: '',
    hostname: '',
    href: '',
    origin: '',
    pathname: '',
    protocol: '',
    search: '',
  },
};
function getDocument() {
  const doc = typeof document !== 'undefined' ? document : {};
  extend$1(doc, ssrDocument);
  return doc;
}
const ssrWindow = {
  document: ssrDocument,
  navigator: {
    userAgent: '',
  },
  location: {
    hash: '',
    host: '',
    hostname: '',
    href: '',
    origin: '',
    pathname: '',
    protocol: '',
    search: '',
  },
  history: {
    replaceState() {
    },
    pushState() {
    },
    go() {
    },
    back() {
    },
  },
  CustomEvent: function CustomEvent2() {
    return this;
  },
  addEventListener() {
  },
  removeEventListener() {
  },
  getComputedStyle() {
    return {
      getPropertyValue() {
        return '';
      },
    };
  },
  Image() {
  },
  Date() {
  },
  screen: {},
  setTimeout() {
  },
  clearTimeout() {
  },
  matchMedia() {
    return {};
  },
  requestAnimationFrame(callback) {
    if (typeof setTimeout === 'undefined') {
      callback();
      return null;
    }
    return setTimeout(callback, 0);
  },
  cancelAnimationFrame(id) {
    if (typeof setTimeout === 'undefined') {
      return;
    }
    clearTimeout(id);
  },
};
function getWindow() {
  const win = typeof window !== 'undefined' ? window : {};
  extend$1(win, ssrWindow);
  return win;
}
function classesToTokens(classes2) {
  if (classes2 === void 0) {
    classes2 = '';
  }
  return classes2.trim().split(' ').filter((c) => !!c.trim());
}
function deleteProps(obj) {
  const object = obj;
  Object.keys(object).forEach((key) => {
    try {
      object[key] = null;
    } catch (e) {
    }
    try {
      delete object[key];
    } catch (e) {
    }
  });
}
function nextTick(callback, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return setTimeout(callback, delay);
}
function now() {
  return Date.now();
}
function getComputedStyle$1(el) {
  const window2 = getWindow();
  let style;
  if (window2.getComputedStyle) {
    style = window2.getComputedStyle(el, null);
  }
  if (!style && el.currentStyle) {
    style = el.currentStyle;
  }
  if (!style) {
    style = el.style;
  }
  return style;
}
function getTranslate(el, axis) {
  if (axis === void 0) {
    axis = 'x';
  }
  const window2 = getWindow();
  let matrix;
  let curTransform;
  let transformMatrix;
  const curStyle = getComputedStyle$1(el);
  if (window2.WebKitCSSMatrix) {
    curTransform = curStyle.transform || curStyle.webkitTransform;
    if (curTransform.split(',').length > 6) {
      curTransform = curTransform.split(', ').map((a) => a.replace(',', '.')).join(', ');
    }
    transformMatrix = new window2.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
  } else {
    transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
    matrix = transformMatrix.toString().split(',');
  }
  if (axis === 'x') {
    if (window2.WebKitCSSMatrix)
      curTransform = transformMatrix.m41;
    else if (matrix.length === 16)
      curTransform = parseFloat(matrix[12]);
    else
      curTransform = parseFloat(matrix[4]);
  }
  if (axis === 'y') {
    if (window2.WebKitCSSMatrix)
      curTransform = transformMatrix.m42;
    else if (matrix.length === 16)
      curTransform = parseFloat(matrix[13]);
    else
      curTransform = parseFloat(matrix[5]);
  }
  return curTransform || 0;
}
function isObject(o) {
  return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';
}
function isNode(node) {
  if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {
    return node instanceof HTMLElement;
  }
  return node && (node.nodeType === 1 || node.nodeType === 11);
}
function extend() {
  const to = Object(arguments.length <= 0 ? void 0 : arguments[0]);
  const noExtend = ['__proto__', 'constructor', 'prototype'];
  for (let i = 1; i < arguments.length; i += 1) {
    const nextSource = i < 0 || arguments.length <= i ? void 0 : arguments[i];
    if (nextSource !== void 0 && nextSource !== null && !isNode(nextSource)) {
      const keysArray = Object.keys(Object(nextSource)).filter((key) => noExtend.indexOf(key) < 0);
      for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
        const nextKey = keysArray[nextIndex];
        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
        if (desc !== void 0 && desc.enumerable) {
          if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
            if (nextSource[nextKey].__swiper__) {
              to[nextKey] = nextSource[nextKey];
            } else {
              extend(to[nextKey], nextSource[nextKey]);
            }
          } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
            to[nextKey] = {};
            if (nextSource[nextKey].__swiper__) {
              to[nextKey] = nextSource[nextKey];
            } else {
              extend(to[nextKey], nextSource[nextKey]);
            }
          } else {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
  }
  return to;
}
function setCSSProperty(el, varName, varValue) {
  el.style.setProperty(varName, varValue);
}
function animateCSSModeScroll(_ref) {
  let {
    swiper,
    targetPosition,
    side,
  } = _ref;
  const window2 = getWindow();
  const startPosition = -swiper.translate;
  let startTime = null;
  let time;
  const duration = swiper.params.speed;
  swiper.wrapperEl.style.scrollSnapType = 'none';
  window2.cancelAnimationFrame(swiper.cssModeFrameID);
  const dir = targetPosition > startPosition ? 'next' : 'prev';
  const isOutOfBound = (current, target) => {
    return dir === 'next' && current >= target || dir === 'prev' && current <= target;
  };
  const animate = () => {
    time = (/* @__PURE__ */ new Date()).getTime();
    if (startTime === null) {
      startTime = time;
    }
    const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
    const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
    let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
    if (isOutOfBound(currentPosition, targetPosition)) {
      currentPosition = targetPosition;
    }
    swiper.wrapperEl.scrollTo({
      [side]: currentPosition,
    });
    if (isOutOfBound(currentPosition, targetPosition)) {
      swiper.wrapperEl.style.overflow = 'hidden';
      swiper.wrapperEl.style.scrollSnapType = '';
      setTimeout(() => {
        swiper.wrapperEl.style.overflow = '';
        swiper.wrapperEl.scrollTo({
          [side]: currentPosition,
        });
      });
      window2.cancelAnimationFrame(swiper.cssModeFrameID);
      return;
    }
    swiper.cssModeFrameID = window2.requestAnimationFrame(animate);
  };
  animate();
}
function elementChildren(element, selector) {
  if (selector === void 0) {
    selector = '';
  }
  return [...element.children].filter((el) => el.matches(selector));
}
function showWarning(text) {
  try {
    console.warn(text);
    return;
  } catch (err) {
  }
}
function createElement(tag, classes2) {
  if (classes2 === void 0) {
    classes2 = [];
  }
  const el = document.createElement(tag);
  el.classList.add(...Array.isArray(classes2) ? classes2 : classesToTokens(classes2));
  return el;
}
function elementOffset(el) {
  const window2 = getWindow();
  const document2 = getDocument();
  const box = el.getBoundingClientRect();
  const body = document2.body;
  const clientTop = el.clientTop || body.clientTop || 0;
  const clientLeft = el.clientLeft || body.clientLeft || 0;
  const scrollTop = el === window2 ? window2.scrollY : el.scrollTop;
  const scrollLeft = el === window2 ? window2.scrollX : el.scrollLeft;
  return {
    top: box.top + scrollTop - clientTop,
    left: box.left + scrollLeft - clientLeft,
  };
}
function elementPrevAll(el, selector) {
  const prevEls = [];
  while (el.previousElementSibling) {
    const prev = el.previousElementSibling;
    if (selector) {
      if (prev.matches(selector))
        prevEls.push(prev);
    } else
      prevEls.push(prev);
    el = prev;
  }
  return prevEls;
}
function elementNextAll(el, selector) {
  const nextEls = [];
  while (el.nextElementSibling) {
    const next = el.nextElementSibling;
    if (selector) {
      if (next.matches(selector))
        nextEls.push(next);
    } else
      nextEls.push(next);
    el = next;
  }
  return nextEls;
}
function elementStyle(el, prop) {
  const window2 = getWindow();
  return window2.getComputedStyle(el, null).getPropertyValue(prop);
}
function elementIndex(el) {
  let child = el;
  let i;
  if (child) {
    i = 0;
    while ((child = child.previousSibling) !== null) {
      if (child.nodeType === 1)
        i += 1;
    }
    return i;
  }
  return void 0;
}
function elementParents(el, selector) {
  const parents = [];
  let parent = el.parentElement;
  while (parent) {
    if (selector) {
      if (parent.matches(selector))
        parents.push(parent);
    } else {
      parents.push(parent);
    }
    parent = parent.parentElement;
  }
  return parents;
}
function elementOuterSize(el, size, includeMargins) {
  const window2 = getWindow();
  {
    return el[size === 'width' ? 'offsetWidth' : 'offsetHeight'] + parseFloat(window2.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-right' : 'margin-top')) + parseFloat(window2.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-left' : 'margin-bottom'));
  }
}
function makeElementsArray(el) {
  return (Array.isArray(el) ? el : [el]).filter((e) => !!e);
}
let support;
function calcSupport() {
  const window2 = getWindow();
  const document2 = getDocument();
  return {
    smoothScroll: document2.documentElement && document2.documentElement.style && 'scrollBehavior' in document2.documentElement.style,
    touch: !!('ontouchstart' in window2 || window2.DocumentTouch && document2 instanceof window2.DocumentTouch),
  };
}
function getSupport() {
  if (!support) {
    support = calcSupport();
  }
  return support;
}
let deviceCached;
function calcDevice(_temp) {
  let {
    userAgent,
  } = _temp === void 0 ? {} : _temp;
  const support2 = getSupport();
  const window2 = getWindow();
  const platform = window2.navigator.platform;
  const ua = userAgent || window2.navigator.userAgent;
  const device = {
    ios: false,
    android: false,
  };
  const screenWidth = window2.screen.width;
  const screenHeight = window2.screen.height;
  const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
  let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
  const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
  const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
  const windows = platform === 'Win32';
  let macos = platform === 'MacIntel';
  const iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];
  if (!ipad && macos && support2.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
    ipad = ua.match(/(Version)\/([\d.]+)/);
    if (!ipad)
      ipad = [0, 1, '13_0_0'];
    macos = false;
  }
  if (android && !windows) {
    device.os = 'android';
    device.android = true;
  }
  if (ipad || iphone || ipod) {
    device.os = 'ios';
    device.ios = true;
  }
  return device;
}
function getDevice(overrides) {
  if (overrides === void 0) {
    overrides = {};
  }
  if (!deviceCached) {
    deviceCached = calcDevice(overrides);
  }
  return deviceCached;
}
let browser;
function calcBrowser() {
  const window2 = getWindow();
  const device = getDevice();
  let needPerspectiveFix = false;
  function isSafari() {
    const ua = window2.navigator.userAgent.toLowerCase();
    return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
  }
  if (isSafari()) {
    const ua = String(window2.navigator.userAgent);
    if (ua.includes('Version/')) {
      const [major, minor] = ua.split('Version/')[1].split(' ')[0].split('.').map((num) => Number(num));
      needPerspectiveFix = major < 16 || major === 16 && minor < 2;
    }
  }
  const isWebView = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window2.navigator.userAgent);
  const isSafariBrowser = isSafari();
  const need3dFix = isSafariBrowser || isWebView && device.ios;
  return {
    isSafari: needPerspectiveFix || isSafariBrowser,
    needPerspectiveFix,
    need3dFix,
    isWebView,
  };
}
function getBrowser() {
  if (!browser) {
    browser = calcBrowser();
  }
  return browser;
}
function Resize(_ref) {
  let {
    swiper,
    on,
    emit,
  } = _ref;
  const window2 = getWindow();
  let observer = null;
  let animationFrame = null;
  const resizeHandler = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized)
      return;
    emit('beforeResize');
    emit('resize');
  };
  const createObserver = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized)
      return;
    observer = new ResizeObserver((entries) => {
      animationFrame = window2.requestAnimationFrame(() => {
        const {
          width,
          height,
        } = swiper;
        let newWidth = width;
        let newHeight = height;
        entries.forEach((_ref2) => {
          let {
            contentBoxSize,
            contentRect,
            target,
          } = _ref2;
          if (target && target !== swiper.el)
            return;
          newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
          newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
        });
        if (newWidth !== width || newHeight !== height) {
          resizeHandler();
        }
      });
    });
    observer.observe(swiper.el);
  };
  const removeObserver = () => {
    if (animationFrame) {
      window2.cancelAnimationFrame(animationFrame);
    }
    if (observer && observer.unobserve && swiper.el) {
      observer.unobserve(swiper.el);
      observer = null;
    }
  };
  const orientationChangeHandler = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized)
      return;
    emit('orientationchange');
  };
  on('init', () => {
    if (swiper.params.resizeObserver && typeof window2.ResizeObserver !== 'undefined') {
      createObserver();
      return;
    }
    window2.addEventListener('resize', resizeHandler);
    window2.addEventListener('orientationchange', orientationChangeHandler);
  });
  on('destroy', () => {
    removeObserver();
    window2.removeEventListener('resize', resizeHandler);
    window2.removeEventListener('orientationchange', orientationChangeHandler);
  });
}
function Observer(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit,
  } = _ref;
  const observers = [];
  const window2 = getWindow();
  const attach = function (target, options) {
    if (options === void 0) {
      options = {};
    }
    const ObserverFunc = window2.MutationObserver || window2.WebkitMutationObserver;
    const observer = new ObserverFunc((mutations) => {
      if (swiper.__preventObserver__)
        return;
      if (mutations.length === 1) {
        emit('observerUpdate', mutations[0]);
        return;
      }
      const observerUpdate = function observerUpdate2() {
        emit('observerUpdate', mutations[0]);
      };
      if (window2.requestAnimationFrame) {
        window2.requestAnimationFrame(observerUpdate);
      } else {
        window2.setTimeout(observerUpdate, 0);
      }
    });
    observer.observe(target, {
      attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
      childList: typeof options.childList === 'undefined' ? true : options.childList,
      characterData: typeof options.characterData === 'undefined' ? true : options.characterData,
    });
    observers.push(observer);
  };
  const init = () => {
    if (!swiper.params.observer)
      return;
    if (swiper.params.observeParents) {
      const containerParents = elementParents(swiper.hostEl);
      for (let i = 0; i < containerParents.length; i += 1) {
        attach(containerParents[i]);
      }
    }
    attach(swiper.hostEl, {
      childList: swiper.params.observeSlideChildren,
    });
    attach(swiper.wrapperEl, {
      attributes: false,
    });
  };
  const destroy = () => {
    observers.forEach((observer) => {
      observer.disconnect();
    });
    observers.splice(0, observers.length);
  };
  extendParams({
    observer: false,
    observeParents: false,
    observeSlideChildren: false,
  });
  on('init', init);
  on('destroy', destroy);
}
var eventsEmitter = {
  on(events2, handler, priority) {
    const self2 = this;
    if (!self2.eventsListeners || self2.destroyed)
      return self2;
    if (typeof handler !== 'function')
      return self2;
    const method = priority ? 'unshift' : 'push';
    events2.split(' ').forEach((event2) => {
      if (!self2.eventsListeners[event2])
        self2.eventsListeners[event2] = [];
      self2.eventsListeners[event2][method](handler);
    });
    return self2;
  },
  once(events2, handler, priority) {
    const self2 = this;
    if (!self2.eventsListeners || self2.destroyed)
      return self2;
    if (typeof handler !== 'function')
      return self2;
    function onceHandler() {
      self2.off(events2, onceHandler);
      if (onceHandler.__emitterProxy) {
        delete onceHandler.__emitterProxy;
      }
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      handler.apply(self2, args);
    }
    onceHandler.__emitterProxy = handler;
    return self2.on(events2, onceHandler, priority);
  },
  onAny(handler, priority) {
    const self2 = this;
    if (!self2.eventsListeners || self2.destroyed)
      return self2;
    if (typeof handler !== 'function')
      return self2;
    const method = priority ? 'unshift' : 'push';
    if (self2.eventsAnyListeners.indexOf(handler) < 0) {
      self2.eventsAnyListeners[method](handler);
    }
    return self2;
  },
  offAny(handler) {
    const self2 = this;
    if (!self2.eventsListeners || self2.destroyed)
      return self2;
    if (!self2.eventsAnyListeners)
      return self2;
    const index = self2.eventsAnyListeners.indexOf(handler);
    if (index >= 0) {
      self2.eventsAnyListeners.splice(index, 1);
    }
    return self2;
  },
  off(events2, handler) {
    const self2 = this;
    if (!self2.eventsListeners || self2.destroyed)
      return self2;
    if (!self2.eventsListeners)
      return self2;
    events2.split(' ').forEach((event2) => {
      if (typeof handler === 'undefined') {
        self2.eventsListeners[event2] = [];
      } else if (self2.eventsListeners[event2]) {
        self2.eventsListeners[event2].forEach((eventHandler, index) => {
          if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
            self2.eventsListeners[event2].splice(index, 1);
          }
        });
      }
    });
    return self2;
  },
  emit() {
    const self2 = this;
    if (!self2.eventsListeners || self2.destroyed)
      return self2;
    if (!self2.eventsListeners)
      return self2;
    let events2;
    let data;
    let context;
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    if (typeof args[0] === 'string' || Array.isArray(args[0])) {
      events2 = args[0];
      data = args.slice(1, args.length);
      context = self2;
    } else {
      events2 = args[0].events;
      data = args[0].data;
      context = args[0].context || self2;
    }
    data.unshift(context);
    const eventsArray = Array.isArray(events2) ? events2 : events2.split(' ');
    eventsArray.forEach((event2) => {
      if (self2.eventsAnyListeners && self2.eventsAnyListeners.length) {
        self2.eventsAnyListeners.forEach((eventHandler) => {
          eventHandler.apply(context, [event2, ...data]);
        });
      }
      if (self2.eventsListeners && self2.eventsListeners[event2]) {
        self2.eventsListeners[event2].forEach((eventHandler) => {
          eventHandler.apply(context, data);
        });
      }
    });
    return self2;
  },
};
function updateSize() {
  const swiper = this;
  let width;
  let height;
  const el = swiper.el;
  if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {
    width = swiper.params.width;
  } else {
    width = el.clientWidth;
  }
  if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {
    height = swiper.params.height;
  } else {
    height = el.clientHeight;
  }
  if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
    return;
  }
  width = width - parseInt(elementStyle(el, 'padding-left') || 0, 10) - parseInt(elementStyle(el, 'padding-right') || 0, 10);
  height = height - parseInt(elementStyle(el, 'padding-top') || 0, 10) - parseInt(elementStyle(el, 'padding-bottom') || 0, 10);
  if (Number.isNaN(width))
    width = 0;
  if (Number.isNaN(height))
    height = 0;
  Object.assign(swiper, {
    width,
    height,
    size: swiper.isHorizontal() ? width : height,
  });
}
function updateSlides() {
  const swiper = this;
  function getDirectionPropertyValue(node, label) {
    return parseFloat(node.getPropertyValue(swiper.getDirectionLabel(label)) || 0);
  }
  const params = swiper.params;
  const {
    wrapperEl,
    slidesEl,
    size: swiperSize,
    rtlTranslate: rtl,
    wrongRTL,
  } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
  const slides = elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);
  const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
  let snapGrid = [];
  const slidesGrid = [];
  const slidesSizesGrid = [];
  let offsetBefore = params.slidesOffsetBefore;
  if (typeof offsetBefore === 'function') {
    offsetBefore = params.slidesOffsetBefore.call(swiper);
  }
  let offsetAfter = params.slidesOffsetAfter;
  if (typeof offsetAfter === 'function') {
    offsetAfter = params.slidesOffsetAfter.call(swiper);
  }
  const previousSnapGridLength = swiper.snapGrid.length;
  const previousSlidesGridLength = swiper.slidesGrid.length;
  let spaceBetween = params.spaceBetween;
  let slidePosition = -offsetBefore;
  let prevSlideSize = 0;
  let index = 0;
  if (typeof swiperSize === 'undefined') {
    return;
  }
  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
    spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;
  } else if (typeof spaceBetween === 'string') {
    spaceBetween = parseFloat(spaceBetween);
  }
  swiper.virtualSize = -spaceBetween;
  slides.forEach((slideEl) => {
    if (rtl) {
      slideEl.style.marginLeft = '';
    } else {
      slideEl.style.marginRight = '';
    }
    slideEl.style.marginBottom = '';
    slideEl.style.marginTop = '';
  });
  if (params.centeredSlides && params.cssMode) {
    setCSSProperty(wrapperEl, '--swiper-centered-offset-before', '');
    setCSSProperty(wrapperEl, '--swiper-centered-offset-after', '');
  }
  const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
  if (gridEnabled) {
    swiper.grid.initSlides(slides);
  } else if (swiper.grid) {
    swiper.grid.unsetSlides();
  }
  let slideSize;
  const shouldResetSlideSize = params.slidesPerView === 'auto' && params.breakpoints && Object.keys(params.breakpoints).filter((key) => {
    return typeof params.breakpoints[key].slidesPerView !== 'undefined';
  }).length > 0;
  for (let i = 0; i < slidesLength; i += 1) {
    slideSize = 0;
    let slide2;
    if (slides[i])
      slide2 = slides[i];
    if (gridEnabled) {
      swiper.grid.updateSlide(i, slide2, slides);
    }
    if (slides[i] && elementStyle(slide2, 'display') === 'none')
      continue;
    if (params.slidesPerView === 'auto') {
      if (shouldResetSlideSize) {
        slides[i].style[swiper.getDirectionLabel('width')] = '';
      }
      const slideStyles = getComputedStyle(slide2);
      const currentTransform = slide2.style.transform;
      const currentWebKitTransform = slide2.style.webkitTransform;
      if (currentTransform) {
        slide2.style.transform = 'none';
      }
      if (currentWebKitTransform) {
        slide2.style.webkitTransform = 'none';
      }
      if (params.roundLengths) {
        slideSize = swiper.isHorizontal() ? elementOuterSize(slide2, 'width') : elementOuterSize(slide2, 'height');
      } else {
        const width = getDirectionPropertyValue(slideStyles, 'width');
        const paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');
        const paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');
        const marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');
        const marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');
        const boxSizing = slideStyles.getPropertyValue('box-sizing');
        if (boxSizing && boxSizing === 'border-box') {
          slideSize = width + marginLeft + marginRight;
        } else {
          const {
            clientWidth,
            offsetWidth,
          } = slide2;
          slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
        }
      }
      if (currentTransform) {
        slide2.style.transform = currentTransform;
      }
      if (currentWebKitTransform) {
        slide2.style.webkitTransform = currentWebKitTransform;
      }
      if (params.roundLengths)
        slideSize = Math.floor(slideSize);
    } else {
      slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
      if (params.roundLengths)
        slideSize = Math.floor(slideSize);
      if (slides[i]) {
        slides[i].style[swiper.getDirectionLabel('width')] = `${slideSize}px`;
      }
    }
    if (slides[i]) {
      slides[i].swiperSlideSize = slideSize;
    }
    slidesSizesGrid.push(slideSize);
    if (params.centeredSlides) {
      slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
      if (prevSlideSize === 0 && i !== 0)
        slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (i === 0)
        slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (Math.abs(slidePosition) < 1 / 1e3)
        slidePosition = 0;
      if (params.roundLengths)
        slidePosition = Math.floor(slidePosition);
      if (index % params.slidesPerGroup === 0)
        snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
    } else {
      if (params.roundLengths)
        slidePosition = Math.floor(slidePosition);
      if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0)
        snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
      slidePosition = slidePosition + slideSize + spaceBetween;
    }
    swiper.virtualSize += slideSize + spaceBetween;
    prevSlideSize = slideSize;
    index += 1;
  }
  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
  if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
    wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;
  }
  if (params.setWrapperSize) {
    wrapperEl.style[swiper.getDirectionLabel('width')] = `${swiper.virtualSize + spaceBetween}px`;
  }
  if (gridEnabled) {
    swiper.grid.updateWrapperSize(slideSize, snapGrid);
  }
  if (!params.centeredSlides) {
    const newSlidesGrid = [];
    for (let i = 0; i < snapGrid.length; i += 1) {
      let slidesGridItem = snapGrid[i];
      if (params.roundLengths)
        slidesGridItem = Math.floor(slidesGridItem);
      if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
        newSlidesGrid.push(slidesGridItem);
      }
    }
    snapGrid = newSlidesGrid;
    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
      snapGrid.push(swiper.virtualSize - swiperSize);
    }
  }
  if (isVirtual && params.loop) {
    const size = slidesSizesGrid[0] + spaceBetween;
    if (params.slidesPerGroup > 1) {
      const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);
      const groupSize = size * params.slidesPerGroup;
      for (let i = 0; i < groups; i += 1) {
        snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);
      }
    }
    for (let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1) {
      if (params.slidesPerGroup === 1) {
        snapGrid.push(snapGrid[snapGrid.length - 1] + size);
      }
      slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);
      swiper.virtualSize += size;
    }
  }
  if (snapGrid.length === 0)
    snapGrid = [0];
  if (spaceBetween !== 0) {
    const key = swiper.isHorizontal() && rtl ? 'marginLeft' : swiper.getDirectionLabel('marginRight');
    slides.filter((_, slideIndex) => {
      if (!params.cssMode || params.loop)
        return true;
      if (slideIndex === slides.length - 1) {
        return false;
      }
      return true;
    }).forEach((slideEl) => {
      slideEl.style[key] = `${spaceBetween}px`;
    });
  }
  if (params.centeredSlides && params.centeredSlidesBounds) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach((slideSizeValue) => {
      allSlidesSize += slideSizeValue + (spaceBetween || 0);
    });
    allSlidesSize -= spaceBetween;
    const maxSnap = allSlidesSize - swiperSize;
    snapGrid = snapGrid.map((snap) => {
      if (snap <= 0)
        return -offsetBefore;
      if (snap > maxSnap)
        return maxSnap + offsetAfter;
      return snap;
    });
  }
  if (params.centerInsufficientSlides) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach((slideSizeValue) => {
      allSlidesSize += slideSizeValue + (spaceBetween || 0);
    });
    allSlidesSize -= spaceBetween;
    const offsetSize = (params.slidesOffsetBefore || 0) + (params.slidesOffsetAfter || 0);
    if (allSlidesSize + offsetSize < swiperSize) {
      const allSlidesOffset = (swiperSize - allSlidesSize - offsetSize) / 2;
      snapGrid.forEach((snap, snapIndex) => {
        snapGrid[snapIndex] = snap - allSlidesOffset;
      });
      slidesGrid.forEach((snap, snapIndex) => {
        slidesGrid[snapIndex] = snap + allSlidesOffset;
      });
    }
  }
  Object.assign(swiper, {
    slides,
    snapGrid,
    slidesGrid,
    slidesSizesGrid,
  });
  if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
    setCSSProperty(wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);
    setCSSProperty(wrapperEl, '--swiper-centered-offset-after', `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
    const addToSnapGrid = -swiper.snapGrid[0];
    const addToSlidesGrid = -swiper.slidesGrid[0];
    swiper.snapGrid = swiper.snapGrid.map((v) => v + addToSnapGrid);
    swiper.slidesGrid = swiper.slidesGrid.map((v) => v + addToSlidesGrid);
  }
  if (slidesLength !== previousSlidesLength) {
    swiper.emit('slidesLengthChange');
  }
  if (snapGrid.length !== previousSnapGridLength) {
    if (swiper.params.watchOverflow)
      swiper.checkOverflow();
    swiper.emit('snapGridLengthChange');
  }
  if (slidesGrid.length !== previousSlidesGridLength) {
    swiper.emit('slidesGridLengthChange');
  }
  if (params.watchSlidesProgress) {
    swiper.updateSlidesOffset();
  }
  swiper.emit('slidesUpdated');
  if (!isVirtual && !params.cssMode && (params.effect === 'slide' || params.effect === 'fade')) {
    const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
    const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);
    if (slidesLength <= params.maxBackfaceHiddenSlides) {
      if (!hasClassBackfaceClassAdded)
        swiper.el.classList.add(backFaceHiddenClass);
    } else if (hasClassBackfaceClassAdded) {
      swiper.el.classList.remove(backFaceHiddenClass);
    }
  }
}
function updateAutoHeight(speed) {
  const swiper = this;
  const activeSlides = [];
  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
  let newHeight = 0;
  let i;
  if (typeof speed === 'number') {
    swiper.setTransition(speed);
  } else if (speed === true) {
    swiper.setTransition(swiper.params.speed);
  }
  const getSlideByIndex = (index) => {
    if (isVirtual) {
      return swiper.slides[swiper.getSlideIndexByData(index)];
    }
    return swiper.slides[index];
  };
  if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
    if (swiper.params.centeredSlides) {
      (swiper.visibleSlides || []).forEach((slide2) => {
        activeSlides.push(slide2);
      });
    } else {
      for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
        const index = swiper.activeIndex + i;
        if (index > swiper.slides.length && !isVirtual)
          break;
        activeSlides.push(getSlideByIndex(index));
      }
    }
  } else {
    activeSlides.push(getSlideByIndex(swiper.activeIndex));
  }
  for (i = 0; i < activeSlides.length; i += 1) {
    if (typeof activeSlides[i] !== 'undefined') {
      const height = activeSlides[i].offsetHeight;
      newHeight = height > newHeight ? height : newHeight;
    }
  }
  if (newHeight || newHeight === 0)
    swiper.wrapperEl.style.height = `${newHeight}px`;
}
function updateSlidesOffset() {
  const swiper = this;
  const slides = swiper.slides;
  const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;
  for (let i = 0; i < slides.length; i += 1) {
    slides[i].swiperSlideOffset = (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();
  }
}
const toggleSlideClasses$1 = (slideEl, condition, className) => {
  if (condition && !slideEl.classList.contains(className)) {
    slideEl.classList.add(className);
  } else if (!condition && slideEl.classList.contains(className)) {
    slideEl.classList.remove(className);
  }
};
function updateSlidesProgress(translate2) {
  if (translate2 === void 0) {
    translate2 = this && this.translate || 0;
  }
  const swiper = this;
  const params = swiper.params;
  const {
    slides,
    rtlTranslate: rtl,
    snapGrid,
  } = swiper;
  if (slides.length === 0)
    return;
  if (typeof slides[0].swiperSlideOffset === 'undefined')
    swiper.updateSlidesOffset();
  let offsetCenter = -translate2;
  if (rtl)
    offsetCenter = translate2;
  swiper.visibleSlidesIndexes = [];
  swiper.visibleSlides = [];
  let spaceBetween = params.spaceBetween;
  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
    spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiper.size;
  } else if (typeof spaceBetween === 'string') {
    spaceBetween = parseFloat(spaceBetween);
  }
  for (let i = 0; i < slides.length; i += 1) {
    const slide2 = slides[i];
    let slideOffset = slide2.swiperSlideOffset;
    if (params.cssMode && params.centeredSlides) {
      slideOffset -= slides[0].swiperSlideOffset;
    }
    const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide2.swiperSlideSize + spaceBetween);
    const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide2.swiperSlideSize + spaceBetween);
    const slideBefore = -(offsetCenter - slideOffset);
    const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
    const isFullyVisible = slideBefore >= 0 && slideBefore <= swiper.size - swiper.slidesSizesGrid[i];
    const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
    if (isVisible) {
      swiper.visibleSlides.push(slide2);
      swiper.visibleSlidesIndexes.push(i);
    }
    toggleSlideClasses$1(slide2, isVisible, params.slideVisibleClass);
    toggleSlideClasses$1(slide2, isFullyVisible, params.slideFullyVisibleClass);
    slide2.progress = rtl ? -slideProgress : slideProgress;
    slide2.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
  }
}
function updateProgress(translate2) {
  const swiper = this;
  if (typeof translate2 === 'undefined') {
    const multiplier = swiper.rtlTranslate ? -1 : 1;
    translate2 = swiper && swiper.translate && swiper.translate * multiplier || 0;
  }
  const params = swiper.params;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  let {
    progress,
    isBeginning,
    isEnd,
    progressLoop,
  } = swiper;
  const wasBeginning = isBeginning;
  const wasEnd = isEnd;
  if (translatesDiff === 0) {
    progress = 0;
    isBeginning = true;
    isEnd = true;
  } else {
    progress = (translate2 - swiper.minTranslate()) / translatesDiff;
    const isBeginningRounded = Math.abs(translate2 - swiper.minTranslate()) < 1;
    const isEndRounded = Math.abs(translate2 - swiper.maxTranslate()) < 1;
    isBeginning = isBeginningRounded || progress <= 0;
    isEnd = isEndRounded || progress >= 1;
    if (isBeginningRounded)
      progress = 0;
    if (isEndRounded)
      progress = 1;
  }
  if (params.loop) {
    const firstSlideIndex = swiper.getSlideIndexByData(0);
    const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);
    const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];
    const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];
    const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];
    const translateAbs = Math.abs(translate2);
    if (translateAbs >= firstSlideTranslate) {
      progressLoop = (translateAbs - firstSlideTranslate) / translateMax;
    } else {
      progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;
    }
    if (progressLoop > 1)
      progressLoop -= 1;
  }
  Object.assign(swiper, {
    progress,
    progressLoop,
    isBeginning,
    isEnd,
  });
  if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight)
    swiper.updateSlidesProgress(translate2);
  if (isBeginning && !wasBeginning) {
    swiper.emit('reachBeginning toEdge');
  }
  if (isEnd && !wasEnd) {
    swiper.emit('reachEnd toEdge');
  }
  if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
    swiper.emit('fromEdge');
  }
  swiper.emit('progress', progress);
}
const toggleSlideClasses = (slideEl, condition, className) => {
  if (condition && !slideEl.classList.contains(className)) {
    slideEl.classList.add(className);
  } else if (!condition && slideEl.classList.contains(className)) {
    slideEl.classList.remove(className);
  }
};
function updateSlidesClasses() {
  const swiper = this;
  const {
    slides,
    params,
    slidesEl,
    activeIndex,
  } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
  const getFilteredSlide = (selector) => {
    return elementChildren(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];
  };
  let activeSlide;
  let prevSlide;
  let nextSlide;
  if (isVirtual) {
    if (params.loop) {
      let slideIndex = activeIndex - swiper.virtual.slidesBefore;
      if (slideIndex < 0)
        slideIndex = swiper.virtual.slides.length + slideIndex;
      if (slideIndex >= swiper.virtual.slides.length)
        slideIndex -= swiper.virtual.slides.length;
      activeSlide = getFilteredSlide(`[data-swiper-slide-index="${slideIndex}"]`);
    } else {
      activeSlide = getFilteredSlide(`[data-swiper-slide-index="${activeIndex}"]`);
    }
  } else {
    if (gridEnabled) {
      activeSlide = slides.filter((slideEl) => slideEl.column === activeIndex)[0];
      nextSlide = slides.filter((slideEl) => slideEl.column === activeIndex + 1)[0];
      prevSlide = slides.filter((slideEl) => slideEl.column === activeIndex - 1)[0];
    } else {
      activeSlide = slides[activeIndex];
    }
  }
  if (activeSlide) {
    if (!gridEnabled) {
      nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
      if (params.loop && !nextSlide) {
        nextSlide = slides[0];
      }
      prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
      if (params.loop && !prevSlide === 0) {
        prevSlide = slides[slides.length - 1];
      }
    }
  }
  slides.forEach((slideEl) => {
    toggleSlideClasses(slideEl, slideEl === activeSlide, params.slideActiveClass);
    toggleSlideClasses(slideEl, slideEl === nextSlide, params.slideNextClass);
    toggleSlideClasses(slideEl, slideEl === prevSlide, params.slidePrevClass);
  });
  swiper.emitSlidesClasses();
}
const processLazyPreloader = (swiper, imageEl) => {
  if (!swiper || swiper.destroyed || !swiper.params)
    return;
  const slideSelector = () => swiper.isElement ? 'swiper-slide' : `.${swiper.params.slideClass}`;
  const slideEl = imageEl.closest(slideSelector());
  if (slideEl) {
    let lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);
    if (!lazyEl && swiper.isElement) {
      if (slideEl.shadowRoot) {
        lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);
      } else {
        requestAnimationFrame(() => {
          if (slideEl.shadowRoot) {
            lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);
            if (lazyEl)
              lazyEl.remove();
          }
        });
      }
    }
    if (lazyEl)
      lazyEl.remove();
  }
};
const unlazy = (swiper, index) => {
  if (!swiper.slides[index])
    return;
  const imageEl = swiper.slides[index].querySelector('[loading="lazy"]');
  if (imageEl)
    imageEl.removeAttribute('loading');
};
const preload = (swiper) => {
  if (!swiper || swiper.destroyed || !swiper.params)
    return;
  let amount = swiper.params.lazyPreloadPrevNext;
  const len = swiper.slides.length;
  if (!len || !amount || amount < 0)
    return;
  amount = Math.min(amount, len);
  const slidesPerView = swiper.params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);
  const activeIndex = swiper.activeIndex;
  if (swiper.params.grid && swiper.params.grid.rows > 1) {
    const activeColumn = activeIndex;
    const preloadColumns = [activeColumn - amount];
    preloadColumns.push(...Array.from({
      length: amount,
    }).map((_, i) => {
      return activeColumn + slidesPerView + i;
    }));
    swiper.slides.forEach((slideEl, i) => {
      if (preloadColumns.includes(slideEl.column))
        unlazy(swiper, i);
    });
    return;
  }
  const slideIndexLastInView = activeIndex + slidesPerView - 1;
  if (swiper.params.rewind || swiper.params.loop) {
    for (let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1) {
      const realIndex = (i % len + len) % len;
      if (realIndex < activeIndex || realIndex > slideIndexLastInView)
        unlazy(swiper, realIndex);
    }
  } else {
    for (let i = Math.max(activeIndex - amount, 0); i <= Math.min(slideIndexLastInView + amount, len - 1); i += 1) {
      if (i !== activeIndex && (i > slideIndexLastInView || i < activeIndex)) {
        unlazy(swiper, i);
      }
    }
  }
};
function getActiveIndexByTranslate(swiper) {
  const {
    slidesGrid,
    params,
  } = swiper;
  const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  let activeIndex;
  for (let i = 0; i < slidesGrid.length; i += 1) {
    if (typeof slidesGrid[i + 1] !== 'undefined') {
      if (translate2 >= slidesGrid[i] && translate2 < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
        activeIndex = i;
      } else if (translate2 >= slidesGrid[i] && translate2 < slidesGrid[i + 1]) {
        activeIndex = i + 1;
      }
    } else if (translate2 >= slidesGrid[i]) {
      activeIndex = i;
    }
  }
  if (params.normalizeSlideIndex) {
    if (activeIndex < 0 || typeof activeIndex === 'undefined')
      activeIndex = 0;
  }
  return activeIndex;
}
function updateActiveIndex(newActiveIndex) {
  const swiper = this;
  const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  const {
    snapGrid,
    params,
    activeIndex: previousIndex,
    realIndex: previousRealIndex,
    snapIndex: previousSnapIndex,
  } = swiper;
  let activeIndex = newActiveIndex;
  let snapIndex;
  const getVirtualRealIndex = (aIndex) => {
    let realIndex2 = aIndex - swiper.virtual.slidesBefore;
    if (realIndex2 < 0) {
      realIndex2 = swiper.virtual.slides.length + realIndex2;
    }
    if (realIndex2 >= swiper.virtual.slides.length) {
      realIndex2 -= swiper.virtual.slides.length;
    }
    return realIndex2;
  };
  if (typeof activeIndex === 'undefined') {
    activeIndex = getActiveIndexByTranslate(swiper);
  }
  if (snapGrid.indexOf(translate2) >= 0) {
    snapIndex = snapGrid.indexOf(translate2);
  } else {
    const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
    snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
  }
  if (snapIndex >= snapGrid.length)
    snapIndex = snapGrid.length - 1;
  if (activeIndex === previousIndex && !swiper.params.loop) {
    if (snapIndex !== previousSnapIndex) {
      swiper.snapIndex = snapIndex;
      swiper.emit('snapIndexChange');
    }
    return;
  }
  if (activeIndex === previousIndex && swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
    swiper.realIndex = getVirtualRealIndex(activeIndex);
    return;
  }
  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
  let realIndex;
  if (swiper.virtual && params.virtual.enabled && params.loop) {
    realIndex = getVirtualRealIndex(activeIndex);
  } else if (gridEnabled) {
    const firstSlideInColumn = swiper.slides.filter((slideEl) => slideEl.column === activeIndex)[0];
    let activeSlideIndex = parseInt(firstSlideInColumn.getAttribute('data-swiper-slide-index'), 10);
    if (Number.isNaN(activeSlideIndex)) {
      activeSlideIndex = Math.max(swiper.slides.indexOf(firstSlideInColumn), 0);
    }
    realIndex = Math.floor(activeSlideIndex / params.grid.rows);
  } else if (swiper.slides[activeIndex]) {
    const slideIndex = swiper.slides[activeIndex].getAttribute('data-swiper-slide-index');
    if (slideIndex) {
      realIndex = parseInt(slideIndex, 10);
    } else {
      realIndex = activeIndex;
    }
  } else {
    realIndex = activeIndex;
  }
  Object.assign(swiper, {
    previousSnapIndex,
    snapIndex,
    previousRealIndex,
    realIndex,
    previousIndex,
    activeIndex,
  });
  if (swiper.initialized) {
    preload(swiper);
  }
  swiper.emit('activeIndexChange');
  swiper.emit('snapIndexChange');
  if (swiper.initialized || swiper.params.runCallbacksOnInit) {
    if (previousRealIndex !== realIndex) {
      swiper.emit('realIndexChange');
    }
    swiper.emit('slideChange');
  }
}
function updateClickedSlide(el, path) {
  const swiper = this;
  const params = swiper.params;
  let slide2 = el.closest(`.${params.slideClass}, swiper-slide`);
  if (!slide2 && swiper.isElement && path && path.length > 1 && path.includes(el)) {
    [...path.slice(path.indexOf(el) + 1, path.length)].forEach((pathEl) => {
      if (!slide2 && pathEl.matches && pathEl.matches(`.${params.slideClass}, swiper-slide`)) {
        slide2 = pathEl;
      }
    });
  }
  let slideFound = false;
  let slideIndex;
  if (slide2) {
    for (let i = 0; i < swiper.slides.length; i += 1) {
      if (swiper.slides[i] === slide2) {
        slideFound = true;
        slideIndex = i;
        break;
      }
    }
  }
  if (slide2 && slideFound) {
    swiper.clickedSlide = slide2;
    if (swiper.virtual && swiper.params.virtual.enabled) {
      swiper.clickedIndex = parseInt(slide2.getAttribute('data-swiper-slide-index'), 10);
    } else {
      swiper.clickedIndex = slideIndex;
    }
  } else {
    swiper.clickedSlide = void 0;
    swiper.clickedIndex = void 0;
    return;
  }
  if (params.slideToClickedSlide && swiper.clickedIndex !== void 0 && swiper.clickedIndex !== swiper.activeIndex) {
    swiper.slideToClickedSlide();
  }
}
var update = {
  updateSize,
  updateSlides,
  updateAutoHeight,
  updateSlidesOffset,
  updateSlidesProgress,
  updateProgress,
  updateSlidesClasses,
  updateActiveIndex,
  updateClickedSlide,
};
function getSwiperTranslate(axis) {
  if (axis === void 0) {
    axis = this.isHorizontal() ? 'x' : 'y';
  }
  const swiper = this;
  const {
    params,
    rtlTranslate: rtl,
    translate: translate2,
    wrapperEl,
  } = swiper;
  if (params.virtualTranslate) {
    return rtl ? -translate2 : translate2;
  }
  if (params.cssMode) {
    return translate2;
  }
  let currentTranslate = getTranslate(wrapperEl, axis);
  currentTranslate += swiper.cssOverflowAdjustment();
  if (rtl)
    currentTranslate = -currentTranslate;
  return currentTranslate || 0;
}
function setTranslate(translate2, byController) {
  const swiper = this;
  const {
    rtlTranslate: rtl,
    params,
    wrapperEl,
    progress,
  } = swiper;
  let x2 = 0;
  let y = 0;
  const z = 0;
  if (swiper.isHorizontal()) {
    x2 = rtl ? -translate2 : translate2;
  } else {
    y = translate2;
  }
  if (params.roundLengths) {
    x2 = Math.floor(x2);
    y = Math.floor(y);
  }
  swiper.previousTranslate = swiper.translate;
  swiper.translate = swiper.isHorizontal() ? x2 : y;
  if (params.cssMode) {
    wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x2 : -y;
  } else if (!params.virtualTranslate) {
    if (swiper.isHorizontal()) {
      x2 -= swiper.cssOverflowAdjustment();
    } else {
      y -= swiper.cssOverflowAdjustment();
    }
    wrapperEl.style.transform = `translate3d(${x2}px, ${y}px, ${z}px)`;
  }
  let newProgress;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (translate2 - swiper.minTranslate()) / translatesDiff;
  }
  if (newProgress !== progress) {
    swiper.updateProgress(translate2);
  }
  swiper.emit('setTranslate', swiper.translate, byController);
}
function minTranslate() {
  return -this.snapGrid[0];
}
function maxTranslate() {
  return -this.snapGrid[this.snapGrid.length - 1];
}
function translateTo(translate2, speed, runCallbacks, translateBounds, internal) {
  if (translate2 === void 0) {
    translate2 = 0;
  }
  if (speed === void 0) {
    speed = this.params.speed;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  if (translateBounds === void 0) {
    translateBounds = true;
  }
  const swiper = this;
  const {
    params,
    wrapperEl,
  } = swiper;
  if (swiper.animating && params.preventInteractionOnTransition) {
    return false;
  }
  const minTranslate2 = swiper.minTranslate();
  const maxTranslate2 = swiper.maxTranslate();
  let newTranslate;
  if (translateBounds && translate2 > minTranslate2)
    newTranslate = minTranslate2;
  else if (translateBounds && translate2 < maxTranslate2)
    newTranslate = maxTranslate2;
  else
    newTranslate = translate2;
  swiper.updateProgress(newTranslate);
  if (params.cssMode) {
    const isH = swiper.isHorizontal();
    if (speed === 0) {
      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
    } else {
      if (!swiper.support.smoothScroll) {
        animateCSSModeScroll({
          swiper,
          targetPosition: -newTranslate,
          side: isH ? 'left' : 'top',
        });
        return true;
      }
      wrapperEl.scrollTo({
        [isH ? 'left' : 'top']: -newTranslate,
        behavior: 'smooth',
      });
    }
    return true;
  }
  if (speed === 0) {
    swiper.setTransition(0);
    swiper.setTranslate(newTranslate);
    if (runCallbacks) {
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.emit('transitionEnd');
    }
  } else {
    swiper.setTransition(speed);
    swiper.setTranslate(newTranslate);
    if (runCallbacks) {
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.emit('transitionStart');
    }
    if (!swiper.animating) {
      swiper.animating = true;
      if (!swiper.onTranslateToWrapperTransitionEnd) {
        swiper.onTranslateToWrapperTransitionEnd = function transitionEnd2(e) {
          if (!swiper || swiper.destroyed)
            return;
          if (e.target !== this)
            return;
          swiper.wrapperEl.removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
          swiper.onTranslateToWrapperTransitionEnd = null;
          delete swiper.onTranslateToWrapperTransitionEnd;
          swiper.animating = false;
          if (runCallbacks) {
            swiper.emit('transitionEnd');
          }
        };
      }
      swiper.wrapperEl.addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
    }
  }
  return true;
}
var translate = {
  getTranslate: getSwiperTranslate,
  setTranslate,
  minTranslate,
  maxTranslate,
  translateTo,
};
function setTransition(duration, byController) {
  const swiper = this;
  if (!swiper.params.cssMode) {
    swiper.wrapperEl.style.transitionDuration = `${duration}ms`;
    swiper.wrapperEl.style.transitionDelay = duration === 0 ? '0ms' : '';
  }
  swiper.emit('setTransition', duration, byController);
}
function transitionEmit(_ref) {
  let {
    swiper,
    runCallbacks,
    direction,
    step,
  } = _ref;
  const {
    activeIndex,
    previousIndex,
  } = swiper;
  let dir = direction;
  if (!dir) {
    if (activeIndex > previousIndex)
      dir = 'next';
    else if (activeIndex < previousIndex)
      dir = 'prev';
    else
      dir = 'reset';
  }
  swiper.emit(`transition${step}`);
  if (runCallbacks && activeIndex !== previousIndex) {
    if (dir === 'reset') {
      swiper.emit(`slideResetTransition${step}`);
      return;
    }
    swiper.emit(`slideChangeTransition${step}`);
    if (dir === 'next') {
      swiper.emit(`slideNextTransition${step}`);
    } else {
      swiper.emit(`slidePrevTransition${step}`);
    }
  }
}
function transitionStart(runCallbacks, direction) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper = this;
  const {
    params,
  } = swiper;
  if (params.cssMode)
    return;
  if (params.autoHeight) {
    swiper.updateAutoHeight();
  }
  transitionEmit({
    swiper,
    runCallbacks,
    direction,
    step: 'Start',
  });
}
function transitionEnd(runCallbacks, direction) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper = this;
  const {
    params,
  } = swiper;
  swiper.animating = false;
  if (params.cssMode)
    return;
  swiper.setTransition(0);
  transitionEmit({
    swiper,
    runCallbacks,
    direction,
    step: 'End',
  });
}
var transition = {
  setTransition,
  transitionStart,
  transitionEnd,
};
function slideTo(index, speed, runCallbacks, internal, initial) {
  if (index === void 0) {
    index = 0;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  if (typeof index === 'string') {
    index = parseInt(index, 10);
  }
  const swiper = this;
  let slideIndex = index;
  if (slideIndex < 0)
    slideIndex = 0;
  const {
    params,
    snapGrid,
    slidesGrid,
    previousIndex,
    activeIndex,
    rtlTranslate: rtl,
    wrapperEl,
    enabled,
  } = swiper;
  if (!enabled && !internal && !initial || swiper.destroyed || swiper.animating && params.preventInteractionOnTransition) {
    return false;
  }
  if (typeof speed === 'undefined') {
    speed = swiper.params.speed;
  }
  const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
  let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
  if (snapIndex >= snapGrid.length)
    snapIndex = snapGrid.length - 1;
  const translate2 = -snapGrid[snapIndex];
  if (params.normalizeSlideIndex) {
    for (let i = 0; i < slidesGrid.length; i += 1) {
      const normalizedTranslate = -Math.floor(translate2 * 100);
      const normalizedGrid = Math.floor(slidesGrid[i] * 100);
      const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);
      if (typeof slidesGrid[i + 1] !== 'undefined') {
        if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
          slideIndex = i;
        } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
          slideIndex = i + 1;
        }
      } else if (normalizedTranslate >= normalizedGrid) {
        slideIndex = i;
      }
    }
  }
  if (swiper.initialized && slideIndex !== activeIndex) {
    if (!swiper.allowSlideNext && (rtl ? translate2 > swiper.translate && translate2 > swiper.minTranslate() : translate2 < swiper.translate && translate2 < swiper.minTranslate())) {
      return false;
    }
    if (!swiper.allowSlidePrev && translate2 > swiper.translate && translate2 > swiper.maxTranslate()) {
      if ((activeIndex || 0) !== slideIndex) {
        return false;
      }
    }
  }
  if (slideIndex !== (previousIndex || 0) && runCallbacks) {
    swiper.emit('beforeSlideChangeStart');
  }
  swiper.updateProgress(translate2);
  let direction;
  if (slideIndex > activeIndex)
    direction = 'next';
  else if (slideIndex < activeIndex)
    direction = 'prev';
  else
    direction = 'reset';
  if (rtl && -translate2 === swiper.translate || !rtl && translate2 === swiper.translate) {
    swiper.updateActiveIndex(slideIndex);
    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }
    swiper.updateSlidesClasses();
    if (params.effect !== 'slide') {
      swiper.setTranslate(translate2);
    }
    if (direction !== 'reset') {
      swiper.transitionStart(runCallbacks, direction);
      swiper.transitionEnd(runCallbacks, direction);
    }
    return false;
  }
  if (params.cssMode) {
    const isH = swiper.isHorizontal();
    const t = rtl ? translate2 : -translate2;
    if (speed === 0) {
      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
      if (isVirtual) {
        swiper.wrapperEl.style.scrollSnapType = 'none';
        swiper._immediateVirtual = true;
      }
      if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {
        swiper._cssModeVirtualInitialSet = true;
        requestAnimationFrame(() => {
          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
        });
      } else {
        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
      }
      if (isVirtual) {
        requestAnimationFrame(() => {
          swiper.wrapperEl.style.scrollSnapType = '';
          swiper._immediateVirtual = false;
        });
      }
    } else {
      if (!swiper.support.smoothScroll) {
        animateCSSModeScroll({
          swiper,
          targetPosition: t,
          side: isH ? 'left' : 'top',
        });
        return true;
      }
      wrapperEl.scrollTo({
        [isH ? 'left' : 'top']: t,
        behavior: 'smooth',
      });
    }
    return true;
  }
  swiper.setTransition(speed);
  swiper.setTranslate(translate2);
  swiper.updateActiveIndex(slideIndex);
  swiper.updateSlidesClasses();
  swiper.emit('beforeTransitionStart', speed, internal);
  swiper.transitionStart(runCallbacks, direction);
  if (speed === 0) {
    swiper.transitionEnd(runCallbacks, direction);
  } else if (!swiper.animating) {
    swiper.animating = true;
    if (!swiper.onSlideToWrapperTransitionEnd) {
      swiper.onSlideToWrapperTransitionEnd = function transitionEnd2(e) {
        if (!swiper || swiper.destroyed)
          return;
        if (e.target !== this)
          return;
        swiper.wrapperEl.removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
        swiper.onSlideToWrapperTransitionEnd = null;
        delete swiper.onSlideToWrapperTransitionEnd;
        swiper.transitionEnd(runCallbacks, direction);
      };
    }
    swiper.wrapperEl.addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
  }
  return true;
}
function slideToLoop(index, speed, runCallbacks, internal) {
  if (index === void 0) {
    index = 0;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  if (typeof index === 'string') {
    const indexAsNumber = parseInt(index, 10);
    index = indexAsNumber;
  }
  const swiper = this;
  if (swiper.destroyed)
    return;
  if (typeof speed === 'undefined') {
    speed = swiper.params.speed;
  }
  const gridEnabled = swiper.grid && swiper.params.grid && swiper.params.grid.rows > 1;
  let newIndex = index;
  if (swiper.params.loop) {
    if (swiper.virtual && swiper.params.virtual.enabled) {
      newIndex = newIndex + swiper.virtual.slidesBefore;
    } else {
      let targetSlideIndex;
      if (gridEnabled) {
        const slideIndex = newIndex * swiper.params.grid.rows;
        targetSlideIndex = swiper.slides.filter((slideEl) => slideEl.getAttribute('data-swiper-slide-index') * 1 === slideIndex)[0].column;
      } else {
        targetSlideIndex = swiper.getSlideIndexByData(newIndex);
      }
      const cols = gridEnabled ? Math.ceil(swiper.slides.length / swiper.params.grid.rows) : swiper.slides.length;
      const {
        centeredSlides,
      } = swiper.params;
      let slidesPerView = swiper.params.slidesPerView;
      if (slidesPerView === 'auto') {
        slidesPerView = swiper.slidesPerViewDynamic();
      } else {
        slidesPerView = Math.ceil(parseFloat(swiper.params.slidesPerView, 10));
        if (centeredSlides && slidesPerView % 2 === 0) {
          slidesPerView = slidesPerView + 1;
        }
      }
      let needLoopFix = cols - targetSlideIndex < slidesPerView;
      if (centeredSlides) {
        needLoopFix = needLoopFix || targetSlideIndex < Math.ceil(slidesPerView / 2);
      }
      if (internal && centeredSlides && swiper.params.slidesPerView !== 'auto' && !gridEnabled) {
        needLoopFix = false;
      }
      if (needLoopFix) {
        const direction = centeredSlides ? targetSlideIndex < swiper.activeIndex ? 'prev' : 'next' : targetSlideIndex - swiper.activeIndex - 1 < swiper.params.slidesPerView ? 'next' : 'prev';
        swiper.loopFix({
          direction,
          slideTo: true,
          activeSlideIndex: direction === 'next' ? targetSlideIndex + 1 : targetSlideIndex - cols + 1,
          slideRealIndex: direction === 'next' ? swiper.realIndex : void 0,
        });
      }
      if (gridEnabled) {
        const slideIndex = newIndex * swiper.params.grid.rows;
        newIndex = swiper.slides.filter((slideEl) => slideEl.getAttribute('data-swiper-slide-index') * 1 === slideIndex)[0].column;
      } else {
        newIndex = swiper.getSlideIndexByData(newIndex);
      }
    }
  }
  requestAnimationFrame(() => {
    swiper.slideTo(newIndex, speed, runCallbacks, internal);
  });
  return swiper;
}
function slideNext(speed, runCallbacks, internal) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper = this;
  const {
    enabled,
    params,
    animating,
  } = swiper;
  if (!enabled || swiper.destroyed)
    return swiper;
  if (typeof speed === 'undefined') {
    speed = swiper.params.speed;
  }
  let perGroup = params.slidesPerGroup;
  if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
    perGroup = Math.max(swiper.slidesPerViewDynamic('current', true), 1);
  }
  const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  if (params.loop) {
    if (animating && !isVirtual && params.loopPreventsSliding)
      return false;
    swiper.loopFix({
      direction: 'next',
    });
    swiper._clientLeft = swiper.wrapperEl.clientLeft;
    if (swiper.activeIndex === swiper.slides.length - 1 && params.cssMode) {
      requestAnimationFrame(() => {
        swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
      });
      return true;
    }
  }
  if (params.rewind && swiper.isEnd) {
    return swiper.slideTo(0, speed, runCallbacks, internal);
  }
  return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
}
function slidePrev(speed, runCallbacks, internal) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper = this;
  const {
    params,
    snapGrid,
    slidesGrid,
    rtlTranslate,
    enabled,
    animating,
  } = swiper;
  if (!enabled || swiper.destroyed)
    return swiper;
  if (typeof speed === 'undefined') {
    speed = swiper.params.speed;
  }
  const isVirtual = swiper.virtual && params.virtual.enabled;
  if (params.loop) {
    if (animating && !isVirtual && params.loopPreventsSliding)
      return false;
    swiper.loopFix({
      direction: 'prev',
    });
    swiper._clientLeft = swiper.wrapperEl.clientLeft;
  }
  const translate2 = rtlTranslate ? swiper.translate : -swiper.translate;
  function normalize(val) {
    if (val < 0)
      return -Math.floor(Math.abs(val));
    return Math.floor(val);
  }
  const normalizedTranslate = normalize(translate2);
  const normalizedSnapGrid = snapGrid.map((val) => normalize(val));
  let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
  if (typeof prevSnap === 'undefined' && params.cssMode) {
    let prevSnapIndex;
    snapGrid.forEach((snap, snapIndex) => {
      if (normalizedTranslate >= snap) {
        prevSnapIndex = snapIndex;
      }
    });
    if (typeof prevSnapIndex !== 'undefined') {
      prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
    }
  }
  let prevIndex = 0;
  if (typeof prevSnap !== 'undefined') {
    prevIndex = slidesGrid.indexOf(prevSnap);
    if (prevIndex < 0)
      prevIndex = swiper.activeIndex - 1;
    if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
      prevIndex = prevIndex - swiper.slidesPerViewDynamic('previous', true) + 1;
      prevIndex = Math.max(prevIndex, 0);
    }
  }
  if (params.rewind && swiper.isBeginning) {
    const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
    return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
  } else if (params.loop && swiper.activeIndex === 0 && params.cssMode) {
    requestAnimationFrame(() => {
      swiper.slideTo(prevIndex, speed, runCallbacks, internal);
    });
    return true;
  }
  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
}
function slideReset(speed, runCallbacks, internal) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper = this;
  if (swiper.destroyed)
    return;
  if (typeof speed === 'undefined') {
    speed = swiper.params.speed;
  }
  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
}
function slideToClosest(speed, runCallbacks, internal, threshold) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  if (threshold === void 0) {
    threshold = 0.5;
  }
  const swiper = this;
  if (swiper.destroyed)
    return;
  if (typeof speed === 'undefined') {
    speed = swiper.params.speed;
  }
  let index = swiper.activeIndex;
  const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
  const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
  const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  if (translate2 >= swiper.snapGrid[snapIndex]) {
    const currentSnap = swiper.snapGrid[snapIndex];
    const nextSnap = swiper.snapGrid[snapIndex + 1];
    if (translate2 - currentSnap > (nextSnap - currentSnap) * threshold) {
      index += swiper.params.slidesPerGroup;
    }
  } else {
    const prevSnap = swiper.snapGrid[snapIndex - 1];
    const currentSnap = swiper.snapGrid[snapIndex];
    if (translate2 - prevSnap <= (currentSnap - prevSnap) * threshold) {
      index -= swiper.params.slidesPerGroup;
    }
  }
  index = Math.max(index, 0);
  index = Math.min(index, swiper.slidesGrid.length - 1);
  return swiper.slideTo(index, speed, runCallbacks, internal);
}
function slideToClickedSlide() {
  const swiper = this;
  if (swiper.destroyed)
    return;
  const {
    params,
    slidesEl,
  } = swiper;
  const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
  let slideToIndex = swiper.clickedIndex;
  let realIndex;
  const slideSelector = swiper.isElement ? 'swiper-slide' : `.${params.slideClass}`;
  if (params.loop) {
    if (swiper.animating)
      return;
    realIndex = parseInt(swiper.clickedSlide.getAttribute('data-swiper-slide-index'), 10);
    if (params.centeredSlides) {
      if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
        swiper.loopFix();
        slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
        nextTick(() => {
          swiper.slideTo(slideToIndex);
        });
      } else {
        swiper.slideTo(slideToIndex);
      }
    } else if (slideToIndex > swiper.slides.length - slidesPerView) {
      swiper.loopFix();
      slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
      nextTick(() => {
        swiper.slideTo(slideToIndex);
      });
    } else {
      swiper.slideTo(slideToIndex);
    }
  } else {
    swiper.slideTo(slideToIndex);
  }
}
var slide = {
  slideTo,
  slideToLoop,
  slideNext,
  slidePrev,
  slideReset,
  slideToClosest,
  slideToClickedSlide,
};
function loopCreate(slideRealIndex) {
  const swiper = this;
  const {
    params,
    slidesEl,
  } = swiper;
  if (!params.loop || swiper.virtual && swiper.params.virtual.enabled)
    return;
  const initSlides = () => {
    const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
    slides.forEach((el, index) => {
      el.setAttribute('data-swiper-slide-index', index);
    });
  };
  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
  const slidesPerGroup = params.slidesPerGroup * (gridEnabled ? params.grid.rows : 1);
  const shouldFillGroup = swiper.slides.length % slidesPerGroup !== 0;
  const shouldFillGrid = gridEnabled && swiper.slides.length % params.grid.rows !== 0;
  const addBlankSlides = (amountOfSlides) => {
    for (let i = 0; i < amountOfSlides; i += 1) {
      const slideEl = swiper.isElement ? createElement('swiper-slide', [params.slideBlankClass]) : createElement('div', [params.slideClass, params.slideBlankClass]);
      swiper.slidesEl.append(slideEl);
    }
  };
  if (shouldFillGroup) {
    if (params.loopAddBlankSlides) {
      const slidesToAdd = slidesPerGroup - swiper.slides.length % slidesPerGroup;
      addBlankSlides(slidesToAdd);
      swiper.recalcSlides();
      swiper.updateSlides();
    } else {
      showWarning('Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)');
    }
    initSlides();
  } else if (shouldFillGrid) {
    if (params.loopAddBlankSlides) {
      const slidesToAdd = params.grid.rows - swiper.slides.length % params.grid.rows;
      addBlankSlides(slidesToAdd);
      swiper.recalcSlides();
      swiper.updateSlides();
    } else {
      showWarning('Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)');
    }
    initSlides();
  } else {
    initSlides();
  }
  swiper.loopFix({
    slideRealIndex,
    direction: params.centeredSlides ? void 0 : 'next',
  });
}
function loopFix(_temp) {
  let {
    slideRealIndex,
    slideTo: slideTo2 = true,
    direction,
    setTranslate: setTranslate2,
    activeSlideIndex,
    byController,
    byMousewheel,
  } = _temp === void 0 ? {} : _temp;
  const swiper = this;
  if (!swiper.params.loop)
    return;
  swiper.emit('beforeLoopFix');
  const {
    slides,
    allowSlidePrev,
    allowSlideNext,
    slidesEl,
    params,
  } = swiper;
  const {
    centeredSlides,
  } = params;
  swiper.allowSlidePrev = true;
  swiper.allowSlideNext = true;
  if (swiper.virtual && params.virtual.enabled) {
    if (slideTo2) {
      if (!params.centeredSlides && swiper.snapIndex === 0) {
        swiper.slideTo(swiper.virtual.slides.length, 0, false, true);
      } else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) {
        swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true);
      } else if (swiper.snapIndex === swiper.snapGrid.length - 1) {
        swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);
      }
    }
    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;
    swiper.emit('loopFix');
    return;
  }
  let slidesPerView = params.slidesPerView;
  if (slidesPerView === 'auto') {
    slidesPerView = swiper.slidesPerViewDynamic();
  } else {
    slidesPerView = Math.ceil(parseFloat(params.slidesPerView, 10));
    if (centeredSlides && slidesPerView % 2 === 0) {
      slidesPerView = slidesPerView + 1;
    }
  }
  const slidesPerGroup = params.slidesPerGroupAuto ? slidesPerView : params.slidesPerGroup;
  let loopedSlides = slidesPerGroup;
  if (loopedSlides % slidesPerGroup !== 0) {
    loopedSlides += slidesPerGroup - loopedSlides % slidesPerGroup;
  }
  loopedSlides += params.loopAdditionalSlides;
  swiper.loopedSlides = loopedSlides;
  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
  if (slides.length < slidesPerView + loopedSlides) {
    showWarning('Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters');
  } else if (gridEnabled && params.grid.fill === 'row') {
    showWarning('Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`');
  }
  const prependSlidesIndexes = [];
  const appendSlidesIndexes = [];
  let activeIndex = swiper.activeIndex;
  if (typeof activeSlideIndex === 'undefined') {
    activeSlideIndex = swiper.getSlideIndex(slides.filter((el) => el.classList.contains(params.slideActiveClass))[0]);
  } else {
    activeIndex = activeSlideIndex;
  }
  const isNext = direction === 'next' || !direction;
  const isPrev = direction === 'prev' || !direction;
  let slidesPrepended = 0;
  let slidesAppended = 0;
  const cols = gridEnabled ? Math.ceil(slides.length / params.grid.rows) : slides.length;
  const activeColIndex = gridEnabled ? slides[activeSlideIndex].column : activeSlideIndex;
  const activeColIndexWithShift = activeColIndex + (centeredSlides && typeof setTranslate2 === 'undefined' ? -slidesPerView / 2 + 0.5 : 0);
  if (activeColIndexWithShift < loopedSlides) {
    slidesPrepended = Math.max(loopedSlides - activeColIndexWithShift, slidesPerGroup);
    for (let i = 0; i < loopedSlides - activeColIndexWithShift; i += 1) {
      const index = i - Math.floor(i / cols) * cols;
      if (gridEnabled) {
        const colIndexToPrepend = cols - index - 1;
        for (let i2 = slides.length - 1; i2 >= 0; i2 -= 1) {
          if (slides[i2].column === colIndexToPrepend)
            prependSlidesIndexes.push(i2);
        }
      } else {
        prependSlidesIndexes.push(cols - index - 1);
      }
    }
  } else if (activeColIndexWithShift + slidesPerView > cols - loopedSlides) {
    slidesAppended = Math.max(activeColIndexWithShift - (cols - loopedSlides * 2), slidesPerGroup);
    for (let i = 0; i < slidesAppended; i += 1) {
      const index = i - Math.floor(i / cols) * cols;
      if (gridEnabled) {
        slides.forEach((slide2, slideIndex) => {
          if (slide2.column === index)
            appendSlidesIndexes.push(slideIndex);
        });
      } else {
        appendSlidesIndexes.push(index);
      }
    }
  }
  swiper.__preventObserver__ = true;
  requestAnimationFrame(() => {
    swiper.__preventObserver__ = false;
  });
  if (isPrev) {
    prependSlidesIndexes.forEach((index) => {
      slides[index].swiperLoopMoveDOM = true;
      slidesEl.prepend(slides[index]);
      slides[index].swiperLoopMoveDOM = false;
    });
  }
  if (isNext) {
    appendSlidesIndexes.forEach((index) => {
      slides[index].swiperLoopMoveDOM = true;
      slidesEl.append(slides[index]);
      slides[index].swiperLoopMoveDOM = false;
    });
  }
  swiper.recalcSlides();
  if (params.slidesPerView === 'auto') {
    swiper.updateSlides();
  } else if (gridEnabled && (prependSlidesIndexes.length > 0 && isPrev || appendSlidesIndexes.length > 0 && isNext)) {
    swiper.slides.forEach((slide2, slideIndex) => {
      swiper.grid.updateSlide(slideIndex, slide2, swiper.slides);
    });
  }
  if (params.watchSlidesProgress) {
    swiper.updateSlidesOffset();
  }
  if (slideTo2) {
    if (prependSlidesIndexes.length > 0 && isPrev) {
      if (typeof slideRealIndex === 'undefined') {
        const currentSlideTranslate = swiper.slidesGrid[activeIndex];
        const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];
        const diff = newSlideTranslate - currentSlideTranslate;
        if (byMousewheel) {
          swiper.setTranslate(swiper.translate - diff);
        } else {
          swiper.slideTo(activeIndex + Math.ceil(slidesPrepended), 0, false, true);
          if (setTranslate2) {
            swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;
            swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;
          }
        }
      } else {
        if (setTranslate2) {
          const shift = gridEnabled ? prependSlidesIndexes.length / params.grid.rows : prependSlidesIndexes.length;
          swiper.slideTo(swiper.activeIndex + shift, 0, false, true);
          swiper.touchEventsData.currentTranslate = swiper.translate;
        }
      }
    } else if (appendSlidesIndexes.length > 0 && isNext) {
      if (typeof slideRealIndex === 'undefined') {
        const currentSlideTranslate = swiper.slidesGrid[activeIndex];
        const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];
        const diff = newSlideTranslate - currentSlideTranslate;
        if (byMousewheel) {
          swiper.setTranslate(swiper.translate - diff);
        } else {
          swiper.slideTo(activeIndex - slidesAppended, 0, false, true);
          if (setTranslate2) {
            swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;
            swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;
          }
        }
      } else {
        const shift = gridEnabled ? appendSlidesIndexes.length / params.grid.rows : appendSlidesIndexes.length;
        swiper.slideTo(swiper.activeIndex - shift, 0, false, true);
      }
    }
  }
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;
  if (swiper.controller && swiper.controller.control && !byController) {
    const loopParams = {
      slideRealIndex,
      direction,
      setTranslate: setTranslate2,
      activeSlideIndex,
      byController: true,
    };
    if (Array.isArray(swiper.controller.control)) {
      swiper.controller.control.forEach((c) => {
        if (!c.destroyed && c.params.loop)
          c.loopFix({
            ...loopParams,
            slideTo: c.params.slidesPerView === params.slidesPerView ? slideTo2 : false,
          });
      });
    } else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) {
      swiper.controller.control.loopFix({
        ...loopParams,
        slideTo: swiper.controller.control.params.slidesPerView === params.slidesPerView ? slideTo2 : false,
      });
    }
  }
  swiper.emit('loopFix');
}
function loopDestroy() {
  const swiper = this;
  const {
    params,
    slidesEl,
  } = swiper;
  if (!params.loop || swiper.virtual && swiper.params.virtual.enabled)
    return;
  swiper.recalcSlides();
  const newSlidesOrder = [];
  swiper.slides.forEach((slideEl) => {
    const index = typeof slideEl.swiperSlideIndex === 'undefined' ? slideEl.getAttribute('data-swiper-slide-index') * 1 : slideEl.swiperSlideIndex;
    newSlidesOrder[index] = slideEl;
  });
  swiper.slides.forEach((slideEl) => {
    slideEl.removeAttribute('data-swiper-slide-index');
  });
  newSlidesOrder.forEach((slideEl) => {
    slidesEl.append(slideEl);
  });
  swiper.recalcSlides();
  swiper.slideTo(swiper.realIndex, 0);
}
var loop = {
  loopCreate,
  loopFix,
  loopDestroy,
};
function setGrabCursor(moving) {
  const swiper = this;
  if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode)
    return;
  const el = swiper.params.touchEventsTarget === 'container' ? swiper.el : swiper.wrapperEl;
  if (swiper.isElement) {
    swiper.__preventObserver__ = true;
  }
  el.style.cursor = 'move';
  el.style.cursor = moving ? 'grabbing' : 'grab';
  if (swiper.isElement) {
    requestAnimationFrame(() => {
      swiper.__preventObserver__ = false;
    });
  }
}
function unsetGrabCursor() {
  const swiper = this;
  if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
    return;
  }
  if (swiper.isElement) {
    swiper.__preventObserver__ = true;
  }
  swiper[swiper.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '';
  if (swiper.isElement) {
    requestAnimationFrame(() => {
      swiper.__preventObserver__ = false;
    });
  }
}
var grabCursor = {
  setGrabCursor,
  unsetGrabCursor,
};
function closestElement(selector, base) {
  if (base === void 0) {
    base = this;
  }
  function __closestFrom(el) {
    if (!el || el === getDocument() || el === getWindow())
      return null;
    if (el.assignedSlot)
      el = el.assignedSlot;
    const found = el.closest(selector);
    if (!found && !el.getRootNode) {
      return null;
    }
    return found || __closestFrom(el.getRootNode().host);
  }
  return __closestFrom(base);
}
function preventEdgeSwipe(swiper, event2, startX) {
  const window2 = getWindow();
  const {
    params,
  } = swiper;
  const edgeSwipeDetection = params.edgeSwipeDetection;
  const edgeSwipeThreshold = params.edgeSwipeThreshold;
  if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window2.innerWidth - edgeSwipeThreshold)) {
    if (edgeSwipeDetection === 'prevent') {
      event2.preventDefault();
      return true;
    }
    return false;
  }
  return true;
}
function onTouchStart(event2) {
  const swiper = this;
  const document2 = getDocument();
  let e = event2;
  if (e.originalEvent)
    e = e.originalEvent;
  const data = swiper.touchEventsData;
  if (e.type === 'pointerdown') {
    if (data.pointerId !== null && data.pointerId !== e.pointerId) {
      return;
    }
    data.pointerId = e.pointerId;
  } else if (e.type === 'touchstart' && e.targetTouches.length === 1) {
    data.touchId = e.targetTouches[0].identifier;
  }
  if (e.type === 'touchstart') {
    preventEdgeSwipe(swiper, e, e.targetTouches[0].pageX);
    return;
  }
  const {
    params,
    touches,
    enabled,
  } = swiper;
  if (!enabled)
    return;
  if (!params.simulateTouch && e.pointerType === 'mouse')
    return;
  if (swiper.animating && params.preventInteractionOnTransition) {
    return;
  }
  if (!swiper.animating && params.cssMode && params.loop) {
    swiper.loopFix();
  }
  let targetEl = e.target;
  if (params.touchEventsTarget === 'wrapper') {
    if (!swiper.wrapperEl.contains(targetEl))
      return;
  }
  if ('which' in e && e.which === 3)
    return;
  if ('button' in e && e.button > 0)
    return;
  if (data.isTouched && data.isMoved)
    return;
  const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';
  const eventPath = e.composedPath ? e.composedPath() : e.path;
  if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) {
    targetEl = eventPath[0];
  }
  const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
  const isTargetShadow = !!(e.target && e.target.shadowRoot);
  if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {
    swiper.allowClick = true;
    return;
  }
  if (params.swipeHandler) {
    if (!targetEl.closest(params.swipeHandler))
      return;
  }
  touches.currentX = e.pageX;
  touches.currentY = e.pageY;
  const startX = touches.currentX;
  const startY = touches.currentY;
  if (!preventEdgeSwipe(swiper, e, startX)) {
    return;
  }
  Object.assign(data, {
    isTouched: true,
    isMoved: false,
    allowTouchCallbacks: true,
    isScrolling: void 0,
    startMoving: void 0,
  });
  touches.startX = startX;
  touches.startY = startY;
  data.touchStartTime = now();
  swiper.allowClick = true;
  swiper.updateSize();
  swiper.swipeDirection = void 0;
  if (params.threshold > 0)
    data.allowThresholdMove = false;
  let preventDefault = true;
  if (targetEl.matches(data.focusableElements)) {
    preventDefault = false;
    if (targetEl.nodeName === 'SELECT') {
      data.isTouched = false;
    }
  }
  if (document2.activeElement && document2.activeElement.matches(data.focusableElements) && document2.activeElement !== targetEl) {
    document2.activeElement.blur();
  }
  const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
  if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) {
    e.preventDefault();
  }
  if (params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {
    swiper.freeMode.onTouchStart();
  }
  swiper.emit('touchStart', e);
}
function onTouchMove(event2) {
  const document2 = getDocument();
  const swiper = this;
  const data = swiper.touchEventsData;
  const {
    params,
    touches,
    rtlTranslate: rtl,
    enabled,
  } = swiper;
  if (!enabled)
    return;
  if (!params.simulateTouch && event2.pointerType === 'mouse')
    return;
  let e = event2;
  if (e.originalEvent)
    e = e.originalEvent;
  if (e.type === 'pointermove') {
    if (data.touchId !== null)
      return;
    const id = e.pointerId;
    if (id !== data.pointerId)
      return;
  }
  let targetTouch;
  if (e.type === 'touchmove') {
    targetTouch = [...e.changedTouches].filter((t) => t.identifier === data.touchId)[0];
    if (!targetTouch || targetTouch.identifier !== data.touchId)
      return;
  } else {
    targetTouch = e;
  }
  if (!data.isTouched) {
    if (data.startMoving && data.isScrolling) {
      swiper.emit('touchMoveOpposite', e);
    }
    return;
  }
  const pageX = targetTouch.pageX;
  const pageY = targetTouch.pageY;
  if (e.preventedByNestedSwiper) {
    touches.startX = pageX;
    touches.startY = pageY;
    return;
  }
  if (!swiper.allowTouchMove) {
    if (!e.target.matches(data.focusableElements)) {
      swiper.allowClick = false;
    }
    if (data.isTouched) {
      Object.assign(touches, {
        startX: pageX,
        startY: pageY,
        currentX: pageX,
        currentY: pageY,
      });
      data.touchStartTime = now();
    }
    return;
  }
  if (params.touchReleaseOnEdges && !params.loop) {
    if (swiper.isVertical()) {
      if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
        data.isTouched = false;
        data.isMoved = false;
        return;
      }
    } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
      return;
    }
  }
  if (document2.activeElement) {
    if (e.target === document2.activeElement && e.target.matches(data.focusableElements)) {
      data.isMoved = true;
      swiper.allowClick = false;
      return;
    }
  }
  if (data.allowTouchCallbacks) {
    swiper.emit('touchMove', e);
  }
  touches.previousX = touches.currentX;
  touches.previousY = touches.currentY;
  touches.currentX = pageX;
  touches.currentY = pageY;
  const diffX = touches.currentX - touches.startX;
  const diffY = touches.currentY - touches.startY;
  if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold)
    return;
  if (typeof data.isScrolling === 'undefined') {
    let touchAngle;
    if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
      data.isScrolling = false;
    } else {
      if (diffX * diffX + diffY * diffY >= 25) {
        touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
        data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
      }
    }
  }
  if (data.isScrolling) {
    swiper.emit('touchMoveOpposite', e);
  }
  if (typeof data.startMoving === 'undefined') {
    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
      data.startMoving = true;
    }
  }
  if (data.isScrolling || e.type === 'touchmove' && data.preventTouchMoveFromPointerMove) {
    data.isTouched = false;
    return;
  }
  if (!data.startMoving) {
    return;
  }
  swiper.allowClick = false;
  if (!params.cssMode && e.cancelable) {
    e.preventDefault();
  }
  if (params.touchMoveStopPropagation && !params.nested) {
    e.stopPropagation();
  }
  let diff = swiper.isHorizontal() ? diffX : diffY;
  let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;
  if (params.oneWayMovement) {
    diff = Math.abs(diff) * (rtl ? 1 : -1);
    touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);
  }
  touches.diff = diff;
  diff *= params.touchRatio;
  if (rtl) {
    diff = -diff;
    touchesDiff = -touchesDiff;
  }
  const prevTouchesDirection = swiper.touchesDirection;
  swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
  swiper.touchesDirection = touchesDiff > 0 ? 'prev' : 'next';
  const isLoop = swiper.params.loop && !params.cssMode;
  const allowLoopFix = swiper.touchesDirection === 'next' && swiper.allowSlideNext || swiper.touchesDirection === 'prev' && swiper.allowSlidePrev;
  if (!data.isMoved) {
    if (isLoop && allowLoopFix) {
      swiper.loopFix({
        direction: swiper.swipeDirection,
      });
    }
    data.startTranslate = swiper.getTranslate();
    swiper.setTransition(0);
    if (swiper.animating) {
      const evt = new window.CustomEvent('transitionend', {
        bubbles: true,
        cancelable: true,
        detail: {
          bySwiperTouchMove: true,
        },
      });
      swiper.wrapperEl.dispatchEvent(evt);
    }
    data.allowMomentumBounce = false;
    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
      swiper.setGrabCursor(true);
    }
    swiper.emit('sliderFirstMove', e);
  }
  let loopFixed;
  (/* @__PURE__ */ new Date()).getTime();
  if (data.isMoved && data.allowThresholdMove && prevTouchesDirection !== swiper.touchesDirection && isLoop && allowLoopFix && Math.abs(diff) >= 1) {
    Object.assign(touches, {
      startX: pageX,
      startY: pageY,
      currentX: pageX,
      currentY: pageY,
      startTranslate: data.currentTranslate,
    });
    data.loopSwapReset = true;
    data.startTranslate = data.currentTranslate;
    return;
  }
  swiper.emit('sliderMove', e);
  data.isMoved = true;
  data.currentTranslate = diff + data.startTranslate;
  let disableParentSwiper = true;
  let resistanceRatio = params.resistanceRatio;
  if (params.touchReleaseOnEdges) {
    resistanceRatio = 0;
  }
  if (diff > 0) {
    if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.slidesSizesGrid[swiper.activeIndex + 1] : swiper.minTranslate())) {
      swiper.loopFix({
        direction: 'prev',
        setTranslate: true,
        activeSlideIndex: 0,
      });
    }
    if (data.currentTranslate > swiper.minTranslate()) {
      disableParentSwiper = false;
      if (params.resistance) {
        data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
      }
    }
  } else if (diff < 0) {
    if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] : swiper.maxTranslate())) {
      swiper.loopFix({
        direction: 'next',
        setTranslate: true,
        activeSlideIndex: swiper.slides.length - (params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10))),
      });
    }
    if (data.currentTranslate < swiper.maxTranslate()) {
      disableParentSwiper = false;
      if (params.resistance) {
        data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
      }
    }
  }
  if (disableParentSwiper) {
    e.preventedByNestedSwiper = true;
  }
  if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }
  if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }
  if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
    data.currentTranslate = data.startTranslate;
  }
  if (params.threshold > 0) {
    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
      if (!data.allowThresholdMove) {
        data.allowThresholdMove = true;
        touches.startX = touches.currentX;
        touches.startY = touches.currentY;
        data.currentTranslate = data.startTranslate;
        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
        return;
      }
    } else {
      data.currentTranslate = data.startTranslate;
      return;
    }
  }
  if (!params.followFinger || params.cssMode)
    return;
  if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }
  if (params.freeMode && params.freeMode.enabled && swiper.freeMode) {
    swiper.freeMode.onTouchMove();
  }
  swiper.updateProgress(data.currentTranslate);
  swiper.setTranslate(data.currentTranslate);
}
function onTouchEnd(event2) {
  const swiper = this;
  const data = swiper.touchEventsData;
  let e = event2;
  if (e.originalEvent)
    e = e.originalEvent;
  let targetTouch;
  const isTouchEvent = e.type === 'touchend' || e.type === 'touchcancel';
  if (!isTouchEvent) {
    if (data.touchId !== null)
      return;
    if (e.pointerId !== data.pointerId)
      return;
    targetTouch = e;
  } else {
    targetTouch = [...e.changedTouches].filter((t) => t.identifier === data.touchId)[0];
    if (!targetTouch || targetTouch.identifier !== data.touchId)
      return;
  }
  if (['pointercancel', 'pointerout', 'pointerleave', 'contextmenu'].includes(e.type)) {
    const proceed = ['pointercancel', 'contextmenu'].includes(e.type) && (swiper.browser.isSafari || swiper.browser.isWebView);
    if (!proceed) {
      return;
    }
  }
  data.pointerId = null;
  data.touchId = null;
  const {
    params,
    touches,
    rtlTranslate: rtl,
    slidesGrid,
    enabled,
  } = swiper;
  if (!enabled)
    return;
  if (!params.simulateTouch && e.pointerType === 'mouse')
    return;
  if (data.allowTouchCallbacks) {
    swiper.emit('touchEnd', e);
  }
  data.allowTouchCallbacks = false;
  if (!data.isTouched) {
    if (data.isMoved && params.grabCursor) {
      swiper.setGrabCursor(false);
    }
    data.isMoved = false;
    data.startMoving = false;
    return;
  }
  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
    swiper.setGrabCursor(false);
  }
  const touchEndTime = now();
  const timeDiff = touchEndTime - data.touchStartTime;
  if (swiper.allowClick) {
    const pathTree = e.path || e.composedPath && e.composedPath();
    swiper.updateClickedSlide(pathTree && pathTree[0] || e.target, pathTree);
    swiper.emit('tap click', e);
    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
      swiper.emit('doubleTap doubleClick', e);
    }
  }
  data.lastClickTime = now();
  nextTick(() => {
    if (!swiper.destroyed)
      swiper.allowClick = true;
  });
  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 && !data.loopSwapReset || data.currentTranslate === data.startTranslate && !data.loopSwapReset) {
    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;
    return;
  }
  data.isTouched = false;
  data.isMoved = false;
  data.startMoving = false;
  let currentPos;
  if (params.followFinger) {
    currentPos = rtl ? swiper.translate : -swiper.translate;
  } else {
    currentPos = -data.currentTranslate;
  }
  if (params.cssMode) {
    return;
  }
  if (params.freeMode && params.freeMode.enabled) {
    swiper.freeMode.onTouchEnd({
      currentPos,
    });
    return;
  }
  const swipeToLast = currentPos >= -swiper.maxTranslate() && !swiper.params.loop;
  let stopIndex = 0;
  let groupSize = swiper.slidesSizesGrid[0];
  for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
    const increment2 = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
    if (typeof slidesGrid[i + increment2] !== 'undefined') {
      if (swipeToLast || currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment2]) {
        stopIndex = i;
        groupSize = slidesGrid[i + increment2] - slidesGrid[i];
      }
    } else if (swipeToLast || currentPos >= slidesGrid[i]) {
      stopIndex = i;
      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
    }
  }
  let rewindFirstIndex = null;
  let rewindLastIndex = null;
  if (params.rewind) {
    if (swiper.isBeginning) {
      rewindLastIndex = params.virtual && params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
    } else if (swiper.isEnd) {
      rewindFirstIndex = 0;
    }
  }
  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
  const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
  if (timeDiff > params.longSwipesMs) {
    if (!params.longSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    if (swiper.swipeDirection === 'next') {
      if (ratio >= params.longSwipesRatio)
        swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);
      else
        swiper.slideTo(stopIndex);
    }
    if (swiper.swipeDirection === 'prev') {
      if (ratio > 1 - params.longSwipesRatio) {
        swiper.slideTo(stopIndex + increment);
      } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {
        swiper.slideTo(rewindLastIndex);
      } else {
        swiper.slideTo(stopIndex);
      }
    }
  } else {
    if (!params.shortSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
    if (!isNavButtonTarget) {
      if (swiper.swipeDirection === 'next') {
        swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
      }
      if (swiper.swipeDirection === 'prev') {
        swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
      }
    } else if (e.target === swiper.navigation.nextEl) {
      swiper.slideTo(stopIndex + increment);
    } else {
      swiper.slideTo(stopIndex);
    }
  }
}
function onResize() {
  const swiper = this;
  const {
    params,
    el,
  } = swiper;
  if (el && el.offsetWidth === 0)
    return;
  if (params.breakpoints) {
    swiper.setBreakpoint();
  }
  const {
    allowSlideNext,
    allowSlidePrev,
    snapGrid,
  } = swiper;
  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
  swiper.allowSlideNext = true;
  swiper.allowSlidePrev = true;
  swiper.updateSize();
  swiper.updateSlides();
  swiper.updateSlidesClasses();
  const isVirtualLoop = isVirtual && params.loop;
  if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) {
    swiper.slideTo(swiper.slides.length - 1, 0, false, true);
  } else {
    if (swiper.params.loop && !isVirtual) {
      swiper.slideToLoop(swiper.realIndex, 0, false, true);
    } else {
      swiper.slideTo(swiper.activeIndex, 0, false, true);
    }
  }
  if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
    clearTimeout(swiper.autoplay.resizeTimeout);
    swiper.autoplay.resizeTimeout = setTimeout(() => {
      if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
        swiper.autoplay.resume();
      }
    }, 500);
  }
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;
  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
    swiper.checkOverflow();
  }
}
function onClick(e) {
  const swiper = this;
  if (!swiper.enabled)
    return;
  if (!swiper.allowClick) {
    if (swiper.params.preventClicks)
      e.preventDefault();
    if (swiper.params.preventClicksPropagation && swiper.animating) {
      e.stopPropagation();
      e.stopImmediatePropagation();
    }
  }
}
function onScroll() {
  const swiper = this;
  const {
    wrapperEl,
    rtlTranslate,
    enabled,
  } = swiper;
  if (!enabled)
    return;
  swiper.previousTranslate = swiper.translate;
  if (swiper.isHorizontal()) {
    swiper.translate = -wrapperEl.scrollLeft;
  } else {
    swiper.translate = -wrapperEl.scrollTop;
  }
  if (swiper.translate === 0)
    swiper.translate = 0;
  swiper.updateActiveIndex();
  swiper.updateSlidesClasses();
  let newProgress;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
  }
  if (newProgress !== swiper.progress) {
    swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
  }
  swiper.emit('setTranslate', swiper.translate, false);
}
function onLoad(e) {
  const swiper = this;
  processLazyPreloader(swiper, e.target);
  if (swiper.params.cssMode || swiper.params.slidesPerView !== 'auto' && !swiper.params.autoHeight) {
    return;
  }
  swiper.update();
}
function onDocumentTouchStart() {
  const swiper = this;
  if (swiper.documentTouchHandlerProceeded)
    return;
  swiper.documentTouchHandlerProceeded = true;
  if (swiper.params.touchReleaseOnEdges) {
    swiper.el.style.touchAction = 'auto';
  }
}
const events = (swiper, method) => {
  const document2 = getDocument();
  const {
    params,
    el,
    wrapperEl,
    device,
  } = swiper;
  const capture = !!params.nested;
  const domMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';
  const swiperMethod = method;
  document2[domMethod]('touchstart', swiper.onDocumentTouchStart, {
    passive: false,
    capture,
  });
  el[domMethod]('touchstart', swiper.onTouchStart, {
    passive: false,
  });
  el[domMethod]('pointerdown', swiper.onTouchStart, {
    passive: false,
  });
  document2[domMethod]('touchmove', swiper.onTouchMove, {
    passive: false,
    capture,
  });
  document2[domMethod]('pointermove', swiper.onTouchMove, {
    passive: false,
    capture,
  });
  document2[domMethod]('touchend', swiper.onTouchEnd, {
    passive: true,
  });
  document2[domMethod]('pointerup', swiper.onTouchEnd, {
    passive: true,
  });
  document2[domMethod]('pointercancel', swiper.onTouchEnd, {
    passive: true,
  });
  document2[domMethod]('touchcancel', swiper.onTouchEnd, {
    passive: true,
  });
  document2[domMethod]('pointerout', swiper.onTouchEnd, {
    passive: true,
  });
  document2[domMethod]('pointerleave', swiper.onTouchEnd, {
    passive: true,
  });
  document2[domMethod]('contextmenu', swiper.onTouchEnd, {
    passive: true,
  });
  if (params.preventClicks || params.preventClicksPropagation) {
    el[domMethod]('click', swiper.onClick, true);
  }
  if (params.cssMode) {
    wrapperEl[domMethod]('scroll', swiper.onScroll);
  }
  if (params.updateOnWindowResize) {
    swiper[swiperMethod](device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);
  } else {
    swiper[swiperMethod]('observerUpdate', onResize, true);
  }
  el[domMethod]('load', swiper.onLoad, {
    capture: true,
  });
};
function attachEvents() {
  const swiper = this;
  const {
    params,
  } = swiper;
  swiper.onTouchStart = onTouchStart.bind(swiper);
  swiper.onTouchMove = onTouchMove.bind(swiper);
  swiper.onTouchEnd = onTouchEnd.bind(swiper);
  swiper.onDocumentTouchStart = onDocumentTouchStart.bind(swiper);
  if (params.cssMode) {
    swiper.onScroll = onScroll.bind(swiper);
  }
  swiper.onClick = onClick.bind(swiper);
  swiper.onLoad = onLoad.bind(swiper);
  events(swiper, 'on');
}
function detachEvents() {
  const swiper = this;
  events(swiper, 'off');
}
var events$1 = {
  attachEvents,
  detachEvents,
};
const isGridEnabled = (swiper, params) => {
  return swiper.grid && params.grid && params.grid.rows > 1;
};
function setBreakpoint() {
  const swiper = this;
  const {
    realIndex,
    initialized,
    params,
    el,
  } = swiper;
  const breakpoints2 = params.breakpoints;
  if (!breakpoints2 || breakpoints2 && Object.keys(breakpoints2).length === 0)
    return;
  const breakpoint = swiper.getBreakpoint(breakpoints2, swiper.params.breakpointsBase, swiper.el);
  if (!breakpoint || swiper.currentBreakpoint === breakpoint)
    return;
  const breakpointOnlyParams = breakpoint in breakpoints2 ? breakpoints2[breakpoint] : void 0;
  const breakpointParams = breakpointOnlyParams || swiper.originalParams;
  const wasMultiRow = isGridEnabled(swiper, params);
  const isMultiRow = isGridEnabled(swiper, breakpointParams);
  const wasGrabCursor = swiper.params.grabCursor;
  const isGrabCursor = breakpointParams.grabCursor;
  const wasEnabled = params.enabled;
  if (wasMultiRow && !isMultiRow) {
    el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);
    swiper.emitContainerClasses();
  } else if (!wasMultiRow && isMultiRow) {
    el.classList.add(`${params.containerModifierClass}grid`);
    if (breakpointParams.grid.fill && breakpointParams.grid.fill === 'column' || !breakpointParams.grid.fill && params.grid.fill === 'column') {
      el.classList.add(`${params.containerModifierClass}grid-column`);
    }
    swiper.emitContainerClasses();
  }
  if (wasGrabCursor && !isGrabCursor) {
    swiper.unsetGrabCursor();
  } else if (!wasGrabCursor && isGrabCursor) {
    swiper.setGrabCursor();
  }
  ['navigation', 'pagination', 'scrollbar'].forEach((prop) => {
    if (typeof breakpointParams[prop] === 'undefined')
      return;
    const wasModuleEnabled = params[prop] && params[prop].enabled;
    const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;
    if (wasModuleEnabled && !isModuleEnabled) {
      swiper[prop].disable();
    }
    if (!wasModuleEnabled && isModuleEnabled) {
      swiper[prop].enable();
    }
  });
  const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
  const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
  const wasLoop = params.loop;
  if (directionChanged && initialized) {
    swiper.changeDirection();
  }
  extend(swiper.params, breakpointParams);
  const isEnabled = swiper.params.enabled;
  const hasLoop = swiper.params.loop;
  Object.assign(swiper, {
    allowTouchMove: swiper.params.allowTouchMove,
    allowSlideNext: swiper.params.allowSlideNext,
    allowSlidePrev: swiper.params.allowSlidePrev,
  });
  if (wasEnabled && !isEnabled) {
    swiper.disable();
  } else if (!wasEnabled && isEnabled) {
    swiper.enable();
  }
  swiper.currentBreakpoint = breakpoint;
  swiper.emit('_beforeBreakpoint', breakpointParams);
  if (initialized) {
    if (needsReLoop) {
      swiper.loopDestroy();
      swiper.loopCreate(realIndex);
      swiper.updateSlides();
    } else if (!wasLoop && hasLoop) {
      swiper.loopCreate(realIndex);
      swiper.updateSlides();
    } else if (wasLoop && !hasLoop) {
      swiper.loopDestroy();
    }
  }
  swiper.emit('breakpoint', breakpointParams);
}
function getBreakpoint(breakpoints2, base, containerEl) {
  if (base === void 0) {
    base = 'window';
  }
  if (!breakpoints2 || base === 'container' && !containerEl)
    return void 0;
  let breakpoint = false;
  const window2 = getWindow();
  const currentHeight = base === 'window' ? window2.innerHeight : containerEl.clientHeight;
  const points = Object.keys(breakpoints2).map((point) => {
    if (typeof point === 'string' && point.indexOf('@') === 0) {
      const minRatio = parseFloat(point.substr(1));
      const value = currentHeight * minRatio;
      return {
        value,
        point,
      };
    }
    return {
      value: point,
      point,
    };
  });
  points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));
  for (let i = 0; i < points.length; i += 1) {
    const {
      point,
      value,
    } = points[i];
    if (base === 'window') {
      if (window2.matchMedia(`(min-width: ${value}px)`).matches) {
        breakpoint = point;
      }
    } else if (value <= containerEl.clientWidth) {
      breakpoint = point;
    }
  }
  return breakpoint || 'max';
}
var breakpoints = {
  setBreakpoint,
  getBreakpoint,
};
function prepareClasses(entries, prefix) {
  const resultClasses = [];
  entries.forEach((item) => {
    if (typeof item === 'object') {
      Object.keys(item).forEach((classNames) => {
        if (item[classNames]) {
          resultClasses.push(prefix + classNames);
        }
      });
    } else if (typeof item === 'string') {
      resultClasses.push(prefix + item);
    }
  });
  return resultClasses;
}
function addClasses() {
  const swiper = this;
  const {
    classNames,
    params,
    rtl,
    el,
    device,
  } = swiper;
  const suffixes = prepareClasses(['initialized', params.direction, {
    'free-mode': swiper.params.freeMode && params.freeMode.enabled,
  }, {
    'autoheight': params.autoHeight,
  }, {
    'rtl': rtl,
  }, {
    'grid': params.grid && params.grid.rows > 1,
  }, {
    'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column',
  }, {
    'android': device.android,
  }, {
    'ios': device.ios,
  }, {
    'css-mode': params.cssMode,
  }, {
    'centered': params.cssMode && params.centeredSlides,
  }, {
    'watch-progress': params.watchSlidesProgress,
  }], params.containerModifierClass);
  classNames.push(...suffixes);
  el.classList.add(...classNames);
  swiper.emitContainerClasses();
}
function removeClasses() {
  const swiper = this;
  const {
    el,
    classNames,
  } = swiper;
  el.classList.remove(...classNames);
  swiper.emitContainerClasses();
}
var classes = {
  addClasses,
  removeClasses,
};
function checkOverflow() {
  const swiper = this;
  const {
    isLocked: wasLocked,
    params,
  } = swiper;
  const {
    slidesOffsetBefore,
  } = params;
  if (slidesOffsetBefore) {
    const lastSlideIndex = swiper.slides.length - 1;
    const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
    swiper.isLocked = swiper.size > lastSlideRightEdge;
  } else {
    swiper.isLocked = swiper.snapGrid.length === 1;
  }
  if (params.allowSlideNext === true) {
    swiper.allowSlideNext = !swiper.isLocked;
  }
  if (params.allowSlidePrev === true) {
    swiper.allowSlidePrev = !swiper.isLocked;
  }
  if (wasLocked && wasLocked !== swiper.isLocked) {
    swiper.isEnd = false;
  }
  if (wasLocked !== swiper.isLocked) {
    swiper.emit(swiper.isLocked ? 'lock' : 'unlock');
  }
}
var checkOverflow$1 = {
  checkOverflow,
};
var defaults = {
  init: true,
  direction: 'horizontal',
  oneWayMovement: false,
  swiperElementNodeName: 'SWIPER-CONTAINER',
  touchEventsTarget: 'wrapper',
  initialSlide: 0,
  speed: 300,
  cssMode: false,
  updateOnWindowResize: true,
  resizeObserver: true,
  nested: false,
  createElements: false,
  eventsPrefix: 'swiper',
  enabled: true,
  focusableElements: 'input, select, option, textarea, button, video, label',
  // Overrides
  width: null,
  height: null,
  //
  preventInteractionOnTransition: false,
  // ssr
  userAgent: null,
  url: null,
  // To support iOS's swipe-to-go-back gesture (when being used in-app).
  edgeSwipeDetection: false,
  edgeSwipeThreshold: 20,
  // Autoheight
  autoHeight: false,
  // Set wrapper width
  setWrapperSize: false,
  // Virtual Translate
  virtualTranslate: false,
  // Effects
  effect: 'slide',
  // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
  // Breakpoints
  breakpoints: void 0,
  breakpointsBase: 'window',
  // Slides grid
  spaceBetween: 0,
  slidesPerView: 1,
  slidesPerGroup: 1,
  slidesPerGroupSkip: 0,
  slidesPerGroupAuto: false,
  centeredSlides: false,
  centeredSlidesBounds: false,
  slidesOffsetBefore: 0,
  // in px
  slidesOffsetAfter: 0,
  // in px
  normalizeSlideIndex: true,
  centerInsufficientSlides: false,
  // Disable swiper and hide navigation when container not overflow
  watchOverflow: true,
  // Round length
  roundLengths: false,
  // Touches
  touchRatio: 1,
  touchAngle: 45,
  simulateTouch: true,
  shortSwipes: true,
  longSwipes: true,
  longSwipesRatio: 0.5,
  longSwipesMs: 300,
  followFinger: true,
  allowTouchMove: true,
  threshold: 5,
  touchMoveStopPropagation: false,
  touchStartPreventDefault: true,
  touchStartForcePreventDefault: false,
  touchReleaseOnEdges: false,
  // Unique Navigation Elements
  uniqueNavElements: true,
  // Resistance
  resistance: true,
  resistanceRatio: 0.85,
  // Progress
  watchSlidesProgress: false,
  // Cursor
  grabCursor: false,
  // Clicks
  preventClicks: true,
  preventClicksPropagation: true,
  slideToClickedSlide: false,
  // loop
  loop: false,
  loopAddBlankSlides: true,
  loopAdditionalSlides: 0,
  loopPreventsSliding: true,
  // rewind
  rewind: false,
  // Swiping/no swiping
  allowSlidePrev: true,
  allowSlideNext: true,
  swipeHandler: null,
  // '.swipe-handler',
  noSwiping: true,
  noSwipingClass: 'swiper-no-swiping',
  noSwipingSelector: null,
  // Passive Listeners
  passiveListeners: true,
  maxBackfaceHiddenSlides: 10,
  // NS
  containerModifierClass: 'swiper-',
  // NEW
  slideClass: 'swiper-slide',
  slideBlankClass: 'swiper-slide-blank',
  slideActiveClass: 'swiper-slide-active',
  slideVisibleClass: 'swiper-slide-visible',
  slideFullyVisibleClass: 'swiper-slide-fully-visible',
  slideNextClass: 'swiper-slide-next',
  slidePrevClass: 'swiper-slide-prev',
  wrapperClass: 'swiper-wrapper',
  lazyPreloaderClass: 'swiper-lazy-preloader',
  lazyPreloadPrevNext: 0,
  // Callbacks
  runCallbacksOnInit: true,
  // Internals
  _emitClasses: false,
};
function moduleExtendParams(params, allModulesParams) {
  return function extendParams(obj) {
    if (obj === void 0) {
      obj = {};
    }
    const moduleParamName = Object.keys(obj)[0];
    const moduleParams = obj[moduleParamName];
    if (typeof moduleParams !== 'object' || moduleParams === null) {
      extend(allModulesParams, obj);
      return;
    }
    if (params[moduleParamName] === true) {
      params[moduleParamName] = {
        enabled: true,
      };
    }
    if (moduleParamName === 'navigation' && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].prevEl && !params[moduleParamName].nextEl) {
      params[moduleParamName].auto = true;
    }
    if (['pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].el) {
      params[moduleParamName].auto = true;
    }
    if (!(moduleParamName in params && 'enabled' in moduleParams)) {
      extend(allModulesParams, obj);
      return;
    }
    if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {
      params[moduleParamName].enabled = true;
    }
    if (!params[moduleParamName])
      params[moduleParamName] = {
        enabled: false,
      };
    extend(allModulesParams, obj);
  };
}
const prototypes = {
  eventsEmitter,
  update,
  translate,
  transition,
  slide,
  loop,
  grabCursor,
  events: events$1,
  breakpoints,
  checkOverflow: checkOverflow$1,
  classes,
};
const extendedDefaults = {};
class Swiper {
  constructor() {
    let el;
    let params;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {
      params = args[0];
    } else {
      [el, params] = args;
    }
    if (!params)
      params = {};
    params = extend({}, params);
    if (el && !params.el)
      params.el = el;
    const document2 = getDocument();
    if (params.el && typeof params.el === 'string' && document2.querySelectorAll(params.el).length > 1) {
      const swipers = [];
      document2.querySelectorAll(params.el).forEach((containerEl) => {
        const newParams = extend({}, params, {
          el: containerEl,
        });
        swipers.push(new Swiper(newParams));
      });
      return swipers;
    }
    const swiper = this;
    swiper.__swiper__ = true;
    swiper.support = getSupport();
    swiper.device = getDevice({
      userAgent: params.userAgent,
    });
    swiper.browser = getBrowser();
    swiper.eventsListeners = {};
    swiper.eventsAnyListeners = [];
    swiper.modules = [...swiper.__modules__];
    if (params.modules && Array.isArray(params.modules)) {
      swiper.modules.push(...params.modules);
    }
    const allModulesParams = {};
    swiper.modules.forEach((mod) => {
      mod({
        params,
        swiper,
        extendParams: moduleExtendParams(params, allModulesParams),
        on: swiper.on.bind(swiper),
        once: swiper.once.bind(swiper),
        off: swiper.off.bind(swiper),
        emit: swiper.emit.bind(swiper),
      });
    });
    const swiperParams = extend({}, defaults, allModulesParams);
    swiper.params = extend({}, swiperParams, extendedDefaults, params);
    swiper.originalParams = extend({}, swiper.params);
    swiper.passedParams = extend({}, params);
    if (swiper.params && swiper.params.on) {
      Object.keys(swiper.params.on).forEach((eventName) => {
        swiper.on(eventName, swiper.params.on[eventName]);
      });
    }
    if (swiper.params && swiper.params.onAny) {
      swiper.onAny(swiper.params.onAny);
    }
    Object.assign(swiper, {
      enabled: swiper.params.enabled,
      el,
      // Classes
      classNames: [],
      // Slides
      slides: [],
      slidesGrid: [],
      snapGrid: [],
      slidesSizesGrid: [],
      // isDirection
      isHorizontal() {
        return swiper.params.direction === 'horizontal';
      },
      isVertical() {
        return swiper.params.direction === 'vertical';
      },
      // Indexes
      activeIndex: 0,
      realIndex: 0,
      //
      isBeginning: true,
      isEnd: false,
      // Props
      translate: 0,
      previousTranslate: 0,
      progress: 0,
      velocity: 0,
      animating: false,
      cssOverflowAdjustment() {
        return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;
      },
      // Locks
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev,
      // Touch Events
      touchEventsData: {
        isTouched: void 0,
        isMoved: void 0,
        allowTouchCallbacks: void 0,
        touchStartTime: void 0,
        isScrolling: void 0,
        currentTranslate: void 0,
        startTranslate: void 0,
        allowThresholdMove: void 0,
        // Form elements to match
        focusableElements: swiper.params.focusableElements,
        // Last click time
        lastClickTime: 0,
        clickTimeout: void 0,
        // Velocities
        velocities: [],
        allowMomentumBounce: void 0,
        startMoving: void 0,
        pointerId: null,
        touchId: null,
      },
      // Clicks
      allowClick: true,
      // Touches
      allowTouchMove: swiper.params.allowTouchMove,
      touches: {
        startX: 0,
        startY: 0,
        currentX: 0,
        currentY: 0,
        diff: 0,
      },
      // Images
      imagesToLoad: [],
      imagesLoaded: 0,
    });
    swiper.emit('_swiper');
    if (swiper.params.init) {
      swiper.init();
    }
    return swiper;
  }

  getDirectionLabel(property) {
    if (this.isHorizontal()) {
      return property;
    }
    return {
      'width': 'height',
      'margin-top': 'margin-left',
      'margin-bottom ': 'margin-right',
      'margin-left': 'margin-top',
      'margin-right': 'margin-bottom',
      'padding-left': 'padding-top',
      'padding-right': 'padding-bottom',
      'marginRight': 'marginBottom',
    }[property];
  }

  getSlideIndex(slideEl) {
    const {
      slidesEl,
      params,
    } = this;
    const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
    const firstSlideIndex = elementIndex(slides[0]);
    return elementIndex(slideEl) - firstSlideIndex;
  }

  getSlideIndexByData(index) {
    return this.getSlideIndex(this.slides.filter((slideEl) => slideEl.getAttribute('data-swiper-slide-index') * 1 === index)[0]);
  }

  recalcSlides() {
    const swiper = this;
    const {
      slidesEl,
      params,
    } = swiper;
    swiper.slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
  }

  enable() {
    const swiper = this;
    if (swiper.enabled)
      return;
    swiper.enabled = true;
    if (swiper.params.grabCursor) {
      swiper.setGrabCursor();
    }
    swiper.emit('enable');
  }

  disable() {
    const swiper = this;
    if (!swiper.enabled)
      return;
    swiper.enabled = false;
    if (swiper.params.grabCursor) {
      swiper.unsetGrabCursor();
    }
    swiper.emit('disable');
  }

  setProgress(progress, speed) {
    const swiper = this;
    progress = Math.min(Math.max(progress, 0), 1);
    const min = swiper.minTranslate();
    const max = swiper.maxTranslate();
    const current = (max - min) * progress + min;
    swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }

  emitContainerClasses() {
    const swiper = this;
    if (!swiper.params._emitClasses || !swiper.el)
      return;
    const cls = swiper.el.className.split(' ').filter((className) => {
      return className.indexOf('swiper') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
    });
    swiper.emit('_containerClasses', cls.join(' '));
  }

  getSlideClasses(slideEl) {
    const swiper = this;
    if (swiper.destroyed)
      return '';
    return slideEl.className.split(' ').filter((className) => {
      return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;
    }).join(' ');
  }

  emitSlidesClasses() {
    const swiper = this;
    if (!swiper.params._emitClasses || !swiper.el)
      return;
    const updates = [];
    swiper.slides.forEach((slideEl) => {
      const classNames = swiper.getSlideClasses(slideEl);
      updates.push({
        slideEl,
        classNames,
      });
      swiper.emit('_slideClass', slideEl, classNames);
    });
    swiper.emit('_slideClasses', updates);
  }

  slidesPerViewDynamic(view, exact) {
    if (view === void 0) {
      view = 'current';
    }
    if (exact === void 0) {
      exact = false;
    }
    const swiper = this;
    const {
      params,
      slides,
      slidesGrid,
      slidesSizesGrid,
      size: swiperSize,
      activeIndex,
    } = swiper;
    let spv = 1;
    if (typeof params.slidesPerView === 'number')
      return params.slidesPerView;
    if (params.centeredSlides) {
      let slideSize = slides[activeIndex] ? Math.ceil(slides[activeIndex].swiperSlideSize) : 0;
      let breakLoop;
      for (let i = activeIndex + 1; i < slides.length; i += 1) {
        if (slides[i] && !breakLoop) {
          slideSize += Math.ceil(slides[i].swiperSlideSize);
          spv += 1;
          if (slideSize > swiperSize)
            breakLoop = true;
        }
      }
      for (let i = activeIndex - 1; i >= 0; i -= 1) {
        if (slides[i] && !breakLoop) {
          slideSize += slides[i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize)
            breakLoop = true;
        }
      }
    } else {
      if (view === 'current') {
        for (let i = activeIndex + 1; i < slides.length; i += 1) {
          const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;
          if (slideInView) {
            spv += 1;
          }
        }
      } else {
        for (let i = activeIndex - 1; i >= 0; i -= 1) {
          const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;
          if (slideInView) {
            spv += 1;
          }
        }
      }
    }
    return spv;
  }

  update() {
    const swiper = this;
    if (!swiper || swiper.destroyed)
      return;
    const {
      snapGrid,
      params,
    } = swiper;
    if (params.breakpoints) {
      swiper.setBreakpoint();
    }
    [...swiper.el.querySelectorAll('[loading="lazy"]')].forEach((imageEl) => {
      if (imageEl.complete) {
        processLazyPreloader(swiper, imageEl);
      }
    });
    swiper.updateSize();
    swiper.updateSlides();
    swiper.updateProgress();
    swiper.updateSlidesClasses();
    function setTranslate2() {
      const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
      const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
      swiper.setTranslate(newTranslate);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    let translated;
    if (params.freeMode && params.freeMode.enabled && !params.cssMode) {
      setTranslate2();
      if (params.autoHeight) {
        swiper.updateAutoHeight();
      }
    } else {
      if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !params.centeredSlides) {
        const slides = swiper.virtual && params.virtual.enabled ? swiper.virtual.slides : swiper.slides;
        translated = swiper.slideTo(slides.length - 1, 0, false, true);
      } else {
        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
      }
      if (!translated) {
        setTranslate2();
      }
    }
    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
      swiper.checkOverflow();
    }
    swiper.emit('update');
  }

  changeDirection(newDirection, needUpdate) {
    if (needUpdate === void 0) {
      needUpdate = true;
    }
    const swiper = this;
    const currentDirection = swiper.params.direction;
    if (!newDirection) {
      newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
    }
    if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {
      return swiper;
    }
    swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);
    swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);
    swiper.emitContainerClasses();
    swiper.params.direction = newDirection;
    swiper.slides.forEach((slideEl) => {
      if (newDirection === 'vertical') {
        slideEl.style.width = '';
      } else {
        slideEl.style.height = '';
      }
    });
    swiper.emit('changeDirection');
    if (needUpdate)
      swiper.update();
    return swiper;
  }

  changeLanguageDirection(direction) {
    const swiper = this;
    if (swiper.rtl && direction === 'rtl' || !swiper.rtl && direction === 'ltr')
      return;
    swiper.rtl = direction === 'rtl';
    swiper.rtlTranslate = swiper.params.direction === 'horizontal' && swiper.rtl;
    if (swiper.rtl) {
      swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);
      swiper.el.dir = 'rtl';
    } else {
      swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);
      swiper.el.dir = 'ltr';
    }
    swiper.update();
  }

  mount(element) {
    const swiper = this;
    if (swiper.mounted)
      return true;
    let el = element || swiper.params.el;
    if (typeof el === 'string') {
      el = document.querySelector(el);
    }
    if (!el) {
      return false;
    }
    el.swiper = swiper;
    if (el.parentNode && el.parentNode.host && el.parentNode.host.nodeName === swiper.params.swiperElementNodeName.toUpperCase()) {
      swiper.isElement = true;
    }
    const getWrapperSelector = () => {
      return `.${(swiper.params.wrapperClass || '').trim().split(' ').join('.')}`;
    };
    const getWrapper = () => {
      if (el && el.shadowRoot && el.shadowRoot.querySelector) {
        const res = el.shadowRoot.querySelector(getWrapperSelector());
        return res;
      }
      return elementChildren(el, getWrapperSelector())[0];
    };
    let wrapperEl = getWrapper();
    if (!wrapperEl && swiper.params.createElements) {
      wrapperEl = createElement('div', swiper.params.wrapperClass);
      el.append(wrapperEl);
      elementChildren(el, `.${swiper.params.slideClass}`).forEach((slideEl) => {
        wrapperEl.append(slideEl);
      });
    }
    Object.assign(swiper, {
      el,
      wrapperEl,
      slidesEl: swiper.isElement && !el.parentNode.host.slideSlots ? el.parentNode.host : wrapperEl,
      hostEl: swiper.isElement ? el.parentNode.host : el,
      mounted: true,
      // RTL
      rtl: el.dir.toLowerCase() === 'rtl' || elementStyle(el, 'direction') === 'rtl',
      rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || elementStyle(el, 'direction') === 'rtl'),
      wrongRTL: elementStyle(wrapperEl, 'display') === '-webkit-box',
    });
    return true;
  }

  init(el) {
    const swiper = this;
    if (swiper.initialized)
      return swiper;
    const mounted = swiper.mount(el);
    if (mounted === false)
      return swiper;
    swiper.emit('beforeInit');
    if (swiper.params.breakpoints) {
      swiper.setBreakpoint();
    }
    swiper.addClasses();
    swiper.updateSize();
    swiper.updateSlides();
    if (swiper.params.watchOverflow) {
      swiper.checkOverflow();
    }
    if (swiper.params.grabCursor && swiper.enabled) {
      swiper.setGrabCursor();
    }
    if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
      swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true);
    } else {
      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
    }
    if (swiper.params.loop) {
      swiper.loopCreate();
    }
    swiper.attachEvents();
    const lazyElements = [...swiper.el.querySelectorAll('[loading="lazy"]')];
    if (swiper.isElement) {
      lazyElements.push(...swiper.hostEl.querySelectorAll('[loading="lazy"]'));
    }
    lazyElements.forEach((imageEl) => {
      if (imageEl.complete) {
        processLazyPreloader(swiper, imageEl);
      } else {
        imageEl.addEventListener('load', (e) => {
          processLazyPreloader(swiper, e.target);
        });
      }
    });
    preload(swiper);
    swiper.initialized = true;
    preload(swiper);
    swiper.emit('init');
    swiper.emit('afterInit');
    return swiper;
  }

  destroy(deleteInstance, cleanStyles) {
    if (deleteInstance === void 0) {
      deleteInstance = true;
    }
    if (cleanStyles === void 0) {
      cleanStyles = true;
    }
    const swiper = this;
    const {
      params,
      el,
      wrapperEl,
      slides,
    } = swiper;
    if (typeof swiper.params === 'undefined' || swiper.destroyed) {
      return null;
    }
    swiper.emit('beforeDestroy');
    swiper.initialized = false;
    swiper.detachEvents();
    if (params.loop) {
      swiper.loopDestroy();
    }
    if (cleanStyles) {
      swiper.removeClasses();
      el.removeAttribute('style');
      wrapperEl.removeAttribute('style');
      if (slides && slides.length) {
        slides.forEach((slideEl) => {
          slideEl.classList.remove(params.slideVisibleClass, params.slideFullyVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
          slideEl.removeAttribute('style');
          slideEl.removeAttribute('data-swiper-slide-index');
        });
      }
    }
    swiper.emit('destroy');
    Object.keys(swiper.eventsListeners).forEach((eventName) => {
      swiper.off(eventName);
    });
    if (deleteInstance !== false) {
      swiper.el.swiper = null;
      deleteProps(swiper);
    }
    swiper.destroyed = true;
    return null;
  }

  static extendDefaults(newDefaults) {
    extend(extendedDefaults, newDefaults);
  }

  static get extendedDefaults() {
    return extendedDefaults;
  }

  static get defaults() {
    return defaults;
  }

  static installModule(mod) {
    if (!Swiper.prototype.__modules__)
      Swiper.prototype.__modules__ = [];
    const modules = Swiper.prototype.__modules__;
    if (typeof mod === 'function' && modules.indexOf(mod) < 0) {
      modules.push(mod);
    }
  }

  static use(module) {
    if (Array.isArray(module)) {
      module.forEach((m) => Swiper.installModule(m));
      return Swiper;
    }
    Swiper.installModule(module);
    return Swiper;
  }
}
Object.keys(prototypes).forEach((prototypeGroup) => {
  Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {
    Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
  });
});
Swiper.use([Resize, Observer]);
function Keyboard(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit,
  } = _ref;
  const document2 = getDocument();
  const window2 = getWindow();
  swiper.keyboard = {
    enabled: false,
  };
  extendParams({
    keyboard: {
      enabled: false,
      onlyInViewport: true,
      pageUpDown: true,
    },
  });
  function handle(event2) {
    if (!swiper.enabled)
      return;
    const {
      rtlTranslate: rtl,
    } = swiper;
    let e = event2;
    if (e.originalEvent)
      e = e.originalEvent;
    const kc = e.keyCode || e.charCode;
    const pageUpDown = swiper.params.keyboard.pageUpDown;
    const isPageUp = pageUpDown && kc === 33;
    const isPageDown = pageUpDown && kc === 34;
    const isArrowLeft = kc === 37;
    const isArrowRight = kc === 39;
    const isArrowUp = kc === 38;
    const isArrowDown = kc === 40;
    if (!swiper.allowSlideNext && (swiper.isHorizontal() && isArrowRight || swiper.isVertical() && isArrowDown || isPageDown)) {
      return false;
    }
    if (!swiper.allowSlidePrev && (swiper.isHorizontal() && isArrowLeft || swiper.isVertical() && isArrowUp || isPageUp)) {
      return false;
    }
    if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
      return void 0;
    }
    if (document2.activeElement && document2.activeElement.nodeName && (document2.activeElement.nodeName.toLowerCase() === 'input' || document2.activeElement.nodeName.toLowerCase() === 'textarea')) {
      return void 0;
    }
    if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {
      let inView = false;
      if (elementParents(swiper.el, `.${swiper.params.slideClass}, swiper-slide`).length > 0 && elementParents(swiper.el, `.${swiper.params.slideActiveClass}`).length === 0) {
        return void 0;
      }
      const el = swiper.el;
      const swiperWidth = el.clientWidth;
      const swiperHeight = el.clientHeight;
      const windowWidth = window2.innerWidth;
      const windowHeight = window2.innerHeight;
      const swiperOffset = elementOffset(el);
      if (rtl)
        swiperOffset.left -= el.scrollLeft;
      const swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiperWidth, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiperHeight], [swiperOffset.left + swiperWidth, swiperOffset.top + swiperHeight]];
      for (let i = 0; i < swiperCoord.length; i += 1) {
        const point = swiperCoord[i];
        if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {
          if (point[0] === 0 && point[1] === 0)
            continue;
          inView = true;
        }
      }
      if (!inView)
        return void 0;
    }
    if (swiper.isHorizontal()) {
      if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {
        if (e.preventDefault)
          e.preventDefault();
        else
          e.returnValue = false;
      }
      if ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl)
        swiper.slideNext();
      if ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl)
        swiper.slidePrev();
    } else {
      if (isPageUp || isPageDown || isArrowUp || isArrowDown) {
        if (e.preventDefault)
          e.preventDefault();
        else
          e.returnValue = false;
      }
      if (isPageDown || isArrowDown)
        swiper.slideNext();
      if (isPageUp || isArrowUp)
        swiper.slidePrev();
    }
    emit('keyPress', kc);
    return void 0;
  }
  function enable() {
    if (swiper.keyboard.enabled)
      return;
    document2.addEventListener('keydown', handle);
    swiper.keyboard.enabled = true;
  }
  function disable() {
    if (!swiper.keyboard.enabled)
      return;
    document2.removeEventListener('keydown', handle);
    swiper.keyboard.enabled = false;
  }
  on('init', () => {
    if (swiper.params.keyboard.enabled) {
      enable();
    }
  });
  on('destroy', () => {
    if (swiper.keyboard.enabled) {
      disable();
    }
  });
  Object.assign(swiper.keyboard, {
    enable,
    disable,
  });
}
function Mousewheel(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit,
  } = _ref;
  const window2 = getWindow();
  extendParams({
    mousewheel: {
      enabled: false,
      releaseOnEdges: false,
      invert: false,
      forceToAxis: false,
      sensitivity: 1,
      eventsTarget: 'container',
      thresholdDelta: null,
      thresholdTime: null,
      noMousewheelClass: 'swiper-no-mousewheel',
    },
  });
  swiper.mousewheel = {
    enabled: false,
  };
  let timeout;
  let lastScrollTime = now();
  let lastEventBeforeSnap;
  const recentWheelEvents = [];
  function normalize(e) {
    const PIXEL_STEP = 10;
    const LINE_HEIGHT = 40;
    const PAGE_HEIGHT = 800;
    let sX = 0;
    let sY = 0;
    let pX = 0;
    let pY = 0;
    if ('detail' in e) {
      sY = e.detail;
    }
    if ('wheelDelta' in e) {
      sY = -e.wheelDelta / 120;
    }
    if ('wheelDeltaY' in e) {
      sY = -e.wheelDeltaY / 120;
    }
    if ('wheelDeltaX' in e) {
      sX = -e.wheelDeltaX / 120;
    }
    if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {
      sX = sY;
      sY = 0;
    }
    pX = sX * PIXEL_STEP;
    pY = sY * PIXEL_STEP;
    if ('deltaY' in e) {
      pY = e.deltaY;
    }
    if ('deltaX' in e) {
      pX = e.deltaX;
    }
    if (e.shiftKey && !pX) {
      pX = pY;
      pY = 0;
    }
    if ((pX || pY) && e.deltaMode) {
      if (e.deltaMode === 1) {
        pX *= LINE_HEIGHT;
        pY *= LINE_HEIGHT;
      } else {
        pX *= PAGE_HEIGHT;
        pY *= PAGE_HEIGHT;
      }
    }
    if (pX && !sX) {
      sX = pX < 1 ? -1 : 1;
    }
    if (pY && !sY) {
      sY = pY < 1 ? -1 : 1;
    }
    return {
      spinX: sX,
      spinY: sY,
      pixelX: pX,
      pixelY: pY,
    };
  }
  function handleMouseEnter() {
    if (!swiper.enabled)
      return;
    swiper.mouseEntered = true;
  }
  function handleMouseLeave() {
    if (!swiper.enabled)
      return;
    swiper.mouseEntered = false;
  }
  function animateSlider(newEvent) {
    if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {
      return false;
    }
    if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {
      return false;
    }
    if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {
      return true;
    }
    if (newEvent.direction < 0) {
      if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
        swiper.slideNext();
        emit('scroll', newEvent.raw);
      }
    } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
      swiper.slidePrev();
      emit('scroll', newEvent.raw);
    }
    lastScrollTime = new window2.Date().getTime();
    return false;
  }
  function releaseScroll(newEvent) {
    const params = swiper.params.mousewheel;
    if (newEvent.direction < 0) {
      if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {
        return true;
      }
    } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {
      return true;
    }
    return false;
  }
  function handle(event2) {
    let e = event2;
    let disableParentSwiper = true;
    if (!swiper.enabled)
      return;
    if (event2.target.closest(`.${swiper.params.mousewheel.noMousewheelClass}`))
      return;
    const params = swiper.params.mousewheel;
    if (swiper.params.cssMode) {
      e.preventDefault();
    }
    let targetEl = swiper.el;
    if (swiper.params.mousewheel.eventsTarget !== 'container') {
      targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);
    }
    const targetElContainsTarget = targetEl && targetEl.contains(e.target);
    if (!swiper.mouseEntered && !targetElContainsTarget && !params.releaseOnEdges)
      return true;
    if (e.originalEvent)
      e = e.originalEvent;
    let delta = 0;
    const rtlFactor = swiper.rtlTranslate ? -1 : 1;
    const data = normalize(e);
    if (params.forceToAxis) {
      if (swiper.isHorizontal()) {
        if (Math.abs(data.pixelX) > Math.abs(data.pixelY))
          delta = -data.pixelX * rtlFactor;
        else
          return true;
      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX))
        delta = -data.pixelY;
      else
        return true;
    } else {
      delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
    }
    if (delta === 0)
      return true;
    if (params.invert)
      delta = -delta;
    let positions = swiper.getTranslate() + delta * params.sensitivity;
    if (positions >= swiper.minTranslate())
      positions = swiper.minTranslate();
    if (positions <= swiper.maxTranslate())
      positions = swiper.maxTranslate();
    disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());
    if (disableParentSwiper && swiper.params.nested)
      e.stopPropagation();
    if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {
      const newEvent = {
        time: now(),
        delta: Math.abs(delta),
        direction: Math.sign(delta),
        raw: event2,
      };
      if (recentWheelEvents.length >= 2) {
        recentWheelEvents.shift();
      }
      const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : void 0;
      recentWheelEvents.push(newEvent);
      if (prevEvent) {
        if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {
          animateSlider(newEvent);
        }
      } else {
        animateSlider(newEvent);
      }
      if (releaseScroll(newEvent)) {
        return true;
      }
    } else {
      const newEvent = {
        time: now(),
        delta: Math.abs(delta),
        direction: Math.sign(delta),
      };
      const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;
      if (!ignoreWheelEvents) {
        lastEventBeforeSnap = void 0;
        let position = swiper.getTranslate() + delta * params.sensitivity;
        const wasBeginning = swiper.isBeginning;
        const wasEnd = swiper.isEnd;
        if (position >= swiper.minTranslate())
          position = swiper.minTranslate();
        if (position <= swiper.maxTranslate())
          position = swiper.maxTranslate();
        swiper.setTransition(0);
        swiper.setTranslate(position);
        swiper.updateProgress();
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
        if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {
          swiper.updateSlidesClasses();
        }
        if (swiper.params.loop) {
          swiper.loopFix({
            direction: newEvent.direction < 0 ? 'next' : 'prev',
            byMousewheel: true,
          });
        }
        if (swiper.params.freeMode.sticky) {
          clearTimeout(timeout);
          timeout = void 0;
          if (recentWheelEvents.length >= 15) {
            recentWheelEvents.shift();
          }
          const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : void 0;
          const firstEvent = recentWheelEvents[0];
          recentWheelEvents.push(newEvent);
          if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {
            recentWheelEvents.splice(0);
          } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {
            const snapToThreshold = delta > 0 ? 0.8 : 0.2;
            lastEventBeforeSnap = newEvent;
            recentWheelEvents.splice(0);
            timeout = nextTick(() => {
              swiper.slideToClosest(swiper.params.speed, true, void 0, snapToThreshold);
            }, 0);
          }
          if (!timeout) {
            timeout = nextTick(() => {
              const snapToThreshold = 0.5;
              lastEventBeforeSnap = newEvent;
              recentWheelEvents.splice(0);
              swiper.slideToClosest(swiper.params.speed, true, void 0, snapToThreshold);
            }, 500);
          }
        }
        if (!ignoreWheelEvents)
          emit('scroll', e);
        if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction)
          swiper.autoplay.stop();
        if (params.releaseOnEdges && (position === swiper.minTranslate() || position === swiper.maxTranslate())) {
          return true;
        }
      }
    }
    if (e.preventDefault)
      e.preventDefault();
    else
      e.returnValue = false;
    return false;
  }
  function events2(method) {
    let targetEl = swiper.el;
    if (swiper.params.mousewheel.eventsTarget !== 'container') {
      targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);
    }
    targetEl[method]('mouseenter', handleMouseEnter);
    targetEl[method]('mouseleave', handleMouseLeave);
    targetEl[method]('wheel', handle);
  }
  function enable() {
    if (swiper.params.cssMode) {
      swiper.wrapperEl.removeEventListener('wheel', handle);
      return true;
    }
    if (swiper.mousewheel.enabled)
      return false;
    events2('addEventListener');
    swiper.mousewheel.enabled = true;
    return true;
  }
  function disable() {
    if (swiper.params.cssMode) {
      swiper.wrapperEl.addEventListener(event, handle);
      return true;
    }
    if (!swiper.mousewheel.enabled)
      return false;
    events2('removeEventListener');
    swiper.mousewheel.enabled = false;
    return true;
  }
  on('init', () => {
    if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {
      disable();
    }
    if (swiper.params.mousewheel.enabled)
      enable();
  });
  on('destroy', () => {
    if (swiper.params.cssMode) {
      enable();
    }
    if (swiper.mousewheel.enabled)
      disable();
  });
  Object.assign(swiper.mousewheel, {
    enable,
    disable,
  });
}
function createElementIfNotDefined(swiper, originalParams, params, checkProps) {
  if (swiper.params.createElements) {
    Object.keys(checkProps).forEach((key) => {
      if (!params[key] && params.auto === true) {
        let element = elementChildren(swiper.el, `.${checkProps[key]}`)[0];
        if (!element) {
          element = createElement('div', checkProps[key]);
          element.className = checkProps[key];
          swiper.el.append(element);
        }
        params[key] = element;
        originalParams[key] = element;
      }
    });
  }
  return params;
}
function Navigation(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit,
  } = _ref;
  extendParams({
    navigation: {
      nextEl: null,
      prevEl: null,
      hideOnClick: false,
      disabledClass: 'swiper-button-disabled',
      hiddenClass: 'swiper-button-hidden',
      lockClass: 'swiper-button-lock',
      navigationDisabledClass: 'swiper-navigation-disabled',
    },
  });
  swiper.navigation = {
    nextEl: null,
    prevEl: null,
  };
  function getEl(el) {
    let res;
    if (el && typeof el === 'string' && swiper.isElement) {
      res = swiper.el.querySelector(el);
      if (res)
        return res;
    }
    if (el) {
      if (typeof el === 'string')
        res = [...document.querySelectorAll(el)];
      if (swiper.params.uniqueNavElements && typeof el === 'string' && res && res.length > 1 && swiper.el.querySelectorAll(el).length === 1) {
        res = swiper.el.querySelector(el);
      } else if (res && res.length === 1) {
        res = res[0];
      }
    }
    if (el && !res)
      return el;
    return res;
  }
  function toggleEl(el, disabled) {
    const params = swiper.params.navigation;
    el = makeElementsArray(el);
    el.forEach((subEl) => {
      if (subEl) {
        subEl.classList[disabled ? 'add' : 'remove'](...params.disabledClass.split(' '));
        if (subEl.tagName === 'BUTTON')
          subEl.disabled = disabled;
        if (swiper.params.watchOverflow && swiper.enabled) {
          subEl.classList[swiper.isLocked ? 'add' : 'remove'](params.lockClass);
        }
      }
    });
  }
  function update2() {
    const {
      nextEl,
      prevEl,
    } = swiper.navigation;
    if (swiper.params.loop) {
      toggleEl(prevEl, false);
      toggleEl(nextEl, false);
      return;
    }
    toggleEl(prevEl, swiper.isBeginning && !swiper.params.rewind);
    toggleEl(nextEl, swiper.isEnd && !swiper.params.rewind);
  }
  function onPrevClick(e) {
    e.preventDefault();
    if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind)
      return;
    swiper.slidePrev();
    emit('navigationPrev');
  }
  function onNextClick(e) {
    e.preventDefault();
    if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind)
      return;
    swiper.slideNext();
    emit('navigationNext');
  }
  function init() {
    const params = swiper.params.navigation;
    swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
      nextEl: 'swiper-button-next',
      prevEl: 'swiper-button-prev',
    });
    if (!(params.nextEl || params.prevEl))
      return;
    let nextEl = getEl(params.nextEl);
    let prevEl = getEl(params.prevEl);
    Object.assign(swiper.navigation, {
      nextEl,
      prevEl,
    });
    nextEl = makeElementsArray(nextEl);
    prevEl = makeElementsArray(prevEl);
    const initButton = (el, dir) => {
      if (el) {
        el.addEventListener('click', dir === 'next' ? onNextClick : onPrevClick);
      }
      if (!swiper.enabled && el) {
        el.classList.add(...params.lockClass.split(' '));
      }
    };
    nextEl.forEach((el) => initButton(el, 'next'));
    prevEl.forEach((el) => initButton(el, 'prev'));
  }
  function destroy() {
    let {
      nextEl,
      prevEl,
    } = swiper.navigation;
    nextEl = makeElementsArray(nextEl);
    prevEl = makeElementsArray(prevEl);
    const destroyButton = (el, dir) => {
      el.removeEventListener('click', dir === 'next' ? onNextClick : onPrevClick);
      el.classList.remove(...swiper.params.navigation.disabledClass.split(' '));
    };
    nextEl.forEach((el) => destroyButton(el, 'next'));
    prevEl.forEach((el) => destroyButton(el, 'prev'));
  }
  on('init', () => {
    if (swiper.params.navigation.enabled === false) {
      disable();
    } else {
      init();
      update2();
    }
  });
  on('toEdge fromEdge lock unlock', () => {
    update2();
  });
  on('destroy', () => {
    destroy();
  });
  on('enable disable', () => {
    let {
      nextEl,
      prevEl,
    } = swiper.navigation;
    nextEl = makeElementsArray(nextEl);
    prevEl = makeElementsArray(prevEl);
    if (swiper.enabled) {
      update2();
      return;
    }
    [...nextEl, ...prevEl].filter((el) => !!el).forEach((el) => el.classList.add(swiper.params.navigation.lockClass));
  });
  on('click', (_s, e) => {
    let {
      nextEl,
      prevEl,
    } = swiper.navigation;
    nextEl = makeElementsArray(nextEl);
    prevEl = makeElementsArray(prevEl);
    const targetEl = e.target;
    if (swiper.params.navigation.hideOnClick && !prevEl.includes(targetEl) && !nextEl.includes(targetEl)) {
      if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl)))
        return;
      let isHidden;
      if (nextEl.length) {
        isHidden = nextEl[0].classList.contains(swiper.params.navigation.hiddenClass);
      } else if (prevEl.length) {
        isHidden = prevEl[0].classList.contains(swiper.params.navigation.hiddenClass);
      }
      if (isHidden === true) {
        emit('navigationShow');
      } else {
        emit('navigationHide');
      }
      [...nextEl, ...prevEl].filter((el) => !!el).forEach((el) => el.classList.toggle(swiper.params.navigation.hiddenClass));
    }
  });
  const enable = () => {
    swiper.el.classList.remove(...swiper.params.navigation.navigationDisabledClass.split(' '));
    init();
    update2();
  };
  const disable = () => {
    swiper.el.classList.add(...swiper.params.navigation.navigationDisabledClass.split(' '));
    destroy();
  };
  Object.assign(swiper.navigation, {
    enable,
    disable,
    update: update2,
    init,
    destroy,
  });
}
function classesToSelector(classes2) {
  if (classes2 === void 0) {
    classes2 = '';
  }
  return `.${classes2.trim().replace(/([\.:!+\/])/g, '\\$1').replace(/ /g, '.')}`;
}
function Pagination(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit,
  } = _ref;
  const pfx = 'swiper-pagination';
  extendParams({
    pagination: {
      el: null,
      bulletElement: 'span',
      clickable: false,
      hideOnClick: false,
      renderBullet: null,
      renderProgressbar: null,
      renderFraction: null,
      renderCustom: null,
      progressbarOpposite: false,
      type: 'bullets',
      // 'bullets' or 'progressbar' or 'fraction' or 'custom'
      dynamicBullets: false,
      dynamicMainBullets: 1,
      formatFractionCurrent: (number) => number,
      formatFractionTotal: (number) => number,
      bulletClass: `${pfx}-bullet`,
      bulletActiveClass: `${pfx}-bullet-active`,
      modifierClass: `${pfx}-`,
      currentClass: `${pfx}-current`,
      totalClass: `${pfx}-total`,
      hiddenClass: `${pfx}-hidden`,
      progressbarFillClass: `${pfx}-progressbar-fill`,
      progressbarOppositeClass: `${pfx}-progressbar-opposite`,
      clickableClass: `${pfx}-clickable`,
      lockClass: `${pfx}-lock`,
      horizontalClass: `${pfx}-horizontal`,
      verticalClass: `${pfx}-vertical`,
      paginationDisabledClass: `${pfx}-disabled`,
    },
  });
  swiper.pagination = {
    el: null,
    bullets: [],
  };
  let bulletSize;
  let dynamicBulletIndex = 0;
  function isPaginationDisabled() {
    return !swiper.params.pagination.el || !swiper.pagination.el || Array.isArray(swiper.pagination.el) && swiper.pagination.el.length === 0;
  }
  function setSideBullets(bulletEl, position) {
    const {
      bulletActiveClass,
    } = swiper.params.pagination;
    if (!bulletEl)
      return;
    bulletEl = bulletEl[`${position === 'prev' ? 'previous' : 'next'}ElementSibling`];
    if (bulletEl) {
      bulletEl.classList.add(`${bulletActiveClass}-${position}`);
      bulletEl = bulletEl[`${position === 'prev' ? 'previous' : 'next'}ElementSibling`];
      if (bulletEl) {
        bulletEl.classList.add(`${bulletActiveClass}-${position}-${position}`);
      }
    }
  }
  function onBulletClick(e) {
    const bulletEl = e.target.closest(classesToSelector(swiper.params.pagination.bulletClass));
    if (!bulletEl) {
      return;
    }
    e.preventDefault();
    const index = elementIndex(bulletEl) * swiper.params.slidesPerGroup;
    if (swiper.params.loop) {
      if (swiper.realIndex === index)
        return;
      swiper.slideToLoop(index);
    } else {
      swiper.slideTo(index);
    }
  }
  function update2() {
    const rtl = swiper.rtl;
    const params = swiper.params.pagination;
    if (isPaginationDisabled())
      return;
    let el = swiper.pagination.el;
    el = makeElementsArray(el);
    let current;
    let previousIndex;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
    const total = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
    if (swiper.params.loop) {
      previousIndex = swiper.previousRealIndex || 0;
      current = swiper.params.slidesPerGroup > 1 ? Math.floor(swiper.realIndex / swiper.params.slidesPerGroup) : swiper.realIndex;
    } else if (typeof swiper.snapIndex !== 'undefined') {
      current = swiper.snapIndex;
      previousIndex = swiper.previousSnapIndex;
    } else {
      previousIndex = swiper.previousIndex || 0;
      current = swiper.activeIndex || 0;
    }
    if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
      const bullets = swiper.pagination.bullets;
      let firstIndex;
      let lastIndex;
      let midIndex;
      if (params.dynamicBullets) {
        bulletSize = elementOuterSize(bullets[0], swiper.isHorizontal() ? 'width' : 'height');
        el.forEach((subEl) => {
          subEl.style[swiper.isHorizontal() ? 'width' : 'height'] = `${bulletSize * (params.dynamicMainBullets + 4)}px`;
        });
        if (params.dynamicMainBullets > 1 && previousIndex !== void 0) {
          dynamicBulletIndex += current - (previousIndex || 0);
          if (dynamicBulletIndex > params.dynamicMainBullets - 1) {
            dynamicBulletIndex = params.dynamicMainBullets - 1;
          } else if (dynamicBulletIndex < 0) {
            dynamicBulletIndex = 0;
          }
        }
        firstIndex = Math.max(current - dynamicBulletIndex, 0);
        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
        midIndex = (lastIndex + firstIndex) / 2;
      }
      bullets.forEach((bulletEl) => {
        const classesToRemove = [...['', '-next', '-next-next', '-prev', '-prev-prev', '-main'].map((suffix) => `${params.bulletActiveClass}${suffix}`)].map((s) => typeof s === 'string' && s.includes(' ') ? s.split(' ') : s).flat();
        bulletEl.classList.remove(...classesToRemove);
      });
      if (el.length > 1) {
        bullets.forEach((bullet) => {
          const bulletIndex = elementIndex(bullet);
          if (bulletIndex === current) {
            bullet.classList.add(...params.bulletActiveClass.split(' '));
          } else if (swiper.isElement) {
            bullet.setAttribute('part', 'bullet');
          }
          if (params.dynamicBullets) {
            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
              bullet.classList.add(...`${params.bulletActiveClass}-main`.split(' '));
            }
            if (bulletIndex === firstIndex) {
              setSideBullets(bullet, 'prev');
            }
            if (bulletIndex === lastIndex) {
              setSideBullets(bullet, 'next');
            }
          }
        });
      } else {
        const bullet = bullets[current];
        if (bullet) {
          bullet.classList.add(...params.bulletActiveClass.split(' '));
        }
        if (swiper.isElement) {
          bullets.forEach((bulletEl, bulletIndex) => {
            bulletEl.setAttribute('part', bulletIndex === current ? 'bullet-active' : 'bullet');
          });
        }
        if (params.dynamicBullets) {
          const firstDisplayedBullet = bullets[firstIndex];
          const lastDisplayedBullet = bullets[lastIndex];
          for (let i = firstIndex; i <= lastIndex; i += 1) {
            if (bullets[i]) {
              bullets[i].classList.add(...`${params.bulletActiveClass}-main`.split(' '));
            }
          }
          setSideBullets(firstDisplayedBullet, 'prev');
          setSideBullets(lastDisplayedBullet, 'next');
        }
      }
      if (params.dynamicBullets) {
        const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
        const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
        const offsetProp = rtl ? 'right' : 'left';
        bullets.forEach((bullet) => {
          bullet.style[swiper.isHorizontal() ? offsetProp : 'top'] = `${bulletsOffset}px`;
        });
      }
    }
    el.forEach((subEl, subElIndex) => {
      if (params.type === 'fraction') {
        subEl.querySelectorAll(classesToSelector(params.currentClass)).forEach((fractionEl) => {
          fractionEl.textContent = params.formatFractionCurrent(current + 1);
        });
        subEl.querySelectorAll(classesToSelector(params.totalClass)).forEach((totalEl) => {
          totalEl.textContent = params.formatFractionTotal(total);
        });
      }
      if (params.type === 'progressbar') {
        let progressbarDirection;
        if (params.progressbarOpposite) {
          progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
        } else {
          progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
        }
        const scale = (current + 1) / total;
        let scaleX = 1;
        let scaleY = 1;
        if (progressbarDirection === 'horizontal') {
          scaleX = scale;
        } else {
          scaleY = scale;
        }
        subEl.querySelectorAll(classesToSelector(params.progressbarFillClass)).forEach((progressEl) => {
          progressEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`;
          progressEl.style.transitionDuration = `${swiper.params.speed}ms`;
        });
      }
      if (params.type === 'custom' && params.renderCustom) {
        subEl.innerHTML = params.renderCustom(swiper, current + 1, total);
        if (subElIndex === 0)
          emit('paginationRender', subEl);
      } else {
        if (subElIndex === 0)
          emit('paginationRender', subEl);
        emit('paginationUpdate', subEl);
      }
      if (swiper.params.watchOverflow && swiper.enabled) {
        subEl.classList[swiper.isLocked ? 'add' : 'remove'](params.lockClass);
      }
    });
  }
  function render() {
    const params = swiper.params.pagination;
    if (isPaginationDisabled())
      return;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.grid && swiper.params.grid.rows > 1 ? swiper.slides.length / Math.ceil(swiper.params.grid.rows) : swiper.slides.length;
    let el = swiper.pagination.el;
    el = makeElementsArray(el);
    let paginationHTML = '';
    if (params.type === 'bullets') {
      let numberOfBullets = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
      if (swiper.params.freeMode && swiper.params.freeMode.enabled && numberOfBullets > slidesLength) {
        numberOfBullets = slidesLength;
      }
      for (let i = 0; i < numberOfBullets; i += 1) {
        if (params.renderBullet) {
          paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
        } else {
          paginationHTML += `<${params.bulletElement} ${swiper.isElement ? 'part="bullet"' : ''} class="${params.bulletClass}"></${params.bulletElement}>`;
        }
      }
    }
    if (params.type === 'fraction') {
      if (params.renderFraction) {
        paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
      } else {
        paginationHTML = `<span class="${params.currentClass}"></span> / <span class="${params.totalClass}"></span>`;
      }
    }
    if (params.type === 'progressbar') {
      if (params.renderProgressbar) {
        paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
      } else {
        paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
      }
    }
    swiper.pagination.bullets = [];
    el.forEach((subEl) => {
      if (params.type !== 'custom') {
        subEl.innerHTML = paginationHTML || '';
      }
      if (params.type === 'bullets') {
        swiper.pagination.bullets.push(...subEl.querySelectorAll(classesToSelector(params.bulletClass)));
      }
    });
    if (params.type !== 'custom') {
      emit('paginationRender', el[0]);
    }
  }
  function init() {
    swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {
      el: 'swiper-pagination',
    });
    const params = swiper.params.pagination;
    if (!params.el)
      return;
    let el;
    if (typeof params.el === 'string' && swiper.isElement) {
      el = swiper.el.querySelector(params.el);
    }
    if (!el && typeof params.el === 'string') {
      el = [...document.querySelectorAll(params.el)];
    }
    if (!el) {
      el = params.el;
    }
    if (!el || el.length === 0)
      return;
    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && Array.isArray(el) && el.length > 1) {
      el = [...swiper.el.querySelectorAll(params.el)];
      if (el.length > 1) {
        el = el.filter((subEl) => {
          if (elementParents(subEl, '.swiper')[0] !== swiper.el)
            return false;
          return true;
        })[0];
      }
    }
    if (Array.isArray(el) && el.length === 1)
      el = el[0];
    Object.assign(swiper.pagination, {
      el,
    });
    el = makeElementsArray(el);
    el.forEach((subEl) => {
      if (params.type === 'bullets' && params.clickable) {
        subEl.classList.add(...(params.clickableClass || '').split(' '));
      }
      subEl.classList.add(params.modifierClass + params.type);
      subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
      if (params.type === 'bullets' && params.dynamicBullets) {
        subEl.classList.add(`${params.modifierClass}${params.type}-dynamic`);
        dynamicBulletIndex = 0;
        if (params.dynamicMainBullets < 1) {
          params.dynamicMainBullets = 1;
        }
      }
      if (params.type === 'progressbar' && params.progressbarOpposite) {
        subEl.classList.add(params.progressbarOppositeClass);
      }
      if (params.clickable) {
        subEl.addEventListener('click', onBulletClick);
      }
      if (!swiper.enabled) {
        subEl.classList.add(params.lockClass);
      }
    });
  }
  function destroy() {
    const params = swiper.params.pagination;
    if (isPaginationDisabled())
      return;
    let el = swiper.pagination.el;
    if (el) {
      el = makeElementsArray(el);
      el.forEach((subEl) => {
        subEl.classList.remove(params.hiddenClass);
        subEl.classList.remove(params.modifierClass + params.type);
        subEl.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
        if (params.clickable) {
          subEl.classList.remove(...(params.clickableClass || '').split(' '));
          subEl.removeEventListener('click', onBulletClick);
        }
      });
    }
    if (swiper.pagination.bullets)
      swiper.pagination.bullets.forEach((subEl) => subEl.classList.remove(...params.bulletActiveClass.split(' ')));
  }
  on('changeDirection', () => {
    if (!swiper.pagination || !swiper.pagination.el)
      return;
    const params = swiper.params.pagination;
    let {
      el,
    } = swiper.pagination;
    el = makeElementsArray(el);
    el.forEach((subEl) => {
      subEl.classList.remove(params.horizontalClass, params.verticalClass);
      subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
    });
  });
  on('init', () => {
    if (swiper.params.pagination.enabled === false) {
      disable();
    } else {
      init();
      render();
      update2();
    }
  });
  on('activeIndexChange', () => {
    if (typeof swiper.snapIndex === 'undefined') {
      update2();
    }
  });
  on('snapIndexChange', () => {
    update2();
  });
  on('snapGridLengthChange', () => {
    render();
    update2();
  });
  on('destroy', () => {
    destroy();
  });
  on('enable disable', () => {
    let {
      el,
    } = swiper.pagination;
    if (el) {
      el = makeElementsArray(el);
      el.forEach((subEl) => subEl.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.pagination.lockClass));
    }
  });
  on('lock unlock', () => {
    update2();
  });
  on('click', (_s, e) => {
    const targetEl = e.target;
    const el = makeElementsArray(swiper.pagination.el);
    if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && el && el.length > 0 && !targetEl.classList.contains(swiper.params.pagination.bulletClass)) {
      if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl))
        return;
      const isHidden = el[0].classList.contains(swiper.params.pagination.hiddenClass);
      if (isHidden === true) {
        emit('paginationShow');
      } else {
        emit('paginationHide');
      }
      el.forEach((subEl) => subEl.classList.toggle(swiper.params.pagination.hiddenClass));
    }
  });
  const enable = () => {
    swiper.el.classList.remove(swiper.params.pagination.paginationDisabledClass);
    let {
      el,
    } = swiper.pagination;
    if (el) {
      el = makeElementsArray(el);
      el.forEach((subEl) => subEl.classList.remove(swiper.params.pagination.paginationDisabledClass));
    }
    init();
    render();
    update2();
  };
  const disable = () => {
    swiper.el.classList.add(swiper.params.pagination.paginationDisabledClass);
    let {
      el,
    } = swiper.pagination;
    if (el) {
      el = makeElementsArray(el);
      el.forEach((subEl) => subEl.classList.add(swiper.params.pagination.paginationDisabledClass));
    }
    destroy();
  };
  Object.assign(swiper.pagination, {
    enable,
    disable,
    render,
    update: update2,
    init,
    destroy,
  });
}
function Scrollbar(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit,
  } = _ref;
  const document2 = getDocument();
  let isTouched = false;
  let timeout = null;
  let dragTimeout = null;
  let dragStartPos;
  let dragSize;
  let trackSize;
  let divider;
  extendParams({
    scrollbar: {
      el: null,
      dragSize: 'auto',
      hide: false,
      draggable: false,
      snapOnRelease: true,
      lockClass: 'swiper-scrollbar-lock',
      dragClass: 'swiper-scrollbar-drag',
      scrollbarDisabledClass: 'swiper-scrollbar-disabled',
      horizontalClass: 'swiper-scrollbar-horizontal',
      verticalClass: 'swiper-scrollbar-vertical',
    },
  });
  swiper.scrollbar = {
    el: null,
    dragEl: null,
  };
  function setTranslate2() {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el)
      return;
    const {
      scrollbar,
      rtlTranslate: rtl,
    } = swiper;
    const {
      dragEl,
      el,
    } = scrollbar;
    const params = swiper.params.scrollbar;
    const progress = swiper.params.loop ? swiper.progressLoop : swiper.progress;
    let newSize = dragSize;
    let newPos = (trackSize - dragSize) * progress;
    if (rtl) {
      newPos = -newPos;
      if (newPos > 0) {
        newSize = dragSize - newPos;
        newPos = 0;
      } else if (-newPos + dragSize > trackSize) {
        newSize = trackSize + newPos;
      }
    } else if (newPos < 0) {
      newSize = dragSize + newPos;
      newPos = 0;
    } else if (newPos + dragSize > trackSize) {
      newSize = trackSize - newPos;
    }
    if (swiper.isHorizontal()) {
      dragEl.style.transform = `translate3d(${newPos}px, 0, 0)`;
      dragEl.style.width = `${newSize}px`;
    } else {
      dragEl.style.transform = `translate3d(0px, ${newPos}px, 0)`;
      dragEl.style.height = `${newSize}px`;
    }
    if (params.hide) {
      clearTimeout(timeout);
      el.style.opacity = 1;
      timeout = setTimeout(() => {
        el.style.opacity = 0;
        el.style.transitionDuration = '400ms';
      }, 1e3);
    }
  }
  function setTransition2(duration) {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el)
      return;
    swiper.scrollbar.dragEl.style.transitionDuration = `${duration}ms`;
  }
  function updateSize2() {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el)
      return;
    const {
      scrollbar,
    } = swiper;
    const {
      dragEl,
      el,
    } = scrollbar;
    dragEl.style.width = '';
    dragEl.style.height = '';
    trackSize = swiper.isHorizontal() ? el.offsetWidth : el.offsetHeight;
    divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));
    if (swiper.params.scrollbar.dragSize === 'auto') {
      dragSize = trackSize * divider;
    } else {
      dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
    }
    if (swiper.isHorizontal()) {
      dragEl.style.width = `${dragSize}px`;
    } else {
      dragEl.style.height = `${dragSize}px`;
    }
    if (divider >= 1) {
      el.style.display = 'none';
    } else {
      el.style.display = '';
    }
    if (swiper.params.scrollbar.hide) {
      el.style.opacity = 0;
    }
    if (swiper.params.watchOverflow && swiper.enabled) {
      scrollbar.el.classList[swiper.isLocked ? 'add' : 'remove'](swiper.params.scrollbar.lockClass);
    }
  }
  function getPointerPosition(e) {
    return swiper.isHorizontal() ? e.clientX : e.clientY;
  }
  function setDragPosition(e) {
    const {
      scrollbar,
      rtlTranslate: rtl,
    } = swiper;
    const {
      el,
    } = scrollbar;
    let positionRatio;
    positionRatio = (getPointerPosition(e) - elementOffset(el)[swiper.isHorizontal() ? 'left' : 'top'] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
    positionRatio = Math.max(Math.min(positionRatio, 1), 0);
    if (rtl) {
      positionRatio = 1 - positionRatio;
    }
    const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
    swiper.updateProgress(position);
    swiper.setTranslate(position);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }
  function onDragStart(e) {
    const params = swiper.params.scrollbar;
    const {
      scrollbar,
      wrapperEl,
    } = swiper;
    const {
      el,
      dragEl,
    } = scrollbar;
    isTouched = true;
    dragStartPos = e.target === dragEl ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;
    e.preventDefault();
    e.stopPropagation();
    wrapperEl.style.transitionDuration = '100ms';
    dragEl.style.transitionDuration = '100ms';
    setDragPosition(e);
    clearTimeout(dragTimeout);
    el.style.transitionDuration = '0ms';
    if (params.hide) {
      el.style.opacity = 1;
    }
    if (swiper.params.cssMode) {
      swiper.wrapperEl.style['scroll-snap-type'] = 'none';
    }
    emit('scrollbarDragStart', e);
  }
  function onDragMove(e) {
    const {
      scrollbar,
      wrapperEl,
    } = swiper;
    const {
      el,
      dragEl,
    } = scrollbar;
    if (!isTouched)
      return;
    if (e.preventDefault && e.cancelable)
      e.preventDefault();
    else
      e.returnValue = false;
    setDragPosition(e);
    wrapperEl.style.transitionDuration = '0ms';
    el.style.transitionDuration = '0ms';
    dragEl.style.transitionDuration = '0ms';
    emit('scrollbarDragMove', e);
  }
  function onDragEnd(e) {
    const params = swiper.params.scrollbar;
    const {
      scrollbar,
      wrapperEl,
    } = swiper;
    const {
      el,
    } = scrollbar;
    if (!isTouched)
      return;
    isTouched = false;
    if (swiper.params.cssMode) {
      swiper.wrapperEl.style['scroll-snap-type'] = '';
      wrapperEl.style.transitionDuration = '';
    }
    if (params.hide) {
      clearTimeout(dragTimeout);
      dragTimeout = nextTick(() => {
        el.style.opacity = 0;
        el.style.transitionDuration = '400ms';
      }, 1e3);
    }
    emit('scrollbarDragEnd', e);
    if (params.snapOnRelease) {
      swiper.slideToClosest();
    }
  }
  function events2(method) {
    const {
      scrollbar,
      params,
    } = swiper;
    const el = scrollbar.el;
    if (!el)
      return;
    const target = el;
    const activeListener = params.passiveListeners ? {
      passive: false,
      capture: false,
    } : false;
    const passiveListener = params.passiveListeners ? {
      passive: true,
      capture: false,
    } : false;
    if (!target)
      return;
    const eventMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';
    target[eventMethod]('pointerdown', onDragStart, activeListener);
    document2[eventMethod]('pointermove', onDragMove, activeListener);
    document2[eventMethod]('pointerup', onDragEnd, passiveListener);
  }
  function enableDraggable() {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el)
      return;
    events2('on');
  }
  function disableDraggable() {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el)
      return;
    events2('off');
  }
  function init() {
    const {
      scrollbar,
      el: swiperEl,
    } = swiper;
    swiper.params.scrollbar = createElementIfNotDefined(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {
      el: 'swiper-scrollbar',
    });
    const params = swiper.params.scrollbar;
    if (!params.el)
      return;
    let el;
    if (typeof params.el === 'string' && swiper.isElement) {
      el = swiper.el.querySelector(params.el);
    }
    if (!el && typeof params.el === 'string') {
      el = document2.querySelectorAll(params.el);
      if (!el.length)
        return;
    } else if (!el) {
      el = params.el;
    }
    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && el.length > 1 && swiperEl.querySelectorAll(params.el).length === 1) {
      el = swiperEl.querySelector(params.el);
    }
    if (el.length > 0)
      el = el[0];
    el.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
    let dragEl;
    if (el) {
      dragEl = el.querySelector(classesToSelector(swiper.params.scrollbar.dragClass));
      if (!dragEl) {
        dragEl = createElement('div', swiper.params.scrollbar.dragClass);
        el.append(dragEl);
      }
    }
    Object.assign(scrollbar, {
      el,
      dragEl,
    });
    if (params.draggable) {
      enableDraggable();
    }
    if (el) {
      el.classList[swiper.enabled ? 'remove' : 'add'](...classesToTokens(swiper.params.scrollbar.lockClass));
    }
  }
  function destroy() {
    const params = swiper.params.scrollbar;
    const el = swiper.scrollbar.el;
    if (el) {
      el.classList.remove(...classesToTokens(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass));
    }
    disableDraggable();
  }
  on('changeDirection', () => {
    if (!swiper.scrollbar || !swiper.scrollbar.el)
      return;
    const params = swiper.params.scrollbar;
    let {
      el,
    } = swiper.scrollbar;
    el = makeElementsArray(el);
    el.forEach((subEl) => {
      subEl.classList.remove(params.horizontalClass, params.verticalClass);
      subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
    });
  });
  on('init', () => {
    if (swiper.params.scrollbar.enabled === false) {
      disable();
    } else {
      init();
      updateSize2();
      setTranslate2();
    }
  });
  on('update resize observerUpdate lock unlock changeDirection', () => {
    updateSize2();
  });
  on('setTranslate', () => {
    setTranslate2();
  });
  on('setTransition', (_s, duration) => {
    setTransition2(duration);
  });
  on('enable disable', () => {
    const {
      el,
    } = swiper.scrollbar;
    if (el) {
      el.classList[swiper.enabled ? 'remove' : 'add'](...classesToTokens(swiper.params.scrollbar.lockClass));
    }
  });
  on('destroy', () => {
    destroy();
  });
  const enable = () => {
    swiper.el.classList.remove(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));
    if (swiper.scrollbar.el) {
      swiper.scrollbar.el.classList.remove(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));
    }
    init();
    updateSize2();
    setTranslate2();
  };
  const disable = () => {
    swiper.el.classList.add(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));
    if (swiper.scrollbar.el) {
      swiper.scrollbar.el.classList.add(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));
    }
    destroy();
  };
  Object.assign(swiper.scrollbar, {
    enable,
    disable,
    updateSize: updateSize2,
    setTranslate: setTranslate2,
    init,
    destroy,
  });
}
function Zoom(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit,
  } = _ref;
  const window2 = getWindow();
  extendParams({
    zoom: {
      enabled: false,
      limitToOriginalSize: false,
      maxRatio: 3,
      minRatio: 1,
      toggle: true,
      containerClass: 'swiper-zoom-container',
      zoomedSlideClass: 'swiper-slide-zoomed',
    },
  });
  swiper.zoom = {
    enabled: false,
  };
  let currentScale = 1;
  let isScaling = false;
  let fakeGestureTouched;
  let fakeGestureMoved;
  const evCache = [];
  const gesture = {
    originX: 0,
    originY: 0,
    slideEl: void 0,
    slideWidth: void 0,
    slideHeight: void 0,
    imageEl: void 0,
    imageWrapEl: void 0,
    maxRatio: 3,
  };
  const image = {
    isTouched: void 0,
    isMoved: void 0,
    currentX: void 0,
    currentY: void 0,
    minX: void 0,
    minY: void 0,
    maxX: void 0,
    maxY: void 0,
    width: void 0,
    height: void 0,
    startX: void 0,
    startY: void 0,
    touchesStart: {},
    touchesCurrent: {},
  };
  const velocity = {
    x: void 0,
    y: void 0,
    prevPositionX: void 0,
    prevPositionY: void 0,
    prevTime: void 0,
  };
  let scale = 1;
  Object.defineProperty(swiper.zoom, 'scale', {
    get() {
      return scale;
    },
    set(value) {
      if (scale !== value) {
        const imageEl = gesture.imageEl;
        const slideEl = gesture.slideEl;
        emit('zoomChange', value, imageEl, slideEl);
      }
      scale = value;
    },
  });
  function getDistanceBetweenTouches() {
    if (evCache.length < 2)
      return 1;
    const x1 = evCache[0].pageX;
    const y1 = evCache[0].pageY;
    const x2 = evCache[1].pageX;
    const y2 = evCache[1].pageY;
    const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
    return distance;
  }
  function getMaxRatio() {
    const params = swiper.params.zoom;
    const maxRatio = gesture.imageWrapEl.getAttribute('data-swiper-zoom') || params.maxRatio;
    if (params.limitToOriginalSize && gesture.imageEl && gesture.imageEl.naturalWidth) {
      const imageMaxRatio = gesture.imageEl.naturalWidth / gesture.imageEl.offsetWidth;
      return Math.min(imageMaxRatio, maxRatio);
    }
    return maxRatio;
  }
  function getScaleOrigin() {
    if (evCache.length < 2)
      return {
        x: null,
        y: null,
      };
    const box = gesture.imageEl.getBoundingClientRect();
    return [(evCache[0].pageX + (evCache[1].pageX - evCache[0].pageX) / 2 - box.x - window2.scrollX) / currentScale, (evCache[0].pageY + (evCache[1].pageY - evCache[0].pageY) / 2 - box.y - window2.scrollY) / currentScale];
  }
  function getSlideSelector() {
    return swiper.isElement ? 'swiper-slide' : `.${swiper.params.slideClass}`;
  }
  function eventWithinSlide(e) {
    const slideSelector = getSlideSelector();
    if (e.target.matches(slideSelector))
      return true;
    if (swiper.slides.filter((slideEl) => slideEl.contains(e.target)).length > 0)
      return true;
    return false;
  }
  function eventWithinZoomContainer(e) {
    const selector = `.${swiper.params.zoom.containerClass}`;
    if (e.target.matches(selector))
      return true;
    if ([...swiper.hostEl.querySelectorAll(selector)].filter((containerEl) => containerEl.contains(e.target)).length > 0)
      return true;
    return false;
  }
  function onGestureStart(e) {
    if (e.pointerType === 'mouse') {
      evCache.splice(0, evCache.length);
    }
    if (!eventWithinSlide(e))
      return;
    const params = swiper.params.zoom;
    fakeGestureTouched = false;
    fakeGestureMoved = false;
    evCache.push(e);
    if (evCache.length < 2) {
      return;
    }
    fakeGestureTouched = true;
    gesture.scaleStart = getDistanceBetweenTouches();
    if (!gesture.slideEl) {
      gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);
      if (!gesture.slideEl)
        gesture.slideEl = swiper.slides[swiper.activeIndex];
      let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);
      if (imageEl) {
        imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];
      }
      gesture.imageEl = imageEl;
      if (imageEl) {
        gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];
      } else {
        gesture.imageWrapEl = void 0;
      }
      if (!gesture.imageWrapEl) {
        gesture.imageEl = void 0;
        return;
      }
      gesture.maxRatio = getMaxRatio();
    }
    if (gesture.imageEl) {
      const [originX, originY] = getScaleOrigin();
      gesture.originX = originX;
      gesture.originY = originY;
      gesture.imageEl.style.transitionDuration = '0ms';
    }
    isScaling = true;
  }
  function onGestureChange(e) {
    if (!eventWithinSlide(e))
      return;
    const params = swiper.params.zoom;
    const zoom = swiper.zoom;
    const pointerIndex = evCache.findIndex((cachedEv) => cachedEv.pointerId === e.pointerId);
    if (pointerIndex >= 0)
      evCache[pointerIndex] = e;
    if (evCache.length < 2) {
      return;
    }
    fakeGestureMoved = true;
    gesture.scaleMove = getDistanceBetweenTouches();
    if (!gesture.imageEl) {
      return;
    }
    zoom.scale = gesture.scaleMove / gesture.scaleStart * currentScale;
    if (zoom.scale > gesture.maxRatio) {
      zoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;
    }
    if (zoom.scale < params.minRatio) {
      zoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;
    }
    gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;
  }
  function onGestureEnd(e) {
    if (!eventWithinSlide(e))
      return;
    if (e.pointerType === 'mouse' && e.type === 'pointerout')
      return;
    const params = swiper.params.zoom;
    const zoom = swiper.zoom;
    const pointerIndex = evCache.findIndex((cachedEv) => cachedEv.pointerId === e.pointerId);
    if (pointerIndex >= 0)
      evCache.splice(pointerIndex, 1);
    if (!fakeGestureTouched || !fakeGestureMoved) {
      return;
    }
    fakeGestureTouched = false;
    fakeGestureMoved = false;
    if (!gesture.imageEl)
      return;
    zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
    gesture.imageEl.style.transitionDuration = `${swiper.params.speed}ms`;
    gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;
    currentScale = zoom.scale;
    isScaling = false;
    if (zoom.scale > 1 && gesture.slideEl) {
      gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);
    } else if (zoom.scale <= 1 && gesture.slideEl) {
      gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);
    }
    if (zoom.scale === 1) {
      gesture.originX = 0;
      gesture.originY = 0;
      gesture.slideEl = void 0;
    }
  }
  let allowTouchMoveTimeout;
  function allowTouchMove() {
    swiper.touchEventsData.preventTouchMoveFromPointerMove = false;
  }
  function preventTouchMove() {
    clearTimeout(allowTouchMoveTimeout);
    swiper.touchEventsData.preventTouchMoveFromPointerMove = true;
    allowTouchMoveTimeout = setTimeout(() => {
      allowTouchMove();
    });
  }
  function onTouchStart2(e) {
    const device = swiper.device;
    if (!gesture.imageEl)
      return;
    if (image.isTouched)
      return;
    if (device.android && e.cancelable)
      e.preventDefault();
    image.isTouched = true;
    const event2 = evCache.length > 0 ? evCache[0] : e;
    image.touchesStart.x = event2.pageX;
    image.touchesStart.y = event2.pageY;
  }
  function onTouchMove2(e) {
    if (!eventWithinSlide(e) || !eventWithinZoomContainer(e)) {
      return;
    }
    const zoom = swiper.zoom;
    if (!gesture.imageEl) {
      return;
    }
    if (!image.isTouched || !gesture.slideEl) {
      return;
    }
    if (!image.isMoved) {
      image.width = gesture.imageEl.offsetWidth || gesture.imageEl.clientWidth;
      image.height = gesture.imageEl.offsetHeight || gesture.imageEl.clientHeight;
      image.startX = getTranslate(gesture.imageWrapEl, 'x') || 0;
      image.startY = getTranslate(gesture.imageWrapEl, 'y') || 0;
      gesture.slideWidth = gesture.slideEl.offsetWidth;
      gesture.slideHeight = gesture.slideEl.offsetHeight;
      gesture.imageWrapEl.style.transitionDuration = '0ms';
    }
    const scaledWidth = image.width * zoom.scale;
    const scaledHeight = image.height * zoom.scale;
    if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) {
      allowTouchMove();
      return;
    }
    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
    image.maxX = -image.minX;
    image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
    image.maxY = -image.minY;
    image.touchesCurrent.x = evCache.length > 0 ? evCache[0].pageX : e.pageX;
    image.touchesCurrent.y = evCache.length > 0 ? evCache[0].pageY : e.pageY;
    const touchesDiff = Math.max(Math.abs(image.touchesCurrent.x - image.touchesStart.x), Math.abs(image.touchesCurrent.y - image.touchesStart.y));
    if (touchesDiff > 5) {
      swiper.allowClick = false;
    }
    if (!image.isMoved && !isScaling) {
      if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {
        image.isTouched = false;
        allowTouchMove();
        return;
      }
      if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {
        image.isTouched = false;
        allowTouchMove();
        return;
      }
    }
    if (e.cancelable) {
      e.preventDefault();
    }
    e.stopPropagation();
    preventTouchMove();
    image.isMoved = true;
    const scaleRatio = (zoom.scale - currentScale) / (gesture.maxRatio - swiper.params.zoom.minRatio);
    const {
      originX,
      originY,
    } = gesture;
    image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX + scaleRatio * (image.width - originX * 2);
    image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY + scaleRatio * (image.height - originY * 2);
    if (image.currentX < image.minX) {
      image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;
    }
    if (image.currentX > image.maxX) {
      image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;
    }
    if (image.currentY < image.minY) {
      image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;
    }
    if (image.currentY > image.maxY) {
      image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;
    }
    if (!velocity.prevPositionX)
      velocity.prevPositionX = image.touchesCurrent.x;
    if (!velocity.prevPositionY)
      velocity.prevPositionY = image.touchesCurrent.y;
    if (!velocity.prevTime)
      velocity.prevTime = Date.now();
    velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
    velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
    if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2)
      velocity.x = 0;
    if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2)
      velocity.y = 0;
    velocity.prevPositionX = image.touchesCurrent.x;
    velocity.prevPositionY = image.touchesCurrent.y;
    velocity.prevTime = Date.now();
    gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;
  }
  function onTouchEnd2() {
    const zoom = swiper.zoom;
    if (!gesture.imageEl)
      return;
    if (!image.isTouched || !image.isMoved) {
      image.isTouched = false;
      image.isMoved = false;
      return;
    }
    image.isTouched = false;
    image.isMoved = false;
    let momentumDurationX = 300;
    let momentumDurationY = 300;
    const momentumDistanceX = velocity.x * momentumDurationX;
    const newPositionX = image.currentX + momentumDistanceX;
    const momentumDistanceY = velocity.y * momentumDurationY;
    const newPositionY = image.currentY + momentumDistanceY;
    if (velocity.x !== 0)
      momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
    if (velocity.y !== 0)
      momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
    const momentumDuration = Math.max(momentumDurationX, momentumDurationY);
    image.currentX = newPositionX;
    image.currentY = newPositionY;
    const scaledWidth = image.width * zoom.scale;
    const scaledHeight = image.height * zoom.scale;
    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
    image.maxX = -image.minX;
    image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
    image.maxY = -image.minY;
    image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
    image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);
    gesture.imageWrapEl.style.transitionDuration = `${momentumDuration}ms`;
    gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;
  }
  function onTransitionEnd() {
    const zoom = swiper.zoom;
    if (gesture.slideEl && swiper.activeIndex !== swiper.slides.indexOf(gesture.slideEl)) {
      if (gesture.imageEl) {
        gesture.imageEl.style.transform = 'translate3d(0,0,0) scale(1)';
      }
      if (gesture.imageWrapEl) {
        gesture.imageWrapEl.style.transform = 'translate3d(0,0,0)';
      }
      gesture.slideEl.classList.remove(`${swiper.params.zoom.zoomedSlideClass}`);
      zoom.scale = 1;
      currentScale = 1;
      gesture.slideEl = void 0;
      gesture.imageEl = void 0;
      gesture.imageWrapEl = void 0;
      gesture.originX = 0;
      gesture.originY = 0;
    }
  }
  function zoomIn(e) {
    const zoom = swiper.zoom;
    const params = swiper.params.zoom;
    if (!gesture.slideEl) {
      if (e && e.target) {
        gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);
      }
      if (!gesture.slideEl) {
        if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
          gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];
        } else {
          gesture.slideEl = swiper.slides[swiper.activeIndex];
        }
      }
      let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);
      if (imageEl) {
        imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];
      }
      gesture.imageEl = imageEl;
      if (imageEl) {
        gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];
      } else {
        gesture.imageWrapEl = void 0;
      }
    }
    if (!gesture.imageEl || !gesture.imageWrapEl)
      return;
    if (swiper.params.cssMode) {
      swiper.wrapperEl.style.overflow = 'hidden';
      swiper.wrapperEl.style.touchAction = 'none';
    }
    gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);
    let touchX;
    let touchY;
    let offsetX;
    let offsetY;
    let diffX;
    let diffY;
    let translateX;
    let translateY;
    let imageWidth;
    let imageHeight;
    let scaledWidth;
    let scaledHeight;
    let translateMinX;
    let translateMinY;
    let translateMaxX;
    let translateMaxY;
    let slideWidth;
    let slideHeight;
    if (typeof image.touchesStart.x === 'undefined' && e) {
      touchX = e.pageX;
      touchY = e.pageY;
    } else {
      touchX = image.touchesStart.x;
      touchY = image.touchesStart.y;
    }
    const forceZoomRatio = typeof e === 'number' ? e : null;
    if (currentScale === 1 && forceZoomRatio) {
      touchX = void 0;
      touchY = void 0;
    }
    const maxRatio = getMaxRatio();
    zoom.scale = forceZoomRatio || maxRatio;
    currentScale = forceZoomRatio || maxRatio;
    if (e && !(currentScale === 1 && forceZoomRatio)) {
      slideWidth = gesture.slideEl.offsetWidth;
      slideHeight = gesture.slideEl.offsetHeight;
      offsetX = elementOffset(gesture.slideEl).left + window2.scrollX;
      offsetY = elementOffset(gesture.slideEl).top + window2.scrollY;
      diffX = offsetX + slideWidth / 2 - touchX;
      diffY = offsetY + slideHeight / 2 - touchY;
      imageWidth = gesture.imageEl.offsetWidth || gesture.imageEl.clientWidth;
      imageHeight = gesture.imageEl.offsetHeight || gesture.imageEl.clientHeight;
      scaledWidth = imageWidth * zoom.scale;
      scaledHeight = imageHeight * zoom.scale;
      translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);
      translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);
      translateMaxX = -translateMinX;
      translateMaxY = -translateMinY;
      translateX = diffX * zoom.scale;
      translateY = diffY * zoom.scale;
      if (translateX < translateMinX) {
        translateX = translateMinX;
      }
      if (translateX > translateMaxX) {
        translateX = translateMaxX;
      }
      if (translateY < translateMinY) {
        translateY = translateMinY;
      }
      if (translateY > translateMaxY) {
        translateY = translateMaxY;
      }
    } else {
      translateX = 0;
      translateY = 0;
    }
    if (forceZoomRatio && zoom.scale === 1) {
      gesture.originX = 0;
      gesture.originY = 0;
    }
    gesture.imageWrapEl.style.transitionDuration = '300ms';
    gesture.imageWrapEl.style.transform = `translate3d(${translateX}px, ${translateY}px,0)`;
    gesture.imageEl.style.transitionDuration = '300ms';
    gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;
  }
  function zoomOut() {
    const zoom = swiper.zoom;
    const params = swiper.params.zoom;
    if (!gesture.slideEl) {
      if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
        gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];
      } else {
        gesture.slideEl = swiper.slides[swiper.activeIndex];
      }
      let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);
      if (imageEl) {
        imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];
      }
      gesture.imageEl = imageEl;
      if (imageEl) {
        gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];
      } else {
        gesture.imageWrapEl = void 0;
      }
    }
    if (!gesture.imageEl || !gesture.imageWrapEl)
      return;
    if (swiper.params.cssMode) {
      swiper.wrapperEl.style.overflow = '';
      swiper.wrapperEl.style.touchAction = '';
    }
    zoom.scale = 1;
    currentScale = 1;
    gesture.imageWrapEl.style.transitionDuration = '300ms';
    gesture.imageWrapEl.style.transform = 'translate3d(0,0,0)';
    gesture.imageEl.style.transitionDuration = '300ms';
    gesture.imageEl.style.transform = 'translate3d(0,0,0) scale(1)';
    gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);
    gesture.slideEl = void 0;
    gesture.originX = 0;
    gesture.originY = 0;
  }
  function zoomToggle(e) {
    const zoom = swiper.zoom;
    if (zoom.scale && zoom.scale !== 1) {
      zoomOut();
    } else {
      zoomIn(e);
    }
  }
  function getListeners() {
    const passiveListener = swiper.params.passiveListeners ? {
      passive: true,
      capture: false,
    } : false;
    const activeListenerWithCapture = swiper.params.passiveListeners ? {
      passive: false,
      capture: true,
    } : true;
    return {
      passiveListener,
      activeListenerWithCapture,
    };
  }
  function enable() {
    const zoom = swiper.zoom;
    if (zoom.enabled)
      return;
    zoom.enabled = true;
    const {
      passiveListener,
      activeListenerWithCapture,
    } = getListeners();
    swiper.wrapperEl.addEventListener('pointerdown', onGestureStart, passiveListener);
    swiper.wrapperEl.addEventListener('pointermove', onGestureChange, activeListenerWithCapture);
    ['pointerup', 'pointercancel', 'pointerout'].forEach((eventName) => {
      swiper.wrapperEl.addEventListener(eventName, onGestureEnd, passiveListener);
    });
    swiper.wrapperEl.addEventListener('pointermove', onTouchMove2, activeListenerWithCapture);
  }
  function disable() {
    const zoom = swiper.zoom;
    if (!zoom.enabled)
      return;
    zoom.enabled = false;
    const {
      passiveListener,
      activeListenerWithCapture,
    } = getListeners();
    swiper.wrapperEl.removeEventListener('pointerdown', onGestureStart, passiveListener);
    swiper.wrapperEl.removeEventListener('pointermove', onGestureChange, activeListenerWithCapture);
    ['pointerup', 'pointercancel', 'pointerout'].forEach((eventName) => {
      swiper.wrapperEl.removeEventListener(eventName, onGestureEnd, passiveListener);
    });
    swiper.wrapperEl.removeEventListener('pointermove', onTouchMove2, activeListenerWithCapture);
  }
  on('init', () => {
    if (swiper.params.zoom.enabled) {
      enable();
    }
  });
  on('destroy', () => {
    disable();
  });
  on('touchStart', (_s, e) => {
    if (!swiper.zoom.enabled)
      return;
    onTouchStart2(e);
  });
  on('touchEnd', (_s, e) => {
    if (!swiper.zoom.enabled)
      return;
    onTouchEnd2();
  });
  on('doubleTap', (_s, e) => {
    if (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
      zoomToggle(e);
    }
  });
  on('transitionEnd', () => {
    if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
      onTransitionEnd();
    }
  });
  on('slideChange', () => {
    if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {
      onTransitionEnd();
    }
  });
  Object.assign(swiper.zoom, {
    enable,
    disable,
    in: zoomIn,
    out: zoomOut,
    toggle: zoomToggle,
  });
}
function Autoplay(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit,
    params,
  } = _ref;
  swiper.autoplay = {
    running: false,
    paused: false,
    timeLeft: 0,
  };
  extendParams({
    autoplay: {
      enabled: false,
      delay: 3e3,
      waitForTransition: true,
      disableOnInteraction: false,
      stopOnLastSlide: false,
      reverseDirection: false,
      pauseOnMouseEnter: false,
    },
  });
  let timeout;
  let raf;
  let autoplayDelayTotal = params && params.autoplay ? params.autoplay.delay : 3e3;
  let autoplayDelayCurrent = params && params.autoplay ? params.autoplay.delay : 3e3;
  let autoplayTimeLeft;
  let autoplayStartTime = (/* @__PURE__ */ new Date()).getTime();
  let wasPaused;
  let isTouched;
  let pausedByTouch;
  let touchStartTimeout;
  let slideChanged;
  let pausedByInteraction;
  let pausedByPointerEnter;
  function onTransitionEnd(e) {
    if (!swiper || swiper.destroyed || !swiper.wrapperEl)
      return;
    if (e.target !== swiper.wrapperEl)
      return;
    swiper.wrapperEl.removeEventListener('transitionend', onTransitionEnd);
    if (pausedByPointerEnter || e.detail && e.detail.bySwiperTouchMove) {
      return;
    }
    resume();
  }
  const calcTimeLeft = () => {
    if (swiper.destroyed || !swiper.autoplay.running)
      return;
    if (swiper.autoplay.paused) {
      wasPaused = true;
    } else if (wasPaused) {
      autoplayDelayCurrent = autoplayTimeLeft;
      wasPaused = false;
    }
    const timeLeft = swiper.autoplay.paused ? autoplayTimeLeft : autoplayStartTime + autoplayDelayCurrent - (/* @__PURE__ */ new Date()).getTime();
    swiper.autoplay.timeLeft = timeLeft;
    emit('autoplayTimeLeft', timeLeft, timeLeft / autoplayDelayTotal);
    raf = requestAnimationFrame(() => {
      calcTimeLeft();
    });
  };
  const getSlideDelay = () => {
    let activeSlideEl;
    if (swiper.virtual && swiper.params.virtual.enabled) {
      activeSlideEl = swiper.slides.filter((slideEl) => slideEl.classList.contains('swiper-slide-active'))[0];
    } else {
      activeSlideEl = swiper.slides[swiper.activeIndex];
    }
    if (!activeSlideEl)
      return void 0;
    const currentSlideDelay = parseInt(activeSlideEl.getAttribute('data-swiper-autoplay'), 10);
    return currentSlideDelay;
  };
  const run = (delayForce) => {
    if (swiper.destroyed || !swiper.autoplay.running)
      return;
    cancelAnimationFrame(raf);
    calcTimeLeft();
    let delay = typeof delayForce === 'undefined' ? swiper.params.autoplay.delay : delayForce;
    autoplayDelayTotal = swiper.params.autoplay.delay;
    autoplayDelayCurrent = swiper.params.autoplay.delay;
    const currentSlideDelay = getSlideDelay();
    if (!Number.isNaN(currentSlideDelay) && currentSlideDelay > 0 && typeof delayForce === 'undefined') {
      delay = currentSlideDelay;
      autoplayDelayTotal = currentSlideDelay;
      autoplayDelayCurrent = currentSlideDelay;
    }
    autoplayTimeLeft = delay;
    const speed = swiper.params.speed;
    const proceed = () => {
      if (!swiper || swiper.destroyed)
        return;
      if (swiper.params.autoplay.reverseDirection) {
        if (!swiper.isBeginning || swiper.params.loop || swiper.params.rewind) {
          swiper.slidePrev(speed, true, true);
          emit('autoplay');
        } else if (!swiper.params.autoplay.stopOnLastSlide) {
          swiper.slideTo(swiper.slides.length - 1, speed, true, true);
          emit('autoplay');
        }
      } else {
        if (!swiper.isEnd || swiper.params.loop || swiper.params.rewind) {
          swiper.slideNext(speed, true, true);
          emit('autoplay');
        } else if (!swiper.params.autoplay.stopOnLastSlide) {
          swiper.slideTo(0, speed, true, true);
          emit('autoplay');
        }
      }
      if (swiper.params.cssMode) {
        autoplayStartTime = (/* @__PURE__ */ new Date()).getTime();
        requestAnimationFrame(() => {
          run();
        });
      }
    };
    if (delay > 0) {
      clearTimeout(timeout);
      timeout = setTimeout(() => {
        proceed();
      }, delay);
    } else {
      requestAnimationFrame(() => {
        proceed();
      });
    }
    return delay;
  };
  const start = () => {
    autoplayStartTime = (/* @__PURE__ */ new Date()).getTime();
    swiper.autoplay.running = true;
    run();
    emit('autoplayStart');
  };
  const stop = () => {
    swiper.autoplay.running = false;
    clearTimeout(timeout);
    cancelAnimationFrame(raf);
    emit('autoplayStop');
  };
  const pause = (internal, reset) => {
    if (swiper.destroyed || !swiper.autoplay.running)
      return;
    clearTimeout(timeout);
    if (!internal) {
      pausedByInteraction = true;
    }
    const proceed = () => {
      emit('autoplayPause');
      if (swiper.params.autoplay.waitForTransition) {
        swiper.wrapperEl.addEventListener('transitionend', onTransitionEnd);
      } else {
        resume();
      }
    };
    swiper.autoplay.paused = true;
    if (reset) {
      if (slideChanged) {
        autoplayTimeLeft = swiper.params.autoplay.delay;
      }
      slideChanged = false;
      proceed();
      return;
    }
    const delay = autoplayTimeLeft || swiper.params.autoplay.delay;
    autoplayTimeLeft = delay - ((/* @__PURE__ */ new Date()).getTime() - autoplayStartTime);
    if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop)
      return;
    if (autoplayTimeLeft < 0)
      autoplayTimeLeft = 0;
    proceed();
  };
  const resume = () => {
    if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop || swiper.destroyed || !swiper.autoplay.running)
      return;
    autoplayStartTime = (/* @__PURE__ */ new Date()).getTime();
    if (pausedByInteraction) {
      pausedByInteraction = false;
      run(autoplayTimeLeft);
    } else {
      run();
    }
    swiper.autoplay.paused = false;
    emit('autoplayResume');
  };
  const onVisibilityChange = () => {
    if (swiper.destroyed || !swiper.autoplay.running)
      return;
    const document2 = getDocument();
    if (document2.visibilityState === 'hidden') {
      pausedByInteraction = true;
      pause(true);
    }
    if (document2.visibilityState === 'visible') {
      resume();
    }
  };
  const onPointerEnter = (e) => {
    if (e.pointerType !== 'mouse')
      return;
    pausedByInteraction = true;
    pausedByPointerEnter = true;
    if (swiper.animating || swiper.autoplay.paused)
      return;
    pause(true);
  };
  const onPointerLeave = (e) => {
    if (e.pointerType !== 'mouse')
      return;
    pausedByPointerEnter = false;
    if (swiper.autoplay.paused) {
      resume();
    }
  };
  const attachMouseEvents = () => {
    if (swiper.params.autoplay.pauseOnMouseEnter) {
      swiper.el.addEventListener('pointerenter', onPointerEnter);
      swiper.el.addEventListener('pointerleave', onPointerLeave);
    }
  };
  const detachMouseEvents = () => {
    swiper.el.removeEventListener('pointerenter', onPointerEnter);
    swiper.el.removeEventListener('pointerleave', onPointerLeave);
  };
  const attachDocumentEvents = () => {
    const document2 = getDocument();
    document2.addEventListener('visibilitychange', onVisibilityChange);
  };
  const detachDocumentEvents = () => {
    const document2 = getDocument();
    document2.removeEventListener('visibilitychange', onVisibilityChange);
  };
  on('init', () => {
    if (swiper.params.autoplay.enabled) {
      attachMouseEvents();
      attachDocumentEvents();
      start();
    }
  });
  on('destroy', () => {
    detachMouseEvents();
    detachDocumentEvents();
    if (swiper.autoplay.running) {
      stop();
    }
  });
  on('_freeModeStaticRelease', () => {
    if (pausedByTouch || pausedByInteraction) {
      resume();
    }
  });
  on('_freeModeNoMomentumRelease', () => {
    if (!swiper.params.autoplay.disableOnInteraction) {
      pause(true, true);
    } else {
      stop();
    }
  });
  on('beforeTransitionStart', (_s, speed, internal) => {
    if (swiper.destroyed || !swiper.autoplay.running)
      return;
    if (internal || !swiper.params.autoplay.disableOnInteraction) {
      pause(true, true);
    } else {
      stop();
    }
  });
  on('sliderFirstMove', () => {
    if (swiper.destroyed || !swiper.autoplay.running)
      return;
    if (swiper.params.autoplay.disableOnInteraction) {
      stop();
      return;
    }
    isTouched = true;
    pausedByTouch = false;
    pausedByInteraction = false;
    touchStartTimeout = setTimeout(() => {
      pausedByInteraction = true;
      pausedByTouch = true;
      pause(true);
    }, 200);
  });
  on('touchEnd', () => {
    if (swiper.destroyed || !swiper.autoplay.running || !isTouched)
      return;
    clearTimeout(touchStartTimeout);
    clearTimeout(timeout);
    if (swiper.params.autoplay.disableOnInteraction) {
      pausedByTouch = false;
      isTouched = false;
      return;
    }
    if (pausedByTouch && swiper.params.cssMode)
      resume();
    pausedByTouch = false;
    isTouched = false;
  });
  on('slideChange', () => {
    if (swiper.destroyed || !swiper.autoplay.running)
      return;
    slideChanged = true;
  });
  Object.assign(swiper.autoplay, {
    start,
    stop,
    pause,
    resume,
  });
}
function effectInit(params) {
  const {
    effect,
    swiper,
    on,
    setTranslate: setTranslate2,
    setTransition: setTransition2,
    overwriteParams,
    perspective,
    recreateShadows,
    getEffectParams,
  } = params;
  on('beforeInit', () => {
    if (swiper.params.effect !== effect)
      return;
    swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);
    if (perspective && perspective()) {
      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
    }
    const overwriteParamsResult = overwriteParams ? overwriteParams() : {};
    Object.assign(swiper.params, overwriteParamsResult);
    Object.assign(swiper.originalParams, overwriteParamsResult);
  });
  on('setTranslate', () => {
    if (swiper.params.effect !== effect)
      return;
    setTranslate2();
  });
  on('setTransition', (_s, duration) => {
    if (swiper.params.effect !== effect)
      return;
    setTransition2(duration);
  });
  on('transitionEnd', () => {
    if (swiper.params.effect !== effect)
      return;
    if (recreateShadows) {
      if (!getEffectParams || !getEffectParams().slideShadows)
        return;
      swiper.slides.forEach((slideEl) => {
        slideEl.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach((shadowEl) => shadowEl.remove());
      });
      recreateShadows();
    }
  });
  let requireUpdateOnVirtual;
  on('virtualUpdate', () => {
    if (swiper.params.effect !== effect)
      return;
    if (!swiper.slides.length) {
      requireUpdateOnVirtual = true;
    }
    requestAnimationFrame(() => {
      if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {
        setTranslate2();
        requireUpdateOnVirtual = false;
      }
    });
  });
}
function EffectCube(_ref) {
  let {
    swiper,
    extendParams,
    on,
  } = _ref;
  extendParams({
    cubeEffect: {
      slideShadows: true,
      shadow: true,
      shadowOffset: 20,
      shadowScale: 0.94,
    },
  });
  const createSlideShadows = (slideEl, progress, isHorizontal) => {
    let shadowBefore = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');
    let shadowAfter = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');
    if (!shadowBefore) {
      shadowBefore = createElement('div', `swiper-slide-shadow-cube swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}`.split(' '));
      slideEl.append(shadowBefore);
    }
    if (!shadowAfter) {
      shadowAfter = createElement('div', `swiper-slide-shadow-cube swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}`.split(' '));
      slideEl.append(shadowAfter);
    }
    if (shadowBefore)
      shadowBefore.style.opacity = Math.max(-progress, 0);
    if (shadowAfter)
      shadowAfter.style.opacity = Math.max(progress, 0);
  };
  const recreateShadows = () => {
    const isHorizontal = swiper.isHorizontal();
    swiper.slides.forEach((slideEl) => {
      const progress = Math.max(Math.min(slideEl.progress, 1), -1);
      createSlideShadows(slideEl, progress, isHorizontal);
    });
  };
  const setTranslate2 = () => {
    const {
      el,
      wrapperEl,
      slides,
      width: swiperWidth,
      height: swiperHeight,
      rtlTranslate: rtl,
      size: swiperSize,
      browser: browser2,
    } = swiper;
    const params = swiper.params.cubeEffect;
    const isHorizontal = swiper.isHorizontal();
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    let wrapperRotate = 0;
    let cubeShadowEl;
    if (params.shadow) {
      if (isHorizontal) {
        cubeShadowEl = swiper.wrapperEl.querySelector('.swiper-cube-shadow');
        if (!cubeShadowEl) {
          cubeShadowEl = createElement('div', 'swiper-cube-shadow');
          swiper.wrapperEl.append(cubeShadowEl);
        }
        cubeShadowEl.style.height = `${swiperWidth}px`;
      } else {
        cubeShadowEl = el.querySelector('.swiper-cube-shadow');
        if (!cubeShadowEl) {
          cubeShadowEl = createElement('div', 'swiper-cube-shadow');
          el.append(cubeShadowEl);
        }
      }
    }
    for (let i = 0; i < slides.length; i += 1) {
      const slideEl = slides[i];
      let slideIndex = i;
      if (isVirtual) {
        slideIndex = parseInt(slideEl.getAttribute('data-swiper-slide-index'), 10);
      }
      let slideAngle = slideIndex * 90;
      let round = Math.floor(slideAngle / 360);
      if (rtl) {
        slideAngle = -slideAngle;
        round = Math.floor(-slideAngle / 360);
      }
      const progress = Math.max(Math.min(slideEl.progress, 1), -1);
      let tx = 0;
      let ty = 0;
      let tz = 0;
      if (slideIndex % 4 === 0) {
        tx = -round * 4 * swiperSize;
        tz = 0;
      } else if ((slideIndex - 1) % 4 === 0) {
        tx = 0;
        tz = -round * 4 * swiperSize;
      } else if ((slideIndex - 2) % 4 === 0) {
        tx = swiperSize + round * 4 * swiperSize;
        tz = swiperSize;
      } else if ((slideIndex - 3) % 4 === 0) {
        tx = -swiperSize;
        tz = 3 * swiperSize + swiperSize * 4 * round;
      }
      if (rtl) {
        tx = -tx;
      }
      if (!isHorizontal) {
        ty = tx;
        tx = 0;
      }
      const transform = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${isHorizontal ? slideAngle : 0}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;
      if (progress <= 1 && progress > -1) {
        wrapperRotate = slideIndex * 90 + progress * 90;
        if (rtl)
          wrapperRotate = -slideIndex * 90 - progress * 90;
        if (swiper.browser && swiper.browser.need3dFix && Math.abs(wrapperRotate) / 90 % 2 === 1) {
          wrapperRotate += 1e-3;
        }
      }
      slideEl.style.transform = transform;
      if (params.slideShadows) {
        createSlideShadows(slideEl, progress, isHorizontal);
      }
    }
    wrapperEl.style.transformOrigin = `50% 50% -${swiperSize / 2}px`;
    wrapperEl.style['-webkit-transform-origin'] = `50% 50% -${swiperSize / 2}px`;
    if (params.shadow) {
      if (isHorizontal) {
        cubeShadowEl.style.transform = `translate3d(0px, ${swiperWidth / 2 + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(89.99deg) rotateZ(0deg) scale(${params.shadowScale})`;
      } else {
        const shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;
        const multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);
        const scale1 = params.shadowScale;
        const scale2 = params.shadowScale / multiplier;
        const offset = params.shadowOffset;
        cubeShadowEl.style.transform = `scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${swiperHeight / 2 + offset}px, ${-swiperHeight / 2 / scale2}px) rotateX(-89.99deg)`;
      }
    }
    const zFactor = (browser2.isSafari || browser2.isWebView) && browser2.needPerspectiveFix ? -swiperSize / 2 : 0;
    wrapperEl.style.transform = `translate3d(0px,0,${zFactor}px) rotateX(${swiper.isHorizontal() ? 0 : wrapperRotate}deg) rotateY(${swiper.isHorizontal() ? -wrapperRotate : 0}deg)`;
    wrapperEl.style.setProperty('--swiper-cube-translate-z', `${zFactor}px`);
  };
  const setTransition2 = (duration) => {
    const {
      el,
      slides,
    } = swiper;
    slides.forEach((slideEl) => {
      slideEl.style.transitionDuration = `${duration}ms`;
      slideEl.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach((subEl) => {
        subEl.style.transitionDuration = `${duration}ms`;
      });
    });
    if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
      const shadowEl = el.querySelector('.swiper-cube-shadow');
      if (shadowEl)
        shadowEl.style.transitionDuration = `${duration}ms`;
    }
  };
  effectInit({
    effect: 'cube',
    swiper,
    on,
    setTranslate: setTranslate2,
    setTransition: setTransition2,
    recreateShadows,
    getEffectParams: () => swiper.params.cubeEffect,
    perspective: () => true,
    overwriteParams: () => ({
      slidesPerView: 1,
      slidesPerGroup: 1,
      watchSlidesProgress: true,
      resistanceRatio: 0,
      spaceBetween: 0,
      centeredSlides: false,
      virtualTranslate: true,
    }),
  });
}
Swiper.use([Pagination, Autoplay, Mousewheel, Navigation, Keyboard, Zoom]);
function modalSwiper(url) {
  const modalOverlayParams = {
    tag: 'div',
    classNames: ['modal-overlay'],
  };
  const modalContainerParams = {
    tag: 'div',
    classNames: ['modal-container'],
  };
  const closeButtonParams = {
    tag: 'button',
    classNames: ['close-button'],
    attributes: {
      type: 'button',
    },
    textContent: '×',
  };
  const swiperParams = {
    tag: 'div',
    classNames: ['swiper-container-modal'],
  };
  const swiperWrapperParams = {
    tag: 'div',
    classNames: ['swiper-wrapper'],
  };
  const swiperSlideParams = {
    tag: 'div',
    classNames: ['swiper-slide', 'modal'],
  };
  const swiperPaginationParams = {
    tag: 'div',
    classNames: ['swiper-pagination-modal'],
  };
  const swiperNavigationPrevParams = {
    tag: 'div',
    classNames: ['swiper-button-prev'],
  };
  const swiperNavigationNextParams = {
    tag: 'div',
    classNames: ['swiper-button-next'],
  };
  const swiperNavigationPrevContainerParams = {
    tag: 'div',
    classNames: ['swiper-button-prev-container-modal'],
  };
  const swiperNavigationNextContainerParams = {
    tag: 'div',
    classNames: ['swiper-button-next-container-modal'],
  };
  const swiperPagination = createElement$1(swiperPaginationParams);
  const swiperNavigationPrev = createElement$1(swiperNavigationPrevParams);
  const swiperNavigationNext = createElement$1(swiperNavigationNextParams);
  const swiperNavigationPrevContainer = createElement$1(
    swiperNavigationPrevContainerParams,
  );
  const swiperNavigationNextContainer = createElement$1(
    swiperNavigationNextContainerParams,
  );
  const swiperWrapper = createElement$1(swiperWrapperParams);
  const swiperMain = createElement$1(swiperParams);
  url.forEach((urlimg) => {
    const imgSlideParams = {
      tag: 'img',
      attributes: {
        alt: 'Felt Boots Img',
        src: urlimg,
      },
      classNames: ['img-slide-modal'],
    };
    const swiperZoomContainerParams = {
      tag: 'div',
      classNames: ['swiper-zoom-container'],
    };
    const swiperZoomContainer = createElement$1(swiperZoomContainerParams);
    const swiperSlide = createElement$1(swiperSlideParams);
    const imgSlide = createElement$1(imgSlideParams);
    addInnerComponent(swiperZoomContainer, imgSlide);
    addInnerComponent(swiperSlide, swiperZoomContainer);
    addInnerComponent(swiperWrapper, swiperSlide);
  });
  addInnerComponent(swiperMain, swiperWrapper);
  addInnerComponent(swiperMain, swiperPagination);
  addInnerComponent(swiperNavigationPrevContainer, swiperNavigationPrev);
  addInnerComponent(swiperNavigationNextContainer, swiperNavigationNext);
  addInnerComponent(swiperMain, swiperNavigationPrevContainer);
  addInnerComponent(swiperMain, swiperNavigationNextContainer);
  const modalOverlay = createElement$1(modalOverlayParams);
  const modalContainer = createElement$1(modalContainerParams);
  const closeButton = createElement$1(closeButtonParams);
  addInnerComponent(modalOverlay, closeButton);
  addInnerComponent(modalContainer, swiperMain);
  addInnerComponent(modalOverlay, modalContainer);
  setTimeout(() => {
    const swiper = new Swiper('.swiper-container-modal', {
      direction: 'horizontal',
      loop: true,
      speed: 2e3,
      preventClicks: true,
      keyboard: {
        enabled: true,
        onlyInViewport: true,
      },
      navigation: {
        nextEl: '.swiper-button-next-container-modal',
        prevEl: '.swiper-button-prev-container-modal',
      },
      pagination: {
        el: '.swiper-pagination-modal',
        clickable: true,
      },
      autoplay: {
        delay: 1500,
        disableOnInteraction: false,
        pauseOnMouseEnter: true,
      },
      mousewheel: {
        enabled: true,
        eventsTarget: '.modal-overlay',
      },
      zoom: {
        maxRatio: 2,
      },
      updateOnWindowResize: true,
    });
    let isZoomed = false;
    let isMouseDown = false;
    document.querySelectorAll('.swiper-zoom-container').forEach((zoomContainer) => {
      zoomContainer.addEventListener('click', (event2) => {
        event2.stopPropagation();
        if (!isZoomed) {
          swiper.zoom.in();
          isZoomed = true;
        } else if (isMouseDown) {
          swiper.zoom.out();
          isZoomed = false;
        }
      });
      zoomContainer.addEventListener('mousedown', () => {
        isMouseDown = true;
      });
      zoomContainer.addEventListener('mouseup', () => {
        isMouseDown = false;
      });
    });
    modalContainer.addEventListener('classChange', () => {
      if (modalContainer.classList.contains('zoomed')) {
        closeButton.style.zIndex = '0';
      } else {
        closeButton.style.zIndex = '';
      }
    });
    function triggerClassChange() {
      const event2 = new Event('classChange');
      modalContainer.dispatchEvent(event2);
    }
    swiper.on('zoomChange', () => {
      if (swiper.zoom.scale !== 1) {
        modalContainer.classList.remove('zoomed');
        triggerClassChange();
        swiper.autoplay.start();
        swiper.allowSlidePrev = true;
        swiper.allowSlideNext = true;
        swiper.allowTouchMove = true;
        swiper.mousewheel.enable();
      } else {
        modalContainer.classList.add('zoomed');
        triggerClassChange();
        swiper.autoplay.stop();
        swiper.allowSlidePrev = false;
        swiper.allowSlideNext = false;
        swiper.allowTouchMove = false;
        swiper.mousewheel.disable();
      }
    });
    closeButton.addEventListener('click', () => {
      if (swiper) {
        swiper.autoplay.stop();
      }
      modalOverlay.classList.add('hidden');
      modalContainer.classList.add('hidden');
      document.body.style.overflow = 'auto';
      const transitionEndHandler = () => {
        modalOverlay.style.visibility = 'hidden';
        modalOverlay.classList.remove('hidden');
        modalContainer.classList.remove('hidden');
        modalContainer.removeEventListener(
          'transitionend',
          transitionEndHandler,
        );
        modalOverlay.removeEventListener('transitionend', transitionEndHandler);
      };
      modalContainer.addEventListener('transitionend', transitionEndHandler);
      modalOverlay.addEventListener('transitionend', transitionEndHandler);
    });
  }, 0);
  document.body.appendChild(modalOverlay);
  return modalOverlay;
}
Swiper.use([
  Pagination,
  Autoplay,
  Scrollbar,
  Mousewheel,
  EffectCube,
  Navigation,
  Keyboard,
]);
function createSwiper(ID2) {
  const swiperContainerParams = {
    tag: 'div',
    classNames: ['swiper-container'],
  };
  const swiperParams = {
    tag: 'div',
    classNames: ['swiper'],
  };
  const swiperWrapperParams = {
    tag: 'div',
    classNames: ['swiper-wrapper'],
  };
  const swiperSlideParams = {
    tag: 'div',
    classNames: ['swiper-slide'],
  };
  const swiperPaginationParams = {
    tag: 'div',
    classNames: ['swiper-pagination'],
  };
  const swiperScrollbarParams = {
    tag: 'div',
    classNames: ['swiper-scrollbar'],
  };
  const swiperNavigationPrevParams = {
    tag: 'div',
    classNames: ['swiper-button-prev'],
  };
  const swiperNavigationNextParams = {
    tag: 'div',
    classNames: ['swiper-button-next'],
  };
  const swiperNavigationPrevContainerParams = {
    tag: 'div',
    classNames: ['swiper-button-prev-container'],
  };
  const swiperNavigationNextContainerParams = {
    tag: 'div',
    classNames: ['swiper-button-next-container'],
  };
  const swiperContainer = createElement$1(swiperContainerParams);
  const swiperScrollbar = createElement$1(swiperScrollbarParams);
  const swiperPagination = createElement$1(swiperPaginationParams);
  const swiperNavigationPrev = createElement$1(swiperNavigationPrevParams);
  const swiperNavigationNext = createElement$1(swiperNavigationNextParams);
  const swiperNavigationPrevContainer = createElement$1(
    swiperNavigationPrevContainerParams,
  );
  const swiperNavigationNextContainer = createElement$1(
    swiperNavigationNextContainerParams,
  );
  const swiperWrapper = createElement$1(swiperWrapperParams);
  const swiperMain = createElement$1(swiperParams);
  const imgArray = [];
  return getDetailedProduct(ID2).then((result) => {
    var _a, _b;
    if (result !== void 0) {
      const { productResponse, categoryResponses } = result;
      if (productResponse.body) {
        (_a = productResponse.body.masterData.current.masterVariant.images) == null ? void 0 : _a.forEach(
          (image) => {
            const swiperSlide = createElement$1(swiperSlideParams);
            const imgSlideParams = {
              tag: 'img',
              attributes: {
                alt: 'Felt Boots Img',
                src: image.url,
              },
              classNames: ['img-slide'],
            };
            imgArray.push(image.url);
            const imgSlide = createElement$1(imgSlideParams);
            addInnerComponent(swiperSlide, imgSlide);
            addInnerComponent(swiperWrapper, swiperSlide);
          },
        );
        const modalOverlay = modalSwiper(imgArray);
        (_b = document.querySelector('#app')) == null ? void 0 : _b.append(modalOverlay);
        addInnerComponent(swiperMain, swiperWrapper);
        addInnerComponent(swiperMain, swiperPagination);
        addInnerComponent(
          swiperNavigationPrevContainer,
          swiperNavigationPrev,
        );
        addInnerComponent(
          swiperNavigationNextContainer,
          swiperNavigationNext,
        );
        addInnerComponent(swiperMain, swiperNavigationPrevContainer);
        addInnerComponent(swiperMain, swiperNavigationNextContainer);
        addInnerComponent(swiperMain, swiperScrollbar);
        addInnerComponent(swiperContainer, swiperMain);
        setTimeout(() => {
          new Swiper('.swiper', {
            direction: 'horizontal',
            loop: true,
            speed: 1e3,
            preventClicks: true,
            keyboard: {
              enabled: false,
              onlyInViewport: true,
            },
            effect: 'cube',
            cubeEffect: {
              slideShadows: true,
            },
            navigation: {
              nextEl: '.swiper-button-next-container',
              prevEl: '.swiper-button-prev-container',
            },
            pagination: {
              el: '.swiper-pagination',
              clickable: true,
            },
            autoplay: {
              delay: 1e3,
              disableOnInteraction: false,
              pauseOnMouseEnter: true,
            },
            scrollbar: {
              el: '.swiper-scrollbar',
              draggable: true,
            },
            mousewheel: {
              enabled: true,
              eventsTarget: '.swiper',
            },
            updateOnWindowResize: true,
            preventClicksPropagation: true,
            simulateTouch: true,
            resizeObserver: true,
            grabCursor: true,
          });
        }, 0);
        swiperWrapper.addEventListener('click', (e) => {
          e.preventDefault();
          modalOverlay.style.visibility = 'visible';
          document.body.style.overflow = 'hidden';
        });
        return {
          swiperContainer,
          response: productResponse,
          categoryResponses,
        };
      } else {
        throw new Error('No product details found');
      }
    } else {
      throw new Error('No product details found');
    }
  }).catch((error) => {
    if (isCustomError(error)) {
      showToast(error.body.message);
    } else if (error instanceof Error) {
      showToast(error.message);
    } else {
      showToast('An unknown error occurred');
    }
    throw error;
  });
}
function createIconContainer(imageUrl, text1, text2, containerClasses = [], imageContainerClasses = [], textContainerClasses = [], text1Classes = [], text2Classes = []) {
  const containerParams = {
    tag: 'div',
    classNames: ['icon_container', ...containerClasses],
  };
  const imageContainerParams = {
    tag: 'div',
    classNames: imageContainerClasses,
  };
  const imageParams = {
    tag: 'img',
    attributes: {
      alt: 'Delivery/Guarantee/Stock icon',
      src: imageUrl,
    },
  };
  const textContainerParams = {
    tag: 'div',
    classNames: textContainerClasses,
  };
  const text1Params = {
    tag: 'div',
    textContent: text1,
    classNames: text1Classes,
  };
  const text2Params = {
    tag: 'div',
    textContent: text2,
    classNames: text2Classes,
  };
  const container = createElement$1(containerParams);
  const imageContainer = createElement$1(imageContainerParams);
  const image = createElement$1(imageParams);
  const textContainer = createElement$1(textContainerParams);
  const text1Element = createElement$1(text1Params);
  const text2Element = createElement$1(text2Params);
  addInnerComponent(imageContainer, image);
  addInnerComponent(textContainer, text1Element);
  addInnerComponent(textContainer, text2Element);
  addInnerComponent(container, imageContainer);
  addInnerComponent(container, textContainer);
  return container;
}
function productDetailedPageComponent(ID2) {
  const detailedProductContainerParams = {
    tag: 'section',
    classNames: ['product_detailed_container'],
  };
  const detailedProductContainer = createElement$1(
    detailedProductContainerParams,
  );
  createSwiper(ID2).then(
    ({
      swiperContainer,
      response,
      categoryResponses,
    }) => {
      var _a, _b, _c, _d, _e, _f;
      const replaceDashWithPlus = (text) => text.replace(/-/g, '+');
      const breadcrumbs = [
        { name: 'home', url: '/' },
        { name: 'catalog', url: '/catalog' },
      ];
      if (categoryResponses.length > 0) {
        breadcrumbs.push({
          name: categoryResponses[0].body.name['en-US'],
          url: `/catalog?category=${replaceDashWithPlus(categoryResponses[0].body.name['en-US'])}`,
        });
      }
      if (categoryResponses.length > 1) {
        breadcrumbs.push({
          name: categoryResponses[1].body.name['en-US'],
          url: `/catalog?category=${replaceDashWithPlus(categoryResponses[1].body.name['en-US'])}`,
        });
      }
      const breadCrumbsContainer = generateBreadcrumbLinks(breadcrumbs);
      const productData = response.body.masterData.current;
      addInnerComponent(detailedProductContainer, breadCrumbsContainer);
      addInnerComponent(detailedProductContainer, swiperContainer);
      const attributes = productData.masterVariant.attributes;
      const descriptionContainerParams = {
        tag: 'div',
        classNames: ['description_container'],
      };
      const descriptionContainer = createElement$1(descriptionContainerParams);
      const productTitleParams = {
        tag: 'h2',
        classNames: ['product_title'],
        textContent: productData.name['en-US'] || 'Product Name',
      };
      const productTitle = createElement$1(productTitleParams);
      const productPriceContainerParams = {
        tag: 'div',
        classNames: ['price_container'],
      };
      const hasDiscount = ((_a = productData.masterVariant) == null ? void 0 : _a.prices) && ((_b = productData.masterVariant.prices[0]) == null ? void 0 : _b.discounted);
      const productPriceParams = {
        tag: 'h3',
        classNames: hasDiscount ? ['product_price', 'discounted_price'] : ['product_price'],
        textContent: ((_c = productData.masterVariant) == null ? void 0 : _c.prices) && productData.masterVariant.prices[0] ? `$${(productData.masterVariant.prices[0].value.centAmount / 100).toFixed(2)}` : 'Price not available',
      };
      const productDiscountPriceParams = {
        tag: 'span',
        classNames: ['discount_price'],
        textContent: hasDiscount ? `$${((((_e = (_d = productData.masterVariant.prices[0]) == null ? void 0 : _d.discounted) == null ? void 0 : _e.value.centAmount) ?? 0) / 100).toFixed(2)}` : '',
      };
      const productPriceContainer = createElement$1(
        productPriceContainerParams,
      );
      const productPrice = createElement$1(productPriceParams);
      const productDiscountPrice = createElement$1(productDiscountPriceParams);
      addInnerComponent(productPriceContainer, productPrice);
      if (hasDiscount) {
        addInnerComponent(productPriceContainer, productDiscountPrice);
      }
      addInnerComponent(descriptionContainer, productTitle);
      addInnerComponent(descriptionContainer, productPriceContainer);
      const productDescriptionText = ((_f = productData.description) == null ? void 0 : _f['en-US']) || 'There should be a description... But it is missing somehow';
      const productDescriptionParams = {
        tag: 'p',
        classNames: ['product_description'],
        textContent: productDescriptionText,
      };
      const productDescription = createElement$1(productDescriptionParams);
      const sizeContainerParams = {
        tag: 'div',
        classNames: ['size_container'],
      };
      const sizeContainer = createElement$1(sizeContainerParams);
      const sizeTitleParams = {
        tag: 'h3',
        classNames: ['size_title'],
        textContent: 'Choose your size:',
      };
      const sizeTitle = createElement$1(sizeTitleParams);
      addInnerComponent(sizeContainer, sizeTitle);
      const sizeButtonContainerParams = {
        tag: 'div',
        classNames: ['size_button_container'],
      };
      const sizeButtonContainer = createElement$1(sizeButtonContainerParams);
      addInnerComponent(sizeContainer, sizeButtonContainer);
      const sizes = [];
      if (productData.masterVariant.attributes) {
        const sizeAttribute = attributes == null ? void 0 : attributes.find(
          (attr) => attr.name === 'size',
        );
        const firstSize = sizeAttribute ? sizeAttribute.value : void 0;
        sizes.push(firstSize);
      }
      productData.variants.forEach((variant) => {
        if (variant.attributes) {
          variant.attributes.forEach((attribute) => {
            if (attribute.name === 'size' && Array.isArray(attribute.value)) {
              attribute.value.forEach((size) => {
                if (typeof size === 'number') {
                  sizes.push(size);
                }
              });
            }
          });
        }
      });
      sizes.sort((a, b) => a - b);
      sizes.forEach((size) => {
        const sizeButtonParams = {
          tag: 'button',
          classNames: ['size_button'],
          textContent: size.toString(),
        };
        const sizeButton = createElement$1(sizeButtonParams);
        sizeButton.addEventListener('click', () => {
          const allSizeButtons = sizeContainer.querySelectorAll('.size_button');
          allSizeButtons.forEach((btn) => {
            btn.classList.remove('__selected');
          });
          sizeButton.classList.add('__selected');
        });
        addInnerComponent(sizeButtonContainer, sizeButton);
      });
      const addToCartBtnParams = {
        tag: 'button',
        classNames: ['add_to_cart', 'button'],
        textContent: 'Add to Cart',
        attributes: {
          type: 'button',
        },
      };
      const errorMessageParams = {
        tag: 'span',
        classNames: ['error_message'],
        textContent: 'Choose size first!',
        attributes: {
          style: 'visibility: hidden; color: red;',
        },
      };
      const errorMessage = createElement$1(errorMessageParams);
      const addToCartBtn = createElement$1(addToCartBtnParams);
      const iconsContainerParams = {
        tag: 'div',
        classNames: ['icons_container'],
      };
      addToCartBtn.addEventListener('click', () => {
        const selectedSizeButton = sizeContainer.querySelector(
          '.size_button.__selected',
        );
        if (!selectedSizeButton) {
          errorMessage.style.visibility = 'visible';
        } else {
          errorMessage.style.visibility = 'hidden';
        }
      });
      const deliveryIconContainer = createIconContainer(
        '../assets/detailedProduct/Delivery.png',
        'Free Delivery',
        '1-2 days',
        ['delivery'],
        ['delivery_icon_container'],
        ['text_container'],
        ['text_top'],
        ['text_bottom'],
      );
      const stockIconContainer = createIconContainer(
        '../assets/detailedProduct/Stock.png',
        'In Stock',
        'Today',
        ['stock'],
        ['stock_icon_container'],
        ['text_container'],
        ['text_top'],
        ['text_bottom'],
      );
      const guaranteedIconContainer = createIconContainer(
        '../assets/detailedProduct/Guaranteed.png',
        'Guaranteed',
        '1 year',
        ['guaranteed'],
        ['guaranteed_icon_container'],
        ['text_container'],
        ['text_top'],
        ['text_bottom'],
      );
      const iconsContainer = createElement$1(iconsContainerParams);
      addInnerComponent(iconsContainer, deliveryIconContainer);
      addInnerComponent(iconsContainer, stockIconContainer);
      addInnerComponent(iconsContainer, guaranteedIconContainer);
      addInnerComponent(descriptionContainer, sizeContainer);
      addInnerComponent(descriptionContainer, productDescription);
      addInnerComponent(descriptionContainer, errorMessage);
      addInnerComponent(descriptionContainer, addToCartBtn);
      addInnerComponent(descriptionContainer, iconsContainer);
      addInnerComponent(detailedProductContainer, descriptionContainer);
    },
  ).catch((error) => {
    if (isCustomError(error)) {
      showToast(error.body.message);
    } else if (error instanceof Error) {
      showToast(error.message);
    } else {
      showToast('An unknown error occurred');
    }
    throw error;
  });
  return detailedProductContainer;
}
function createDetailedProductPage(params) {
  if (!params || !params.id) {
    const errorContainer = createElement$1({
      tag: 'div',
      classNames: ['error'],
      textContent: 'Product ID not found.',
    });
    return errorContainer;
  }
  const productContainerParams = {
    tag: 'section',
    classNames: ['product_container'],
  };
  const productContainer = createElement$1(productContainerParams);
  const header = createHeader();
  productContainer.prepend(header);
  const productDetailedContainer = productDetailedPageComponent(params.id);
  addInnerComponent(productContainer, productDetailedContainer);
  return productContainer;
}
const infoReadvalidStatus = {
  name: true,
};
function setInfoReadvalidStatus(field, value) {
  infoReadvalidStatus[field] = value;
}
function randomString() {
  const characters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let result = '';
  for (let i = 0; i < 16; i++) {
    result += characters.charAt(Math.floor(Math.random() * characters.length));
  }
  return result;
}
async function showClick(e) {
  e.preventDefault();
  let elem = e.target;
  if (!elem.classList.contains('profile-header__btn-edit')) {
    setInfoReadvalidStatus('name', true);
    const parent = elem.parentElement;
    elem = findElement(parent, 'profile-header__btn-edit');
    elem.setAttribute('disabled', '');
    elem.textContent = 'Edit';
  }
  const form = elem.form;
  const name = form.elements.namedItem('Name');
  const lastName = form.elements.namedItem('Last Name');
  const date = form.elements.namedItem('Date');
  const email = form.elements.namedItem('Email');
  const post = Array.from(
    form.elements.namedItem('post'),
  );
  const city = Array.from(
    form.elements.namedItem('city'),
  );
  const street = Array.from(
    form.elements.namedItem('street'),
  );
  const postElem = form.elements.namedItem('post');
  const cityElem = form.elements.namedItem('city');
  const streetElem = form.elements.namedItem('street');
  elem.classList.toggle('btn-edit--active');
  const countrie = [
    findElement(form, 'address-prof__countries-list'),
  ];
  const countries = Array.from(getCountriesList(post));
  if (!isEmptyArray(post) && !isEmptyArray(city) && !isEmptyArray(street)) {
    if (name && lastName && date && post && city && street && email) {
      toggleReadOnly(
        countries,
        name,
        lastName,
        date,
        email,
        ...post,
        ...city,
        ...street,
      );
    }
  } else {
    if (name && lastName && date && postElem && cityElem && streetElem && email) {
      toggleReadOnly(
        countrie,
        name,
        lastName,
        date,
        email,
        postElem,
        cityElem,
        streetElem,
      );
    }
  }
  fillObjectWithUniqueKeys(form, true, validStatus);
  checkAllInputs();
  changeText(elem);
}
function changeText(text) {
  if (text.innerHTML === 'Edit') {
    text.innerHTML = 'Save';
  } else {
    text.innerHTML = 'Edit';
  }
}
async function toggleReadOnly(countries, ...args) {
  const result = [];
  const data = await getUserData();
  if (infoReadvalidStatus.name) {
    args.flat().forEach((e) => {
      e.removeAttribute('readonly');
      dateToggleReadonly(e);
    });
    countries.forEach((e) => {
      e.classList.remove('readonly');
      removeCheckBoxDisabled(e, infoReadvalidStatus.name);
      e.addEventListener('click', addCountriesList, true);
    });
    setInfoReadvalidStatus('name', false);
  } else {
    const body = {
      version: data.version,
      actions: [],
    };
    args.flat().forEach((e) => {
      dateToggleReadonly(e);
      const act = checkInput(e, data);
      result.push(...act);
      e.setAttribute('readonly', '');
    });
    countries.forEach((e) => {
      removeCheckBoxDisabled(e, infoReadvalidStatus.name);
      e.classList.add('readonly');
      e.removeEventListener('click', addCountriesList, true);
    });
    body.actions = result;
    console.log(body);
    updateCustomer(body);
    setInfoReadvalidStatus('name', true);
    const deleteBtns = document.querySelectorAll(
      '.address-prof-container__delete-btn',
    );
    deleteBtns.forEach((btn) => {
      btn.removeAttribute('disabled');
    });
  }
}
function checkInput(elem, data) {
  var _a;
  const result = [];
  if (elem.getAttribute('name') === 'Name') {
    const action = {
      action: 'setFirstName',
      firstName: elem.value,
    };
    result.push(action);
  } else if (elem.getAttribute('name') === 'Last Name') {
    const action = {
      action: 'setLastName',
      lastName: elem.value,
    };
    result.push(action);
  } else if (elem.getAttribute('name') === 'Email') {
    const action = {
      action: 'changeEmail',
      email: elem.value,
    };
    result.push(action);
  } else if (elem.getAttribute('name') === 'Date') {
    const month = elem.previousSibling;
    const day = month == null ? void 0 : month.previousSibling;
    const DOB = `${elem.value.padStart(4, '0')}-${month.value.padStart(2, '0')}-${day.value.padStart(2, '0')}`;
    const action = {
      action: 'setDateOfBirth',
      dateOfBirth: DOB,
    };
    result.push(action);
  } else if (elem.getAttribute('name') === 'post') {
    const ancestor = (_a = elem.parentElement) == null ? void 0 : _a.parentElement;
    const indicator = findElement(
      ancestor,
      'address-prof__country-indicator',
    );
    const city = findElement(
      ancestor,
      'profile-form__city-input',
    );
    const street = findElement(
      ancestor,
      'profile-form__street-input',
    );
    const country = findElement(
      ancestor,
      'address-prof__countries-list',
    );
    const countryNames = countrys.names();
    const countryIndex = countryNames.indexOf(country.textContent);
    const capitalСountries = Object.keys(countrys.all)[countryIndex];
    const id = elem.getAttribute('addressid');
    const billingAddress = data.billingAddressIds;
    const shippingAddressIds = data.shippingAddressIds;
    const shippingDefaultCheck = findElement(
      ancestor,
      'shipping-checkbox-container__default-shipping-checkbox',
    );
    const shippingCheck = findElement(
      ancestor,
      'shipping-checkbox-container__shipping-checkbox',
    );
    const billingDefaultCheck = findElement(
      ancestor,
      'billing-checkbox-container__default-billing-checkbox',
    );
    const billingCheck = findElement(
      ancestor,
      'billing-checkbox-container__billing-checkbox',
    );
    if (id) {
      if (billingCheck.checked) {
        const action = {
          action: 'addBillingAddressId',
          addressId: id,
        };
        indicator.textContent = 'Billing Address';
        result.push(action);
      }
      if (!billingCheck.checked && (billingAddress == null ? void 0 : billingAddress.find((element) => element === id))) {
        const action = {
          action: 'removeBillingAddressId',
          addressId: id,
        };
        result.push(action);
      }
      if (shippingDefaultCheck.checked) {
        const action = {
          action: 'setDefaultShippingAddress',
          addressId: id,
        };
        indicator.textContent = 'Default Shipping Address';
        result.push(action);
      }
      if (billingDefaultCheck.checked) {
        const action = {
          action: 'setDefaultBillingAddress',
          addressId: id,
        };
        indicator.textContent = 'Default Billing Address';
        result.push(action);
      }
      if (shippingCheck.checked) {
        const action = {
          action: 'addShippingAddressId',
          addressId: id,
        };
        indicator.textContent = ' Shipping Address';
        result.push(action);
      }
      if (!shippingCheck.checked && (shippingAddressIds == null ? void 0 : shippingAddressIds.find((element) => element === id))) {
        const action = {
          action: 'removeShippingAddressId',
          addressId: id,
        };
        result.push(action);
      }
      if (billingCheck.checked && shippingCheck.checked) {
        indicator.textContent = 'Shipping and Billing Address';
      }
      if (billingDefaultCheck.checked && shippingDefaultCheck.checked) {
        indicator.textContent = ' Default Shipping and Billing Address';
      }
      if (!billingDefaultCheck.checked && !shippingDefaultCheck.checked && !billingCheck.checked && !shippingCheck.checked) {
        indicator.textContent = 'Address';
      }
    }
    if (city && street && id) {
      if (elem.getAttribute('addressid') === id) {
        console.log(1);
        const action = {
          action: 'changeAddress',
          addressId: id,
          address: {
            key: randomString(),
            city: city.value,
            postalCode: elem.value,
            streetName: street.value,
            country: capitalСountries,
          },
        };
        result.push(action);
      }
    }
  }
  return result;
}
function dateToggleReadonly(e) {
  if (e.classList.contains('date__year')) {
    const month = e.previousSibling;
    const day = month == null ? void 0 : month.previousSibling;
    if (infoReadvalidStatus.name) {
      month == null ? void 0 : month.removeAttribute('readonly');
      day == null ? void 0 : day.removeAttribute('readonly');
    } else {
      month == null ? void 0 : month.setAttribute('readonly', '');
      day == null ? void 0 : day.setAttribute('readonly', '');
    }
  }
}
function removeCheckBoxDisabled(e, status) {
  const parent = e.parentElement;
  const defaultShipping = findElement(
    parent,
    'shipping-checkbox-container__default-shipping-checkbox',
  );
  const shipping = findElement(
    parent,
    'shipping-checkbox-container__shipping-checkbox',
  );
  const defaultBilling = findElement(
    parent,
    'billing-checkbox-container__billing-checkbox',
  );
  const billing = findElement(
    parent,
    'billing-checkbox-container__default-billing-checkbox',
  );
  if (status) {
    defaultShipping.removeAttribute('disabled');
    shipping.removeAttribute('disabled');
    defaultBilling.removeAttribute('disabled');
    billing.removeAttribute('disabled');
  } else {
    defaultShipping.setAttribute('disabled', '');
    shipping.setAttribute('disabled', '');
    defaultBilling.setAttribute('disabled', '');
    billing.setAttribute('disabled', '');
  }
}
async function createEdit() {
  const infoHeaderButtonParams = {
    tag: 'button',
    classNames: ['profile-header__btn-edit', 'profile-btn'],
    textContent: 'Edit',
    attributes: { form: 'profile-form' },
  };
  const showClickHandler = (e) => {
    e.preventDefault();
    showClick(e);
  };
  const infoEditButton = createElement$1(infoHeaderButtonParams);
  infoEditButton.addEventListener('click', showClickHandler);
  return infoEditButton;
}
function checkLength(name) {
  if (name.length > 20) {
    return name = name.slice(0, 20) + '...';
  } else {
    return name;
  }
}
function buildPasswordBtn(userData) {
  const passwordButtonParams = {
    tag: 'button',
    classNames: ['profile-header__btn-password', 'profile-btn'],
    textContent: 'Password Change',
  };
  const passwordButton = createElement$1(passwordButtonParams);
  const addPasswordModalHandler = () => {
    addPasswordModal(userData);
  };
  passwordButton.addEventListener('click', addPasswordModalHandler);
  return passwordButton;
}
function buildRadioCountry() {
  const checkBoxContainerParams = {
    tag: 'div',
    classNames: ['indicator-container__checkbox-container'],
  };
  const checkBoxContainer = createElement$1(checkBoxContainerParams);
  const billingCheckBoxContainerParams = {
    tag: 'div',
    classNames: ['billing-checkbox-container'],
  };
  const shippingCheckBoxContainerParams = {
    tag: 'div',
    classNames: ['shipping-checkbox-container'],
  };
  const shippingCheckBoxContainer = createElement$1(
    shippingCheckBoxContainerParams,
  );
  const billingCheckBoxContainer = createElement$1(
    billingCheckBoxContainerParams,
  );
  addInnerComponent(checkBoxContainer, shippingCheckBoxContainer);
  addInnerComponent(checkBoxContainer, billingCheckBoxContainer);
  const [defaultShippingLabel, defaultShippingCheckBox] = createInput(
    randomString(),
    [
      [
        'shipping-checkbox-container__default-shipping-label',
        'address-checkbox-label',
      ],
      [
        'shipping-checkbox-container__default-shipping-checkbox',
        'address-checkbox',
      ],
    ],
    'defaultShipping',
    'checkbox',
  );
  defaultShippingLabel.textContent = 'Use as default shipping address';
  addInnerComponent(defaultShippingLabel, defaultShippingCheckBox);
  const [shippingLabel, shippingCheckBox] = createInput(
    randomString(),
    [
      ['shipping-checkbox-container__shipping-label', 'address-checkbox-label'],
      ['shipping-checkbox-container__shipping-checkbox', 'address-checkbox'],
    ],
    'shipping',
    'checkbox',
  );
  shippingLabel.textContent = 'Use as shipping address';
  addInnerComponent(shippingLabel, shippingCheckBox);
  const [defaultBillingLabel, defaultBillingCheckBox] = createInput(
    randomString(),
    [
      [
        'shipping-checkbox-container__default-billing-label',
        'address-checkbox-label',
      ],
      [
        'billing-checkbox-container__default-billing-checkbox',
        'address-checkbox',
      ],
    ],
    'defaultBilling',
    'checkbox',
  );
  defaultBillingLabel.textContent = 'Use as default billing address';
  addInnerComponent(defaultBillingLabel, defaultBillingCheckBox);
  const [billingLabel, billingCheckBox] = createInput(
    randomString(),
    [
      ['billing-checkbox-container__billing-label', 'address-checkbox-label'],
      ['billing-checkbox-container__billing-checkbox', 'address-checkbox'],
    ],
    'billing',
    'checkbox',
  );
  billingLabel.textContent = 'Use as billing address';
  addInnerComponent(billingLabel, billingCheckBox);
  addInnerComponent(shippingCheckBoxContainer, defaultShippingLabel);
  addInnerComponent(shippingCheckBoxContainer, shippingLabel);
  addInnerComponent(billingCheckBoxContainer, defaultBillingLabel);
  addInnerComponent(billingCheckBoxContainer, billingLabel);
  defaultShippingLabel.addEventListener('click', preventLabelDefault);
  shippingLabel.addEventListener('click', preventLabelDefault);
  defaultBillingLabel.addEventListener('click', preventLabelDefault);
  billingLabel.addEventListener('click', preventLabelDefault);
  defaultShippingCheckBox.setAttribute('hide', '');
  defaultBillingCheckBox.setAttribute('hide', '');
  shippingCheckBox.setAttribute('hide', '');
  billingCheckBox.setAttribute('hide', '');
  defaultShippingCheckBox.setAttribute('disabled', '');
  defaultBillingCheckBox.setAttribute('disabled', '');
  shippingCheckBox.setAttribute('disabled', '');
  billingCheckBox.setAttribute('disabled', '');
  defaultShippingCheckBox.removeAttribute('required');
  defaultBillingCheckBox.removeAttribute('required');
  shippingCheckBox.removeAttribute('required');
  billingCheckBox.removeAttribute('required');
  defaultShippingCheckBox.addEventListener('click', toggleCheckBox);
  defaultBillingCheckBox.addEventListener('click', toggleCheckBox);
  shippingCheckBox.addEventListener('click', toggleCheckBox);
  billingCheckBox.addEventListener('click', toggleCheckBox);
  return [
    checkBoxContainer,
    defaultShippingCheckBox,
    defaultBillingCheckBox,
    shippingCheckBox,
    billingCheckBox,
  ];
}
function preventLabelDefault(e) {
  e.preventDefault();
}
function toggleCheckBox(e) {
  e.stopPropagation();
  const elem = e.target;
  if (elem.classList.contains(
    'shipping-checkbox-container__default-shipping-checkbox',
  ) || elem.classList.contains(
    'billing-checkbox-container__default-billing-checkbox',
  )) {
    const form = elem.form;
    const similarElems = findElement(
      form,
      elem.classList[0],
      true,
    );
    similarElems.forEach((el) => {
      if (el != elem) {
        el.checked = false;
      }
    });
  }
}
function buildProfileCountry(currentId, billingId, shippingId, defaultBillingId, defaultShippingId) {
  const countryContainerParam = {
    tag: 'div',
    classNames: ['address-prof__country-container', 'country-wrapper'],
  };
  const countryIndicatorContainerParams = {
    tag: 'div',
    classNames: ['address-prof__country-indicator-container'],
  };
  const countryIndicatorContainer = createElement$1(
    countryIndicatorContainerParams,
  );
  const countryContainer = createElement$1(countryContainerParam);
  const countriesListParams = {
    tag: 'div',
    classNames: ['address-prof__countries-list', 'countries-list', 'readonly'],
  };
  const countriesInpunParams = {
    tag: 'input',
    classNames: ['address-prof-input', 'reg-input'],
    attributes: { type: 'text', placeholder: 'Enter your country', hide: '' },
  };
  const countryIndicatorParams = {
    tag: 'div',
    classNames: ['address-prof__country-indicator'],
  };
  const countryIndicator = createElement$1(countryIndicatorParams);
  const [
    radioContainer,
    defaultShippingCheckBox,
    defaltBillingCheckBox,
    shippingCheckBox,
    billingCheckBox,
  ] = buildRadioCountry();
  addInnerComponent(countryContainer, countryIndicatorContainer);
  addInnerComponent(countryIndicatorContainer, countryIndicator);
  addInnerComponent(countryIndicatorContainer, radioContainer);
  const countriesInput = createElement$1(countriesInpunParams);
  const countriesList = createElement$1(countriesListParams);
  if (currentId !== void 0) {
    let isBilling = false;
    let isShipping = false;
    billingId == null ? void 0 : billingId.forEach((e) => {
      if (currentId === e) {
        billingCheckBox.setAttribute('checked', '');
        countryIndicator.textContent = 'Billing Address';
        isBilling = true;
        if (currentId === defaultBillingId) {
          defaltBillingCheckBox.setAttribute('checked', '');
          countryIndicator.textContent = 'Default Billing Address';
        }
      }
    });
    shippingId == null ? void 0 : shippingId.forEach((e) => {
      if (currentId === e) {
        shippingCheckBox.setAttribute('checked', '');
        countryIndicator.textContent = 'Shipping Address';
        isShipping = true;
        if (currentId === defaultShippingId) {
          defaultShippingCheckBox.setAttribute('checked', '');
          countryIndicator.textContent = 'Default Shipping Address';
        }
      }
    });
    if (!isBilling && !isShipping) {
      countryIndicator.textContent = 'Address';
    }
    if (isBilling && isShipping) {
      countryIndicator.textContent = 'Billing and Shipping Address';
    }
  } else {
    countryIndicator.textContent = 'Address';
  }
  if (defaultShippingCheckBox.checked && defaltBillingCheckBox.checked) {
    countryIndicator.textContent = 'Default Shipping and Billing Address';
  }
  addInnerComponent(countryContainer, countriesInput);
  addInnerComponent(countryContainer, countriesList);
  return [countryContainer, countriesList];
}
function buildProfileAddressLoyalt() {
  const cityLabelParams = {
    tag: 'label',
    classNames: ['profile-form__city-label', 'prof-label', 'label-city'],
    attributes: { name: 'city', 'data-validation-type': 'city' },
    textContent: 'City',
  };
  const cityInputParams = {
    tag: 'input',
    classNames: ['profile-form__city-input', 'prof-input', 'input-city'],
    attributes: {
      name: 'city',
      'data-validation-type': 'city',
      readonly: '',
      placeholder: 'Enter your City',
    },
  };
  const cityLabel = createElement$1(cityLabelParams);
  const cityInput = createElement$1(cityInputParams);
  const profileCityError = createErrorElement();
  addInnerComponent(cityLabel, cityInput);
  addInnerComponent(cityLabel, profileCityError);
  cityInput.addEventListener('input', validateInput);
  const postLabelParams = {
    tag: 'label',
    classNames: ['profile-form__post-label', 'prof-label', 'label-post'],
    attributes: { name: 'post', 'data-validation-type': 'post' },
    textContent: 'Post',
  };
  const postInputParams = {
    tag: 'input',
    classNames: ['profile-form__post-input', 'prof-input', 'input-post'],
    attributes: {
      name: 'post',
      'data-validation-type': 'post',
      readonly: '',
      placeholder: 'Enter your Post Code',
    },
  };
  const postLabel = createElement$1(postLabelParams);
  const postInput = createElement$1(postInputParams);
  postInput.addEventListener('input', validateInput);
  const profilePostError = createErrorElement();
  addInnerComponent(postLabel, postInput);
  addInnerComponent(postLabel, profilePostError);
  const streetLabelParams = {
    tag: 'label',
    classNames: ['profile-form__street-label', 'prof-label', 'label-street'],
    attributes: { name: 'street', 'data-validation-type': 'street' },
    textContent: 'Street',
  };
  const streetInputParams = {
    tag: 'input',
    classNames: ['profile-form__street-input', 'prof-input', 'input-street'],
    attributes: {
      name: 'street',
      'data-validation-type': 'street',
      readonly: '',
      placeholder: 'Enter your Street',
    },
  };
  const streetLabel = createElement$1(streetLabelParams);
  const streetInput = createElement$1(streetInputParams);
  streetInput.addEventListener('input', validateInput);
  const profileStreetError = createErrorElement();
  addInnerComponent(streetLabel, streetInput);
  addInnerComponent(streetLabel, profileStreetError);
  return [streetLabel, cityLabel, postLabel, streetInput, cityInput, postInput];
}
function buildDeleteAddressBtn() {
  const deleteAddressBtnParams = {
    tag: 'button',
    classNames: ['address-prof-container__delete-btn', 'profile-btn'],
    textContent: 'Delete Address',
  };
  const deleteAddressBtn = createElement$1(deleteAddressBtnParams);
  deleteAddressBtn.addEventListener('click', clickDeleteButton);
  return deleteAddressBtn;
}
async function clickDeleteButton(e) {
  var _a;
  e.preventDefault();
  const elem = e.target;
  const parent = elem.parentElement;
  const ancestor = parent == null ? void 0 : parent.parentElement;
  const form = ancestor == null ? void 0 : ancestor.parentElement;
  const deleteButtons = Array.from(
    (ancestor == null ? void 0 : ancestor.querySelectorAll('.address-prof-container__delete-btn')) || [],
  );
  const post = findElement(
    parent,
    'profile-form__post-input',
  );
  const userData = await getUserData();
  const addressList = userData.addresses.reverse();
  const index = deleteButtons.indexOf(elem);
  const id = post.getAttribute('addressid');
  if (((_a = addressList[index]) == null ? void 0 : _a.id) === void 0) {
    parent == null ? void 0 : parent.remove();
    fillObjectWithUniqueKeys(form, false, validStatus);
    checkAllInputs();
  } else {
    if (id) {
      const body = {
        version: userData.version,
        actions: [
          {
            action: 'removeAddress',
            addressId: id,
          },
        ],
      };
      parent == null ? void 0 : parent.remove();
      updateCustomer(body);
      fillObjectWithUniqueKeys(form, false, validStatus);
      console.log(validStatus);
      checkAllInputs();
    }
  }
}
function buildAddressProfile(customerData) {
  const addressInfoContainerParams = {
    tag: 'div',
    classNames: ['profile-form__address-prof-container'],
  };
  const addressInfoContainer = createElement$1(addressInfoContainerParams);
  if (customerData) {
    const reverseCustomret = customerData.addresses.reverse();
    reverseCustomret.forEach((e) => {
      if (e.id) {
        const currentId = e.id;
        const deleteBtn = buildDeleteAddressBtn();
        const bullingId = customerData.billingAddressIds;
        const shippingId = customerData.shippingAddressIds;
        const shippingDefaultId = customerData.defaultShippingAddressId;
        const billingDefaultId = customerData.defaultBillingAddressId;
        const city = e.city ? e.city : '';
        const post = e.postalCode ? e.postalCode : '';
        const country = countrys.findByIso2(e.country);
        const street = e.streetName ? e.streetName : '';
        const addressInfWrapperParams = {
          tag: 'div',
          classNames: ['address-prof-container__address-wrapper'],
        };
        const addressInfWrapper = createElement$1(addressInfWrapperParams);
        const [countriesContainer, countriesList] = buildProfileCountry(
          currentId,
          bullingId,
          shippingId,
          billingDefaultId,
          shippingDefaultId,
        );
        const [
          streetLabel,
          cityLabel,
          postLabel,
          streetInput,
          cityInput,
          postInput,
        ] = buildProfileAddressLoyalt();
        cityInput.value = city;
        const key = randomString();
        postInput.setAttribute('addressId', e.id);
        postInput.setAttribute('addressKey', key);
        postInput.value = post;
        countriesList.textContent = country.name;
        streetInput.value = street;
        addInnerComponent(addressInfoContainer, addressInfWrapper);
        addInnerComponent(addressInfWrapper, countriesContainer);
        addInnerComponent(addressInfWrapper, postLabel);
        addInnerComponent(addressInfWrapper, cityLabel);
        addInnerComponent(addressInfWrapper, streetLabel);
        addInnerComponent(addressInfWrapper, deleteBtn);
      }
    });
  }
  return addressInfoContainer;
}
function addEmptyCountryList() {
  const addressInfWrapperParams = {
    tag: 'div',
    classNames: ['address-prof-container__address-wrapper'],
  };
  const addressInfWrapper = createElement$1(addressInfWrapperParams);
  const [countriesContainer, countriesList] = buildProfileCountry(
    void 0,
    void 0,
    void 0,
    void 0,
    void 0,
  );
  const [streetLabel, cityLabel, postLabel, streetInput, cityInput, postInput] = buildProfileAddressLoyalt();
  const deleteBtn = buildDeleteAddressBtn();
  addInnerComponent(addressInfWrapper, countriesContainer);
  addInnerComponent(addressInfWrapper, postLabel);
  addInnerComponent(addressInfWrapper, cityLabel);
  addInnerComponent(addressInfWrapper, streetLabel);
  addInnerComponent(addressInfWrapper, deleteBtn);
  cityInput.value = '';
  postInput.value = '';
  countriesList.textContent = 'Chose your Country';
  streetInput.value = '';
  streetInput.setAttribute('disabled', '');
  postInput.setAttribute('disabled', '');
  cityInput.setAttribute('disabled', '');
  return addressInfWrapper;
}
let counter = 0;
async function buildAddAddressBtn() {
  const addAddressBtnParams = {
    tag: 'button',
    classNames: ['profile-header__btn-add-address', 'profile-btn'],
    textContent: 'Add Address',
    attributes: { form: 'profile-form' },
  };
  const addAddressBtn = createElement$1(addAddressBtnParams);
  addAddressBtn.addEventListener('click', async (e) => {
    e.preventDefault();
    await addAddress(e);
  });
  return addAddressBtn;
}
async function addAddress(e) {
  const userData = await getUserData();
  if (userData) {
    const elem = e.target;
    const form = elem.form;
    const newAddress = addEmptyCountryList();
    const addressContainer = findElement(
      form,
      'profile-form__address-prof-container',
    );
    if (newAddress) {
      counter--;
      newAddress.style.order = counter.toString();
      addressContainer.append(newAddress);
    }
    fillObjectWithUniqueKeys(form, false, validStatus);
    const body = {
      version: userData.version,
      actions: [
        {
          action: 'addAddress',
          address: {
            key: randomString(),
            city: 'Chose Your Country',
            postalCode: 'Chose Your Country',
            streetName: 'Chose Your Country',
            country: 'AF',
          },
        },
      ],
    };
    await updateCustomer(body);
    const post = findElement(
      newAddress,
      'profile-form__post-input',
    );
    const newUSerdata = await getUserData();
    const id = newUSerdata.addresses[newUSerdata.addresses.length - 1].id;
    if (id) {
      post.setAttribute('addressid', id);
    }
    if (infoReadvalidStatus) {
      setInfoReadvalidStatus('name', true);
    }
    elem.setAttribute('disabled', '');
    const saveBtn = document.querySelector(
      '.profile-header__btn-edit',
    );
    saveBtn.textContent = 'Edit';
  }
}
async function buildProfileHeader(userData) {
  const profileHeaderParams = {
    tag: 'div',
    classNames: ['profile__header'],
  };
  const profileLogoContainerParams = {
    tag: 'div',
    classNames: ['profile-header__logo-container'],
  };
  const profileLogoImgParams = {
    tag: 'div',
    classNames: ['profile-logo__logo-img'],
    textContent: 'AR',
  };
  const logoUserContainerParams = {
    tag: 'div',
    classNames: ['profile-logo__user-container'],
  };
  const logoUserTitleParams = {
    tag: 'h2',
    classNames: ['profile-logo__user-title'],
    textContent: 'Alex Rawles',
  };
  const logoUserLinkParams = {
    tag: 'a',
    classNames: ['profile-logo__user-link', 'link'],
    textContent: 'alexarawles@gmail.com',
  };
  const buttonContainerParams = {
    tag: 'div',
    classNames: ['profile-header__buttons-container'],
  };
  const buttonContainer = createElement$1(buttonContainerParams);
  const profileHeader = createElement$1(profileHeaderParams);
  const profileLogoContainer = createElement$1(profileLogoContainerParams);
  const profileLogoImg = createElement$1(profileLogoImgParams);
  const logoUserContainer = createElement$1(logoUserContainerParams);
  const logoUserTitle = createElement$1(logoUserTitleParams);
  const logoUserLink = createElement$1(logoUserLinkParams);
  const editbutton = await createEdit();
  const passwrodButton = buildPasswordBtn(userData);
  const addAddressButton = await buildAddAddressBtn();
  addInnerComponent(profileHeader, profileLogoContainer);
  addInnerComponent(profileLogoContainer, profileLogoImg);
  addInnerComponent(profileLogoContainer, logoUserContainer);
  addInnerComponent(logoUserContainer, logoUserTitle);
  addInnerComponent(logoUserContainer, logoUserLink);
  addInnerComponent(profileHeader, buttonContainer);
  addInnerComponent(buttonContainer, addAddressButton);
  addInnerComponent(buttonContainer, passwrodButton);
  addInnerComponent(buttonContainer, editbutton);
  let name = userData.firstName ? userData.firstName : '';
  let lastName = userData.lastName ? userData.lastName : '';
  let mail = userData.email ? userData.email : '';
  profileLogoImg.innerHTML = `${name[0].toUpperCase()}${lastName[0].toUpperCase()}`;
  logoUserTitle.innerHTML = `${name} ${lastName}`;
  logoUserLink.innerHTML = mail;
  logoUserTitle.innerHTML = checkLength(logoUserTitle.innerHTML);
  logoUserLink.innerHTML = checkLength(logoUserLink.innerHTML);
  name = checkLength(name);
  lastName = checkLength(lastName);
  mail = checkLength(mail);
  return profileHeader;
}
function buildPersonalProfile(userData) {
  const infoPersonalInfContainerParams = {
    tag: 'div',
    classNames: ['profile-form__personal-prof-container'],
  };
  const infoPersonalInfContainer = createElement$1(
    infoPersonalInfContainerParams,
  );
  const [infoLabelName, infoInputName] = createInput(
    'Name',
    [
      ['profile-form__name-label', 'prof-label'],
      ['profile-form__name-input', 'prof-input'],
    ],
    'name',
  );
  const infoNameError = createErrorElement();
  addInnerComponent(infoPersonalInfContainer, infoLabelName);
  addInnerComponent(infoLabelName, infoInputName);
  addInnerComponent(infoLabelName, infoNameError);
  infoInputName.setAttribute('readonly', '');
  infoInputName.addEventListener('input', validateInput);
  const [infoLabelLastName, infoInputLastName] = createInput(
    'Last Name',
    [
      ['profile-form__last-name-label', 'prof-label'],
      ['profile-form__last-name-input', 'prof-input'],
    ],
    'name',
  );
  const infoLastNameError = createErrorElement();
  addInnerComponent(infoPersonalInfContainer, infoLabelLastName);
  addInnerComponent(infoLabelLastName, infoInputLastName);
  addInnerComponent(infoLabelLastName, infoLastNameError);
  infoInputLastName.setAttribute('readonly', '');
  infoInputLastName.addEventListener('input', validateInput);
  const dateLabelContainerParam = {
    tag: 'label',
    classNames: ['profile-form__date-label', 'prof-label'],
    textContent: 'Date of Birth',
  };
  const dateLabelContainer = createElement$1(dateLabelContainerParam);
  const dateContainerParam = {
    tag: 'label',
    classNames: ['profile-form__date-container', 'prof-label'],
    attributes: { for: 'Date' },
  };
  const dateContainer = createElement$1(dateContainerParam);
  const dayParam = {
    tag: 'input',
    classNames: ['date__day', 'prof-input', 'date-input'],
    attributes: {
      type: 'text',
      maxLength: '2',
      'data-validation-type': 'day',
      hide: '',
      readonly: '',
    },
  };
  const monthParam = {
    tag: 'input',
    classNames: ['date__month', 'prof-input', 'date-input'],
    attributes: {
      type: 'text',
      maxLength: '2',
      'data-validation-type': 'month',
      hide: '',
      readonly: '',
    },
  };
  const yearParam = {
    tag: 'input',
    classNames: ['date__year', 'prof-input', 'date-input'],
    attributes: {
      type: 'text',
      maxLength: '4',
      'data-validation-type': 'year',
      readonly: '',
      id: 'Date',
      name: 'Date',
    },
  };
  const day = createElement$1(dayParam);
  const month = createElement$1(monthParam);
  const year = createElement$1(yearParam);
  day.addEventListener('input', checkNumber);
  month.addEventListener('input', checkNumber);
  year.addEventListener('input', checkNumber);
  const [infoLabelMail, infoInputMail] = createInput(
    'Email',
    [
      ['profile-form__email-label', 'prof-label'],
      ['profile-form__email-input', 'prof-input'],
    ],
    'email',
  );
  const infoMailError = createErrorElement();
  addInnerComponent(infoPersonalInfContainer, infoLabelMail);
  addInnerComponent(infoLabelMail, infoInputMail);
  addInnerComponent(infoLabelMail, infoMailError);
  infoInputMail.setAttribute('readonly', '');
  infoInputMail.addEventListener('input', validateInput);
  if (userData) {
    const name = userData.firstName ? userData.firstName : '';
    const lastName = userData.lastName ? userData.lastName : '';
    const date = userData.dateOfBirth ? userData.dateOfBirth : '';
    const email = userData.email ? userData.email : '';
    infoInputName.value = name;
    infoInputLastName.value = lastName;
    const yearDate2 = date.slice(0, 4);
    const dayDate2 = date.slice(8, 12);
    const monthDate2 = date.slice(5, 7);
    const infoDateError = createErrorElement();
    infoInputMail.value = email;
    infoDateError.classList.add('error-date');
    day.value = dayDate2;
    month.value = monthDate2;
    year.value = yearDate2;
    addInnerComponent(infoPersonalInfContainer, dateLabelContainer);
    addInnerComponent(dateLabelContainer, infoDateError);
    addInnerComponent(dateLabelContainer, dateContainer);
    addInnerComponent(dateContainer, day);
    addInnerComponent(dateContainer, month);
    addInnerComponent(dateContainer, year);
  }
  return infoPersonalInfContainer;
}
async function buildProfileForm(data) {
  const infoFormParams = {
    tag: 'form',
    classNames: ['profile-container__profile-form'],
    attributes: { id: 'profile-form' },
  };
  const addressProfile = await buildAddressProfile(data);
  const personalProfile = buildPersonalProfile(data);
  const infoForm = createElement$1(infoFormParams);
  addInnerComponent(infoForm, personalProfile);
  addInnerComponent(infoForm, addressProfile);
  fillObjectWithUniqueKeys(infoForm, true, validStatus);
  return infoForm;
}
async function createInfo() {
  const profileContainerParams = {
    tag: 'div',
    classNames: ['profile-container'],
  };
  const profileContainer = createElement$1(profileContainerParams);
  const profileWrapperParams = {
    tag: 'div',
    classNames: ['profile-container__profile-wrapper'],
  };
  try {
    const userData = await getUserData();
    const profileWrapper = createElement$1(profileWrapperParams);
    const header = await buildProfileHeader(userData);
    const form = await buildProfileForm(userData);
    if (form) {
      addInnerComponent(profileContainer, profileWrapper);
      addInnerComponent(profileWrapper, header);
      addInnerComponent(profileWrapper, form);
    }
    return profileContainer;
  } catch (err) {
    return;
  }
}
async function buildUserProfilePage() {
  const userProfilePageParams = {
    tag: 'div',
    classNames: ['user-profile-page'],
  };
  const profileImgParams = {
    tag: 'img',
    classNames: ['profile__img'],
    attributes: {
      alt: 'Profile Page Background Image',
      src: '/assets/registration/background.jpg',
    },
  };
  const profileImg = createElement$1(profileImgParams);
  const userProfilePage = createElement$1(userProfilePageParams);
  const infoContainer = await createInfo();
  const header = createHeader();
  if (infoContainer) {
    addInnerComponent(userProfilePage, header);
    addInnerComponent(userProfilePage, profileImg);
    addInnerComponent(userProfilePage, infoContainer);
  }
  return userProfilePage;
}
function matchPath(route, path) {
  const routeSegments = route.split('/').filter(Boolean);
  const pathSegments = path.split('/').filter(Boolean);
  if (routeSegments.length !== pathSegments.length) {
    return null;
  }
  const params = {};
  for (let i = 0; i < routeSegments.length; i++) {
    const routeSegment = routeSegments[i];
    const pathSegment = pathSegments[i];
    if (routeSegment.startsWith(':')) {
      const paramName = routeSegment.slice(1);
      params[paramName] = pathSegment;
    } else if (routeSegment !== pathSegment) {
      return null;
    }
  }
  return { params };
}
function createRouter(routes2) {
  const router2 = {
    routes: routes2,
    async handleLocationChange() {
      const appElement = document.getElementById('app');
      const path = window.location.pathname;
      const isLoggedIn = Boolean(localStorage.getItem('token'));
      if (path.startsWith('/profile') && !isLoggedIn) {
        this.navigate('/login');
        return;
      }
      if ((path === '/login' || path === '/register') && isLoggedIn) {
        this.navigate('/');
        return;
      }
      const routeKeys = Object.keys(this.routes);
      let handler = null;
      let params = {};
      for (const route of routeKeys) {
        const match = matchPath(route, path);
        if (match) {
          handler = this.routes[route];
          params = match.params;
          break;
        }
      }
      if (!handler) {
        handler = notFoundPage;
      }
      const view = await handler(params);
      if (appElement) {
        appElement.innerHTML = '';
        appElement.appendChild(view);
      } else {
        console.error("The element with ID 'app' was not found in the DOM.");
      }
    },
    navigate(path) {
      window.history.pushState({}, '', path);
      this.handleLocationChange();
    },
  };
  window.addEventListener('popstate', () => {
    router2.handleLocationChange();
  });
  return router2;
}
const routes = {
  '/': createMainPage,
  '/login': createAuthPage,
  '/register': buildRegistrationPage,
  '/404': notFoundPage,
  '/catalog': createCatalogPage,
  '/profile/:id': buildUserProfilePage,
  '/product/:id': createDetailedProductPage,
};
const router = createRouter(routes);
function navigateTo(path) {
  window.history.pushState({}, '', path);
  router.handleLocationChange();
}
function navigateToProfile(userId) {
  router.navigate(`/profile/${userId}`);
}
isUserLogined();
router.handleLocationChange();
fetchProducts();
//# sourceMappingURL=index.js.map
